<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>주소 → 지도 & 그룹 묶기</title>
    <script
  type="text/javascript"
  src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=ms2yp98bvf&submodules=geocoder">
</script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
      body {
        font-family: "Pretendard", "Noto Sans KR", sans-serif;
        margin: 0;
        display: flex;
        height: 100vh;
        overflow: hidden;
        background: #f5f7fa;
      }
      #sidebar {
        width: 420px;
        background: #fff;
        box-shadow: 3px 0 10px rgba(0, 0, 0, 0.05);
        display: flex;
        flex-direction: column;
        transition: all 0.3s ease;
      }
      #sidebar.hidden {
        width: 0;
        overflow: hidden;
      }
      #map {
        flex: 1;
      }

      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #eef2f8;
        padding: 10px 15px;
        font-weight: bold;
        font-size: 18px;
        border-bottom: 1px solid #dce3ef;
      }
      header button {
        background: #007aff;
        color: white;
        border: none;
        border-radius: 8px;
        padding: 5px 10px;
        cursor: pointer;
      }

      details {
        padding: 10px 15px;
        background: #fafbfd;
        border-bottom: 1px solid #eee;
      }
      summary {
        cursor: pointer;
        font-weight: 600;
        color: #444;
        list-style: none;
      }

      input,
      button,
      select,
      textarea {
        margin: 5px 0;
        padding: 7px;
        font-size: 13px;
        border: 1px solid #ccc;
        border-radius: 6px;
      }

      #group-list {
        flex: 1;
        overflow-y: auto;
        padding: 10px 15px;
      }

      .group-box {
        margin-bottom: 8px;
        border-radius: 10px;
        border: 1px solid #ddd;
        background: #fafafa;
        transition: all 0.2s;
      }
      .group-box:hover {
        background: #eef6ff;
      }
      .group-header {
        padding: 8px 10px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .group-header.overloaded {
        color: #e00;
      }
      .group-contents {
        padding: 5px 15px;
        display: none;
      }
      .group-box.open .group-contents {
        display: block;
      }

      .address-item {
        padding: 5px 0;
        border-bottom: 1px dashed #ddd;
        font-size: 13px;
        cursor: grab;
      }
      .address-item:hover {
        background: #f0f7ff;
      }
      .address-item:active {
        cursor: grabbing;
      }

      .info-window {
        font-size: 13px;
        line-height: 1.4;
        max-width: 260px;
        max-height: 200px;
        overflow-y: auto;
      }

      @media (max-width: 768px) {
        #sidebar {
          width: 100%;
          position: absolute;
          z-index: 10;
          height: 50%;
        }
        #map {
          height: 50%;
        }
      }
    </style>
  </head>
  <body>
    <div id="sidebar">
      <header>
        <span>주소 → 지도 & 그룹 묶기</span>
        <button onclick="toggleSidebar()">지도만 보기</button>
      </header>

      <details open id="settings-panel">
        <summary>설정 펼치기/접기</summary>
        <div>
          <label
            >엑셀 파일
            <input type="file" id="excelFile" accept=".xlsx, .xls" /></label
          ><br />
          <label
            >주소열
            <input id="addressCol" type="number" value="14" style="width: 60px"
          /></label>
          <label
            >품목열
            <input
              id="itemCol"
              type="number"
              value="10"
              style="width: 60px" /></label
          ><br />
          <label
            >최대 가구 수
            <input
              id="maxGroupSize"
              type="number"
              value="12"
              style="width: 80px" /></label
          ><br />
          <button onclick="geocodeAll()">1단계: 주소 지오코딩</button>
          <button onclick="clearList()">현재 목록 초기화</button>
          <button onclick="groupAddresses()">2단계: 조건으로 그룹 묶기</button>
          <button onclick="exportExcel()">엑셀로 내보내기</button>
        </div>
      </details>

      <div style="padding: 5px 15px">
        보기:
        <button onclick="setFilter('all')">모두</button>
        <button onclick="setFilter('group')">그룹만</button>
        <button onclick="setFilter('ungrouped')">미지정만</button>
        <div
          id="status"
          style="margin-top: 6px; font-size: 13px; color: #666"
        ></div>
      </div>

      <div id="group-list"></div>
    </div>

    <div id="map"></div>

    <script>
      let map,
        markers = [],
        groups = [],
        addressData = [],
        dragged = null,
        filterMode = "all";

      function initMap() {
        map = new naver.maps.Map("map", {
          center: new naver.maps.LatLng(37.158135, 127.103159),
          zoom: 9,
        });
      }

      function toggleSidebar() {
        document.getElementById("sidebar").classList.toggle("hidden");
      }

      function setFilter(mode) {
        filterMode = mode;
        renderGroups();
      }

      document.getElementById("excelFile").addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (evt) => {
          const data = new Uint8Array(evt.target.result);
          const workbook = XLSX.read(data, { type: "array" });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          const json = XLSX.utils.sheet_to_json(sheet, { header: 1 });
          const addrCol =
            parseInt(document.getElementById("addressCol").value) - 1;
          const itemCol =
            parseInt(document.getElementById("itemCol").value) - 1;
          addressData = json
            .filter((r) => r[addrCol])
            .map((r) => ({
              original: r[addrCol],
              item: r[itemCol],
              group: null,
            }));
          renderGroups();
        };
        reader.readAsArrayBuffer(file);
      });

      async function geocodeAll() {
        const cache = JSON.parse(localStorage.getItem("geocodeCache") || "{}");
        const geocoder = naver.maps.Service;
        let updated = 0;
        for (let row of addressData) {
          if (!cache[row.original]) {
            await new Promise((res) => {
              geocoder.geocode({ query: row.original }, (status, resData) => {
                if (status === "OK" && resData.v2.addresses[0]) {
                  const loc = resData.v2.addresses[0];
                  cache[row.original] = {
                    lat: parseFloat(loc.y),
                    lng: parseFloat(loc.x),
                  };
                  updated++;
                }
                res();
              });
            });
          }
        }
        localStorage.setItem("geocodeCache", JSON.stringify(cache));
        alert(`지오코딩 완료. 새로 추가된 ${updated}건`);
      }

      function groupAddresses() {
        const cache = JSON.parse(localStorage.getItem("geocodeCache") || "{}");
        const coords = addressData
          .map((a) => ({ ...a, ...cache[a.original] }))
          .filter((a) => a.lat);
        const maxGroupSize = parseInt(
          document.getElementById("maxGroupSize").value
        );
        const groupCount = Math.ceil(coords.length / maxGroupSize);
        const colors = [
          "#007bff",
          "#ff6600",
          "#28a745",
          "#dc3545",
          "#6f42c1",
          "#20c997",
          "#fd7e14",
        ];
        groups = [];
        for (let i = 0; i < groupCount; i++) {
          groups.push({
            id: i + 1,
            color: colors[i % colors.length],
            items: [],
          });
        }
        coords.forEach((c, i) => {
          const g = groups[i % groupCount];
          g.items.push(c);
          c.group = g.id;
        });
        renderGroups();
        renderMarkers();
      }

      function renderMarkers() {
        markers.forEach((m) => m.setMap(null));
        markers = [];
        const cache = JSON.parse(localStorage.getItem("geocodeCache") || "{}");
        groups.forEach((g) => {
          g.items.forEach((item) => {
            if (!item.lat || !item.lng) return;
            const marker = new naver.maps.Marker({
              position: new naver.maps.LatLng(item.lat, item.lng),
              map,
              icon: {
                content: `<div style="background:${g.color};color:white;border-radius:50%;width:22px;height:22px;display:flex;align-items:center;justify-content:center;font-size:12px;">${g.id}</div>`,
              },
            });
            const info = new naver.maps.InfoWindow({
              content: `<div class="info-window"><b>그룹 ${g.id}</b><br>${item.original}<hr><b>품목</b><br>${item.item}</div>`,
            });
            naver.maps.Event.addListener(marker, "click", () => {
              info.open(map, marker);
            });
            naver.maps.Event.addListener(map, "click", () => {
              info.close();
            });
            markers.push(marker);
          });
        });
      }

      function renderGroups() {
        const list = document.getElementById("group-list");
        list.innerHTML = "";
        const frag = document.createDocumentFragment();
        groups.forEach((g) => {
          if (filterMode === "ungrouped" && g.items.length > 0) return;
          if (filterMode === "group" && g.items.length === 0) return;
          const box = document.createElement("div");
          box.className = "group-box";
          box.style.borderColor = g.color;
          const header = document.createElement("div");
          header.className = "group-header";
          header.innerHTML = `그룹 ${g.id} (${g.items.length} 가구)`;
          header.addEventListener("click", () => {
            box.classList.toggle("open");
            fitToGroup(g);
          });
          box.appendChild(header);

          const content = document.createElement("div");
          content.className = "group-contents";
          g.items.forEach((a) => {
            const div = document.createElement("div");
            div.className = "address-item";
            div.draggable = true;
            div.innerHTML = `• ${a.original}<br><small style="color:#777">${a.item}</small>`;
            div.ondragstart = () => (dragged = a);
            div.ondragend = () => (dragged = null);
            div.ondblclick = () => focusMarker(a);
            content.appendChild(div);
          });
          box.appendChild(content);
          box.ondragover = (e) => {
            e.preventDefault();
          };
          box.ondrop = (e) => {
            if (!dragged) return;
            const oldGroup = groups.find((x) => x.id === dragged.group);
            if (oldGroup)
              oldGroup.items = oldGroup.items.filter((x) => x !== dragged);
            g.items.push(dragged);
            dragged.group = g.id;
            renderGroups();
            renderMarkers();
          };
          frag.appendChild(box);
        });
        list.appendChild(frag);
        document.getElementById(
          "status"
        ).textContent = `그룹 수: ${groups.length}`;
      }

      function focusMarker(a) {
        map.setCenter(new naver.maps.LatLng(a.lat, a.lng));
        map.setZoom(14);
      }

      function fitToGroup(g) {
        if (!g.items.length) return;
        const bounds = new naver.maps.LatLngBounds();
        g.items.forEach((a) =>
          bounds.extend(new naver.maps.LatLng(a.lat, a.lng))
        );
        map.fitBounds(bounds);
      }

      function clearList() {
        if (confirm("현재 목록을 초기화할까요? (주소 캐시는 유지됩니다)")) {
          groups = [];
          addressData = [];
          renderGroups();
          renderMarkers();
        }
      }

      function exportExcel() {
        if (!addressData.length) {
          alert("데이터가 없습니다.");
          return;
        }
        const wsData = [["원본주소", "품목", "그룹"]];
        addressData.forEach((a) =>
          wsData.push([a.original, a.item, a.group || "미지정"])
        );
        const ws = XLSX.utils.aoa_to_sheet(wsData);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "결과");
        XLSX.writeFile(wb, "그룹결과.xlsx");
      }

      window.onload = initMap;
    </script>
  </body>
</html>
