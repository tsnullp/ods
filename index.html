<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>Î∞∞Ï∞® ÏãúÏä§ÌÖú (ÎÑ§Ïù¥Î≤Ñ ÏßÄÎèÑ + ÏóëÏÖÄ)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Naver Map -->
    <script
      type="text/javascript"
      src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=ms2yp98bvf&submodules=geocoder"
    ></script>
    <!-- Excel Readers/Writers -->
    <script src="https://unpkg.com/read-excel-file@5.7.1/bundle/read-excel-file.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <style>
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #f9fafb;
        color: #111827;
        display: flex;
        flex-direction: column;
      }
      header {
        background: #3b82f6;
        color: #fff;
        padding: 10px 16px;
        font-weight: 700;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      header .file-name {
        font-size: 13px;
        opacity: 0.9;
      }

      #container {
        display: flex;
        flex: 1;
        min-height: 0;
      }
      #map-wrapper {
        position: relative;
        flex: 2;
        min-width: 0;
      }
      #map {
        width: 100%;
        height: 100%;
      }

      /* ÏÉÅÎã® Í∑∏Î£π ÏöîÏïΩ */
      #group-summary {
        position: absolute;
        left: 8px;
        right: 8px;
        top: 8px;
        z-index: 20;
        background: rgba(243, 244, 246, 0.95);
        border-radius: 16px;
        padding: 6px 8px;
        border: 1px solid #e5e7eb;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        max-height: 120px;
        overflow: auto;
      }
      .group-chip {
        font-size: 11px;
        padding: 4px 10px;
        border-radius: 999px;
        cursor: pointer;
        white-space: nowrap;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        background: #e5e7eb;
        border: 1px solid transparent;
      }
      .group-chip .color-dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
      }
      .group-chip.active {
        border-color: #111827;
        background: #dbeafe;
        font-weight: 700;
      }

      /* Ï¢åÏ∏° ÏÉÅÏÑ∏ Ïπ¥Îìú */
      #detail {
        position: absolute;
        left: 12px;
        bottom: 12px;
        width: 340px;
        max-height: 62%;
        border-radius: 14px;
        border: 1px solid #e5e7eb;
        background: rgba(249, 250, 251, 0.97);
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.25);
        overflow: hidden;
        font-size: 12px;
        display: none;
        z-index: 15;
      }
      .detail-header {
        padding: 8px 10px;
        color: #fff;
      }
      .detail-header-title {
        font-size: 11px;
        opacity: 0.9;
      }
      .detail-header-addr {
        font-size: 13px;
        font-weight: 700;
        margin-top: 2px;
      }
      .detail-body {
        padding: 8px 10px 10px;
        background: #f9fafb;
      }
      .detail-summary {
        font-size: 11px;
        color: #4b5563;
        margin-bottom: 6px;
      }
      .detail-set-title {
        font-weight: 700;
        margin-top: 6px;
      }
      .detail-body ul {
        margin: 2px 0 4px 18px;
        padding: 0;
      }

      /* ÏÇ¨Ïù¥ÎìúÎ∞î(Ïò§Î•∏Ï™Ω Î¶¨Ïä§Ìä∏) */
      #sidebar {
        flex: 1;
        min-width: 340px;
        max-width: 480px;
        border-left: 1px solid #e5e7eb;
        background: #fff;
        display: flex;
        flex-direction: column;
      }
      #group-header-fixed {
        padding: 8px 10px 0;
      }
      #group-list {
        flex: 1;
        padding: 4px 10px 10px;
        overflow: auto;
      }
      .group-block {
        margin-top: 4px;
        border-radius: 10px;
        border: 1px solid #e5e7eb;
        background: #f9fafb;
      }
      .group-header {
        padding: 8px 10px;
        font-size: 13px;
        font-weight: 700;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-radius: 10px;
        background: #e5e7eb;
      }
      .group-header.active {
        box-shadow: inset 0 0 0 1px #111827;
        background: #e5effe;
      }
      .group-body {
        padding: 6px 8px 8px;
      }
      .group-color-pill {
        width: 14px;
        height: 14px;
        border-radius: 999px;
        margin-right: 6px;
      }
      .group-header-left {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .house-item {
        margin-top: 6px;
        padding: 6px 8px;
        background: #fff;
        border-radius: 8px;
        border: 1px solid #e5e7eb;
        font-size: 12px;
        cursor: pointer;
        display: grid;
        gap: 3px;
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.05);
        line-height: 1.35;
      }
      .house-item.active {
        border-color: #3b82f6;
        box-shadow: 0 0 0 1px #3b82f6;
      }
      .house-main {
        font-weight: 700;
        font-size: 13px;
      }
      .house-rep {
        font-size: 12px;
        color: #1d4ed8;
      }
      .house-sub {
        font-size: 11px;
        color: #6b7280;
      }
      .house-bottom {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 2px;
      }
      .house-bottom select {
        font-size: 11px;
        padding: 2px 4px;
      }

      footer {
        padding: 6px 12px;
        border-top: 1px solid #e5e7eb;
        background: #f3f4f6;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 12px;
        gap: 8px;
      }
      input[type="file"] {
        display: none;
      }
      label.upload-btn {
        background: #3b82f6;
        color: #fff;
        border-radius: 6px;
        padding: 6px 10px;
        cursor: pointer;
        font-size: 12px;
      }
      button.export-btn {
        background: #10b981;
        color: #fff;
        border-radius: 6px;
        padding: 6px 10px;
        cursor: pointer;
        font-size: 12px;
        border: 0;
      }
      button.small-btn {
        background: #6b7280;
        color: #fff;
        border-radius: 6px;
        padding: 4px 8px;
        font-size: 11px;
        border: 0;
        cursor: pointer;
      }

      #truckCount {
        width: 52px;
        padding: 3px 4px;
        font-size: 11px;
      }
      #log {
        font-size: 11px;
        color: #6b7280;
        max-width: 280px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      /* Ïù∏Ìè¨Ïπ¥Îìú(ÏßÄÎèÑ ÌåùÏóÖ) - ÏµúÏÜå Ï†ïÎ≥¥ */
      .info-card {
        font-size: 11px;
        border-radius: 10px;
        overflow: hidden;
        min-width: 260px;
        max-width: 320px;
        box-shadow: 0 8px 16px rgba(15, 23, 42, 0.25);
        background: #f9fafb;
      }
      .info-card-header {
        padding: 6px 8px;
        color: #fff;
      }
      .info-card-header-top {
        font-size: 11px;
        opacity: 0.9;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .info-card-header-title {
        font-size: 14px;
        font-weight: 700;
        margin-top: 2px;
      }
      .info-card-body {
        padding: 6px 8px 8px;
        background: #f9fafb;
      }
      .info-card-summary {
        margin-bottom: 4px;
        color: #4b5563;
      }
      .info-card-group-line {
        margin-bottom: 4px;
      }
      .info-card-group-line select {
        font-size: 11px;
        padding: 2px 4px;
      }
      .link-product {
        color: #2563eb;
        text-decoration: none;
      }
      .link-product:hover {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <header>
      <div>üì¶ Î∞∞Ï∞® ÏãúÏä§ÌÖú</div>
      <div class="file-name" id="file-name">ÏóëÏÖÄ ÌååÏùºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</div>
    </header>

    <div id="container">
      <div id="map-wrapper">
        <div id="map"></div>
        <div id="group-summary"></div>
        <div id="detail"></div>
      </div>
      <div id="sidebar">
        <div id="group-header-fixed"></div>
        <div id="group-list"></div>
      </div>
    </div>

    <footer>
      <div>
        <label for="fileInput" class="upload-btn">ÏóëÏÖÄ Î∂àÎü¨Ïò§Í∏∞</label>
        <input id="fileInput" type="file" accept=".xlsx,.xls" />
        <span id="log"></span>
      </div>
      <div style="display: flex; align-items: center; gap: 6px">
        <span>Ï∞®Îüâ Ïàò</span>
        <input id="truckCount" type="number" min="1" />
        <button class="small-btn" id="regroupBtn">ÏûêÎèô Í∑∏Î£π Ïû¨Î∞∞Ïπò</button>
        <button class="small-btn" id="orderToggleBtn">ÏàúÏÑú Ï†ïÎ∞©Ìñ•</button>
        <button class="export-btn" id="exportBtn">ÏóëÏÖÄ ÎÇ¥Î≥¥ÎÇ¥Í∏∞</button>
      </div>
    </footer>

    <script>
      /* ===== ÏÉÅÏàò/ÏÉÅÌÉú ===== */
      const START_POINT_LAT = 37.158135;
      const START_POINT_LNG = 127.103159;
      const CBM_PRECISION = 3;

      const CITY_CENTERS = {
        PYEONGTAEK: { lat: 36.992, lng: 127.112 },
        HWASEONG: { lat: 37.199, lng: 126.833 },
        ANSEONG: { lat: 37.01, lng: 127.27 },
      };
      const OUTSKIRTS_RADIUS_KM = 10;
      const ANSEONG_MIN_FOR_SOLO = 8;
      const GROUP_TARGET_SIZE = 12;

      /* Î∞∞ÏßÄ Î∞∞Í≤Ω Ìà¨Î™ÖÎèÑ(Îçî Ïó∞ÌïòÍ≤å) */
      const BADGE_ALPHA = 0.25;

      /* Í∑∏Î£π ÏÉâÏÉÅ */
      const GROUP_COLORS = [
        "#ef4444",
        "#3b82f6",
        "#22c55e",
        "#eab308",
        "#a855f7",
        "#f97316",
        "#06b6d4",
        "#ec4899",
        "#64748b",
        "#84cc16",
        "#0ea5e9",
        "#6366f1",
        "#14b8a6",
        "#f97373",
      ];

      let map = null,
        headers = [],
        originalRows = [],
        households = [],
        groups = [],
        targetGroupCount = null;
      const markerByHouseId = new Map();
      const infoWindow = new naver.maps.InfoWindow({
        anchorSkew: true,
        borderWidth: 0,
        backgroundColor: "transparent",
      });

      const uiState = {
        focusedGroupId: null,
        focusedHouseholdId: null,
        orderReverse: false,
      };

      /* ===== Î°úÍ∑∏ ===== */
      function logInfo(m) {
        console.log("INFO:", m);
        const el = document.getElementById("log");
        if (el) el.textContent = m;
      }
      function logError(m, e) {
        console.error("ERROR:", m, e || "");
        const el = document.getElementById("log");
        if (el) el.textContent = "‚ö†Ô∏è " + m;
      }
      window.addEventListener("error", (e) =>
        logError(`Ï†ÑÏó≠ Ïò§Î•ò: ${e.message}`)
      );
      window.addEventListener("unhandledrejection", (e) =>
        logError(
          `ÎπÑÎèôÍ∏∞ Ïò§Î•ò: ${e.reason && e.reason.message ? e.reason : e.reason}`
        )
      );

      /* ===== Ïú†Ìã∏ ===== */
      function haversineKm(lat1, lon1, lat2, lon2) {
        const R = 6371,
          dLat = ((lat2 - lat1) * Math.PI) / 180,
          dLon = ((lon2 - lon1) * Math.PI) / 180;
        const x =
          Math.sin(dLat / 2) ** 2 +
          Math.cos((lat1 * Math.PI) / 180) *
            Math.cos((lat2 * Math.PI) / 180) *
            Math.sin(dLon / 2) ** 2;
        return R * 2 * Math.atan2(Math.sqrt(x), Math.sqrt(1 - x));
      }
      function normalizeAddress(raw) {
        if (!raw) return "";
        return String(raw)
          .replace(/ÎåÄÌïúÎØºÍµ≠|Republic of Korea/gi, "")
          .replace(/\s+/g, " ")
          .replace(/[(),]/g, "")
          .trim();
      }
      function findHeaderIndex(names, fallback = -1) {
        const lower = headers.map((h) => String(h).trim().toLowerCase());
        for (const n of names) {
          const idx = lower.indexOf(String(n).toLowerCase());
          if (idx !== -1) return idx;
        }
        return fallback;
      }
      function makeCoupangUrl(q) {
        return q
          ? "https://www.coupang.com/np/search?component=&q=" +
              encodeURIComponent(q)
          : "https://www.coupang.com/";
      }
      function escapeHtml(s) {
        return String(s)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }
      function formatSetPartSummary(setCount, partCount) {
        return partCount <= 1
          ? `ÏÑ∏Ìä∏ ${setCount}Í∞ú`
          : `ÏÑ∏Ìä∏ ${setCount}Í∞ú ¬∑ Î∂ÄÌíà ${partCount}Í∞ú`;
      }
      function formatTelHref(p) {
        return p ? "tel:" + String(p).replace(/[^\d+]/g, "") : "";
      }

      /* ===== ÌååÏùº Î°úÎìú/ÌååÏã± ===== */
      async function handleFile(file) {
        try {
          logInfo("ÏóëÏÖÄ ÏùΩÎäî Ï§ë...");
          const rows = await readXlsxFile(file);
          if (!rows || rows.length < 2) {
            logError("ÏóëÏÖÄÏóê Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.");
            return;
          }
          headers = rows[0].map((h) => (h == null ? "" : String(h)));
          originalRows = rows.slice(1).map((cells, idx) => ({
            rowId: idx,
            cells: cells.map((c) => (c == null ? "" : c)),
          }));

          logInfo("Í∞ÄÍµ¨ Îã®ÏúÑÎ°ú Î≥ÄÌôò...");
          buildHouseholds();

          logInfo("ÏßÄÏò§ÏΩîÎî©...");
          await geocodeAllHouseholds();

          logInfo("ÏßÄÏó≠ ÌÉúÍπÖ...");
          tagRegions();

          logInfo("Í∂åÏû• Í∑∏Î£π Ïàò Í≥ÑÏÇ∞...");
          computeRecommendedGroupCount();

          logInfo("ÏßÄÏó≠ Í∑úÏπô Í∏∞Î∞ò ÏûêÎèô Í∑∏Î£πÌïë...");
          autoGroupRegional();

          fitGroupCountToTarget();

          if (groups.length > 0) uiState.focusedGroupId = groups[0].id;

          logInfo(
            `Î†åÎçîÎßÅ... (Í∂åÏû• Í∑∏Î£πÏàò=${targetGroupCount}, Ïã§Ï†ú=${groups.length})`
          );
          renderAll();
          logInfo("ÏôÑÎ£å");
        } catch (e) {
          logError("ÏóëÏÖÄ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò", e);
        }
      }

      function buildHouseholds() {
        const idxAddress = findHeaderIndex(["Address", "Ï£ºÏÜå"], 0);
        const idxCBM = findHeaderIndex(["CBM"], -1);
        const idxPhone = findHeaderIndex(["Ï†ÑÌôîÎ≤àÌò∏", "phone", "tel"], 11);
        const idxVIName = findHeaderIndex(["VI Name"], 7);
        const idxSKUName = findHeaderIndex(["SKU Name"], 9);
        const idxVINum = findHeaderIndex(["VI Number", "VINumber"], -1);

        const mapByNorm = new Map();
        for (const row of originalRows) {
          const raw = row.cells[idxAddress];
          const norm = normalizeAddress(raw);
          if (!norm) continue;
          if (!mapByNorm.has(norm)) {
            mapByNorm.set(norm, {
              id: null,
              rawAddress: raw,
              normAddress: norm,
              rows: [],
              sets: [],
              totalSets: 0,
              totalParts: 0,
              cbmSum: 0,
              lat: null,
              lng: null,
              distance: null,
              groupId: null,
              representLabel: "",
              orderInGroup: null,
              phone: null,
              city: "OTHER",
              isOutskirts: false,
            });
          }
          const h = mapByNorm.get(norm);
          h.rows.push(row);
          if (idxCBM !== -1) {
            const v = parseFloat(row.cells[idxCBM]);
            if (!isNaN(v)) h.cbmSum += v;
          }
          if (idxPhone !== -1 && !h.phone) {
            const ph = row.cells[idxPhone];
            if (ph) h.phone = String(ph);
          }
        }

        households = Array.from(mapByNorm.values());
        households.forEach((h, idx) => {
          h.id = idx;
          const setMap = new Map();
          for (const row of h.rows) {
            const viNum = idxVINum !== -1 ? row.cells[idxVINum] : "";
            const viName = idxVIName !== -1 ? row.cells[idxVIName] : "";
            const skuName = idxSKUName !== -1 ? row.cells[idxSKUName] : "";
            const key =
              (viNum && String(viNum)) ||
              (viName && "VI:" + String(viName)) ||
              "SKU:" + String(skuName) + "#" + row.rowId;
            if (!setMap.has(key))
              setMap.set(key, {
                key,
                viName: viName || "",
                rows: [],
                skuNames: [],
              });
            const s = setMap.get(key);
            s.rows.push(row);
            if (skuName) s.skuNames.push(String(skuName));
          }
          const sets = [];
          for (const [, s] of setMap) {
            let rep;
            if (s.rows.length === 1)
              rep =
                (idxSKUName !== -1 && s.rows[0].cells[idxSKUName]) ||
                s.viName ||
                "(ÌíàÎ™©)";
            else rep = s.viName || s.skuNames[0] || "(Ï°∞Î¶ΩÌíà)";
            sets.push({
              key: s.key,
              representName: String(rep),
              rows: s.rows,
              skuCount: s.rows.length,
            });
          }
          h.sets = sets;
          h.totalSets = sets.length;
          h.totalParts = h.rows.length;
          if (sets.length === 0) h.representLabel = "(ÌíàÎ™© ÏóÜÏùå)";
          else if (sets.length === 1) h.representLabel = sets[0].representName;
          else
            h.representLabel = `${sets[0].representName} Ïô∏ ${
              sets.length - 1
            }Í±¥`;
        });
      }

      function geocodeAddress(q) {
        return new Promise((res) => {
          naver.maps.Service.geocode({ query: q }, (st, resp) => {
            if (st !== naver.maps.Service.Status.OK) res(null);
            else res(resp);
          });
        });
      }
      async function geocodeAllHouseholds() {
        const total = households.length;
        let done = 0;
        for (const h of households) {
          try {
            const r = await geocodeAddress(h.normAddress || h.rawAddress);
            if (r && r.v2 && r.v2.addresses && r.v2.addresses.length > 0) {
              const a = r.v2.addresses[0];
              const lat = parseFloat(a.y),
                lng = parseFloat(a.x);
              if (!isNaN(lat) && !isNaN(lng)) {
                h.lat = lat;
                h.lng = lng;
                h.distance = haversineKm(
                  START_POINT_LAT,
                  START_POINT_LNG,
                  lat,
                  lng
                );
              }
            }
          } catch (e) {
          } finally {
            done++;
            logInfo(`ÏßÄÏò§ÏΩîÎî© Ï§ë... (${done}/${total})`);
          }
        }
      }

      /* ===== ÏßÄÏó≠ ÌÉúÍπÖ & Í∂åÏû• Í∑∏Î£π Ïàò ===== */
      function inferCityFromAddress(raw) {
        const s = String(raw || "");
        if (/ÏïàÏÑ±Ïãú/.test(s)) return "ANSEONG";
        if (/ÌèâÌÉùÏãú/.test(s)) return "PYEONGTAEK";
        if (/ÌôîÏÑ±Ïãú/.test(s)) return "HWASEONG";
        return "OTHER";
      }
      function tagRegions() {
        households.forEach((h) => {
          h.city = inferCityFromAddress(h.rawAddress);
          if (h.lat != null && h.lng != null) {
            const centers = CITY_CENTERS[h.city];
            if (centers) {
              const d = haversineKm(centers.lat, centers.lng, h.lat, h.lng);
              h.isOutskirts = d > OUTSKIRTS_RADIUS_KM;
            } else h.isOutskirts = false;
          } else h.isOutskirts = false;
        });
      }

      function computeRecommendedGroupCount() {
        const total = households.length;
        const anCnt = households.filter((h) => h.city === "ANSEONG").length;
        const hxOuter = households.filter(
          (h) => h.city === "HWASEONG" && h.isOutskirts
        ).length;
        const ptkOuter = households.filter(
          (h) => h.city === "PYEONGTAEK" && h.isOutskirts
        ).length;

        const anGroups = anCnt > 0 ? 1 : 0;
        const hxGroups = Math.ceil(hxOuter / GROUP_TARGET_SIZE);
        const ptkGroups = Math.ceil(ptkOuter / GROUP_TARGET_SIZE);
        const remaining = total - (anCnt + hxOuter + ptkOuter);
        const restGroups = Math.ceil(
          Math.max(0, remaining) / GROUP_TARGET_SIZE
        );

        targetGroupCount = Math.max(
          1,
          anGroups + hxGroups + ptkGroups + restGroups
        );
        const t = document.getElementById("truckCount");
        if (t) t.value = targetGroupCount;
        logInfo(`Í∂åÏû• Í∑∏Î£π Ïàò: ${targetGroupCount} (Ï¥ù ${total}Í∞ÄÍµ¨)`);
      }

      /* ===== ÏûêÎèô Í∑∏Î£πÌïë(ÏßÄÏó≠ Í∑úÏπô) ===== */
      function autoGroupRegional() {
        groups = [];
        households.forEach((h) => {
          h.groupId = null;
          h.orderInGroup = null;
        });
        let nextGid = 1;
        const pool = new Set(households.map((h) => h.id));
        const take = (ids, gid) => {
          ids.forEach((id) => {
            const h = households.find((x) => x.id === id);
            if (!h) return;
            h.groupId = gid;
            pool.delete(id);
          });
          groups.push({ id: gid, memberIds: ids.slice() });
          nextGid++;
        };

        // 1) ÏïàÏÑ±: Í∞ÄÎä•ÌïòÎ©¥ Îã®ÎèÖ, Î∂ÄÏ°±ÌïòÎ©¥ ÌèâÌÉù Í∑ºÏ†ë Ìè¨Ìï®
        const anseong = households
          .filter((h) => pool.has(h.id) && h.city === "ANSEONG")
          .map((h) => h.id);
        if (anseong.length > 0) {
          if (anseong.length < ANSEONG_MIN_FOR_SOLO) {
            const c = CITY_CENTERS.ANSEONG;
            const ptkNear = households
              .filter((h) => pool.has(h.id) && h.city === "PYEONGTAEK")
              .map((h) => ({
                id: h.id,
                d:
                  h.lat && h.lng
                    ? haversineKm(c.lat, c.lng, h.lat, h.lng)
                    : 9999,
              }))
              .sort((a, b) => a.d - b.d)
              .map((x) => x.id);
            while (anseong.length < GROUP_TARGET_SIZE && ptkNear.length > 0)
              anseong.push(ptkNear.shift());
          }
          take(anseong, nextGid);
        }

        // 2) ÌôîÏÑ± Ïô∏Í≥Ω
        const hxOuterIds = households
          .filter(
            (h) => pool.has(h.id) && h.city === "HWASEONG" && h.isOutskirts
          )
          .map((h) => h.id);
        if (hxOuterIds.length > 0) clusterAndTake(hxOuterIds, "HWASEONG");

        // 3) ÌèâÌÉù Ïô∏Í≥Ω
        const ptkOuterIds = households
          .filter(
            (h) => pool.has(h.id) && h.city === "PYEONGTAEK" && h.isOutskirts
          )
          .map((h) => h.id);
        if (ptkOuterIds.length > 0) clusterAndTake(ptkOuterIds, "PYEONGTAEK");

        // 4) ÎÇòÎ®∏ÏßÄ
        const rest = [...pool];
        if (rest.length > 0) {
          const restHs = rest
            .map((id) => households.find((h) => h.id === id))
            .sort((a, b) => (a.distance ?? 999) - (b.distance ?? 999));
          const unvisited = new Set(restHs.map((h) => h.id));
          while (unvisited.size > 0) {
            const seedId = unvisited.values().next().value;
            const seed = households.find((h) => h.id === seedId);
            if (!seed) break;
            const members = [seedId];
            unvisited.delete(seedId);
            const cands = [];
            for (const hid of unvisited) {
              const h = households.find((x) => x.id === hid);
              if (!h || h.lat == null) continue;
              const d = haversineKm(seed.lat, seed.lng, h.lat, h.lng);
              cands.push({ id: hid, d });
            }
            cands.sort((a, b) => a.d - b.d);
            for (const { id } of cands) {
              if (members.length >= GROUP_TARGET_SIZE) break;
              members.push(id);
              unvisited.delete(id);
            }
            take(members, nextGid);
          }
        }

        computeOrdersForAllGroups();

        function clusterAndTake(idList, cityKey) {
          const hs = idList.map((id) => households.find((h) => h.id === id));
          const sorted = hs
            .sort(
              (a, b) =>
                (a.lat && a.lng ? distCenter(a, cityKey) : 999) -
                (b.lat && b.lng ? distCenter(b, cityKey) : 999)
            )
            .reverse();
          while (sorted.length > 0) {
            const seed = sorted[0];
            const center = { lat: seed.lat, lng: seed.lng };
            const chunk = sorted.map((h) => ({
              id: h.id,
              d:
                h.lat && h.lng
                  ? haversineKm(center.lat, center.lng, h.lat, h.lng)
                  : 999,
            }));
            chunk.sort((a, b) => a.d - b.d);
            const takeIds = chunk.slice(0, GROUP_TARGET_SIZE).map((x) => x.id);
            take(takeIds, nextGid);
            for (const rid of takeIds) {
              const idx = sorted.findIndex((x) => x.id === rid);
              if (idx > -1) sorted.splice(idx, 1);
            }
          }
          function distCenter(h, city) {
            const c = CITY_CENTERS[city];
            return haversineKm(c.lat, c.lng, h.lat, h.lng);
          }
        }
      }

      /* ===== Í∂åÏû• Í∑∏Î£π ÏàòÏóê ÎßûÏ∂∞ Î≥¥Ï†ï ===== */
      function fitGroupCountToTarget() {
        if (!targetGroupCount || targetGroupCount < 1) return;
        const nextGroupId = () =>
          (groups.length ? Math.max(...groups.map((g) => g.id)) : 0) + 1;

        const centroid = (g) => {
          const vs = g.memberIds
            .map((id) => households.find((h) => h.id === id))
            .filter((h) => h && h.lat != null);
          if (vs.length === 0) return null;
          let slat = 0,
            slng = 0;
          vs.forEach((h) => {
            slat += h.lat;
            slng += h.lng;
          });
          return { lat: slat / vs.length, lng: slng / vs.length };
        };

        function splitLargest() {
          const sortable = [...groups].sort(
            (a, b) => b.memberIds.length - a.memberIds.length
          );
          const g = sortable.find((gg) => gg.memberIds.length > 1);
          if (!g) return false;
          const memberHs = g.memberIds
            .map((id) => households.find((h) => h.id === id))
            .filter((h) => h.lat != null && h.lng != null);
          if (memberHs.length < 2) return false;
          let s1 = memberHs[0],
            s2 = memberHs[1],
            md = 0;
          for (let i = 0; i < memberHs.length; i++) {
            for (let j = i + 1; j < memberHs.length; j++) {
              const d = haversineKm(
                memberHs[i].lat,
                memberHs[i].lng,
                memberHs[j].lat,
                memberHs[j].lng
              );
              if (d > md) {
                md = d;
                s1 = memberHs[i];
                s2 = memberHs[j];
              }
            }
          }
          const a = [],
            b = [];
          g.memberIds.forEach((id) => {
            const h = households.find((x) => x.id === id);
            if (h.lat == null) {
              (a.length <= b.length ? a : b).push(id);
              return;
            }
            const d1 = haversineKm(h.lat, h.lng, s1.lat, s1.lng),
              d2 = haversineKm(h.lat, h.lng, s2.lat, s2.lng);
            (d1 <= d2 ? a : b).push(id);
          });
          if (a.length === 0 || b.length === 0) return false;
          g.memberIds = a;
          const newId = nextGroupId();
          groups.push({ id: newId, memberIds: b });
          b.forEach((id) => {
            const h = households.find((x) => x.id === id);
            h.groupId = newId;
          });
          return true;
        }

        function mergeClosest() {
          if (groups.length < 2) return false;
          let p = null,
            md = Infinity;
          for (let i = 0; i < groups.length; i++) {
            for (let j = i + 1; j < groups.length; j++) {
              const c1 = centroid(groups[i]),
                c2 = centroid(groups[j]);
              if (!c1 || !c2) continue;
              const d = haversineKm(c1.lat, c1.lng, c2.lat, c2.lng);
              if (d < md) {
                md = d;
                p = [i, j];
              }
            }
          }
          if (!p) return false;
          const [i, j] = p;
          const g1 = groups[i],
            g2 = groups[j];
          g1.memberIds.push(...g2.memberIds);
          g2.memberIds.forEach((id) => {
            const h = households.find((x) => x.id === id);
            h.groupId = g1.id;
          });
          groups.splice(j, 1);
          return true;
        }

        let safety = 200;
        while (groups.length < targetGroupCount && safety--)
          if (!splitLargest()) break;
        while (groups.length > targetGroupCount && safety--)
          if (!mergeClosest()) break;

        groups.sort((a, b) => a.id - b.id);
        const idMap = new Map();
        groups.forEach((g, idx) => idMap.set(g.id, idx + 1));
        groups.forEach((g) => (g.id = idMap.get(g.id)));
        households.forEach((h) => (h.groupId = idMap.get(h.groupId)));
        computeOrdersForAllGroups();
      }

      /* ===== ÏàúÏÑú Í≥ÑÏÇ∞ ===== */
      function computeOrdersForAllGroups() {
        groups.forEach((g) => computeOrderForGroup(g));
      }
      function computeOrderForGroup(g) {
        const members = g.memberIds
          .map((id) => households.find((h) => h.id === id))
          .filter(Boolean);
        members.forEach((h) => (h.orderInGroup = null));
        let clat = START_POINT_LAT,
          clng = START_POINT_LNG,
          order = 1;
        const withC = members.filter((h) => h.lat != null && h.lng != null);
        const noC = members.filter((h) => h.lat == null || h.lng == null);
        const unvisited = [...withC];
        while (unvisited.length > 0) {
          let bi = 0,
            bd = Infinity;
          for (let i = 0; i < unvisited.length; i++) {
            const h = unvisited[i];
            const d = haversineKm(clat, clng, h.lat, h.lng);
            if (d < bd) {
              bd = d;
              bi = i;
            }
          }
          const next = unvisited.splice(bi, 1)[0];
          next.orderInGroup = order++;
          clat = next.lat;
          clng = next.lng;
        }
        noC.forEach((h) => {
          h.orderInGroup = order++;
        });
      }
      function getDisplayOrder(h) {
        if (h.orderInGroup == null) return null;
        const g = groups.find((gg) => gg.id === h.groupId);
        const size = g ? g.memberIds.length : 1;
        return uiState.orderReverse
          ? size - h.orderInGroup + 1
          : h.orderInGroup;
      }

      /* ===== ÏßÄÎèÑ/ÎßàÏª§ ===== */
      function ensureMap() {
        if (map) return;
        map = new naver.maps.Map("map", {
          center: new naver.maps.LatLng(START_POINT_LAT, START_POINT_LNG),
          zoom: 11,
        });
        new naver.maps.Marker({
          position: new naver.maps.LatLng(START_POINT_LAT, START_POINT_LNG),
          map,
          title: "Ï∂úÎ∞úÏßÄ",
        });
        naver.maps.Event.addListener(map, "click", () => {
          infoWindow.close();
          uiState.focusedHouseholdId = null;
          renderDetail(null);
          renderGroupList();
          updateMarkerAppearance();
        });
      }

      function makeMarkerIcon(
        groupId,
        { focused = false, dimmed = false, orderNumber } = {}
      ) {
        const baseColor = getGroupColor(groupId);
        const zoom =
          window.map && typeof map.getZoom === "function" ? map.getZoom() : 12;
        const radius = (focused ? 17 : 14) + Math.max(0, zoom - 12);
        const padding = 6;
        const diameter = radius * 2 + padding * 2;
        const cx = diameter / 2,
          cy = diameter / 2;

        const pts = [];
        for (let i = 0; i < 6; i++) {
          const ang = (Math.PI / 3) * i - Math.PI / 2;
          pts.push(
            `${cx + radius * Math.cos(ang)},${cy + radius * Math.sin(ang)}`
          );
        }

        // Ïò§Î•∏Ï™Ω-ÏÉÅÎã® Íº≠ÏßìÏ†ê Í∑ºÏ≤ò
        const vx = cx + radius * Math.cos(-Math.PI / 6);
        const vy = cy + radius * Math.sin(-Math.PI / 6);

        // Î∞∞ÏßÄ ÏúÑÏπò/ÌÅ¨Í∏∞
        const badgeR = 9,
          overlap = 7;
        const bx = vx - badgeR + 2 - overlap,
          by = vy - badgeR + 2 - overlap;

        const extraRight = Math.max(0, bx + badgeR * 2 - diameter) + 2;
        const extraTop = Math.max(0, 0 - by) + 2;
        const totalW = diameter + extraRight,
          totalH = diameter + extraTop;

        const fillOpacity = dimmed ? 0.6 : 1.0;
        const centralTextSize = Math.max(12, 12 + (zoom - 12));
        const orderTextSize = 10;

        const badgeSvg =
          orderNumber != null
            ? `
          <g transform="translate(${extraRight / 2},${
                extraTop / 2
              })" filter="url(#mkShadow)">
            <circle cx="${bx + badgeR}" cy="${
                by + badgeR
              }" r="${badgeR}" fill="rgba(17,17,17,${BADGE_ALPHA})" />
            <text x="${bx + badgeR}" y="${
                by + badgeR
              }" text-anchor="middle" dominant-baseline="central"
                  font-size="${orderTextSize}" font-weight="800" fill="#ffffff" style="opacity:.98">${orderNumber}</text>
          </g>`
            : "";

        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${totalW}" height="${totalH}"
                        viewBox="${-extraRight / 2} ${
          -extraTop / 2
        } ${totalW} ${totalH}">
          <defs>
            <filter id="mkShadow" x="-50%" y="-50%" width="200%" height="200%">
              <feDropShadow dx="0" dy="1.2" stdDeviation="1.2" flood-color="rgba(17,24,39,0.45)"/>
            </filter>
          </defs>
          <polygon points="${pts.join(
            " "
          )}" fill="${baseColor}" fill-opacity="${fillOpacity}" stroke="#ffffff" stroke-width="2" filter="url(#mkShadow)"/>
          <text x="${cx}" y="${cy}" text-anchor="middle" dominant-baseline="central"
                font-size="${centralTextSize}" font-weight="800" fill="#ffffff"
                style="paint-order:stroke;stroke:#000;stroke-width:.6;opacity:${
                  dimmed ? 0.9 : 1
                }">${groupId ?? ""}</text>
          ${badgeSvg}
        </svg>`;

        return {
          url: "data:image/svg+xml;charset=UTF-8," + encodeURIComponent(svg),
          size: new naver.maps.Size(totalW, totalH),
          origin: new naver.maps.Point(0, 0),
          anchor: new naver.maps.Point(diameter / 2, diameter / 2),
        };
      }

      function getGroupColor(id) {
        const s = [...groups].sort((a, b) => a.id - b.id);
        const idx = s.findIndex((g) => g.id === id);
        return idx === -1 ? "#6b7280" : GROUP_COLORS[idx % GROUP_COLORS.length];
      }

      function renderMarkers() {
        ensureMap();
        markerByHouseId.forEach((m) => m.setMap(null));
        markerByHouseId.clear();
        households.forEach((h) => {
          if (h.lat == null) return;
          const mk = new naver.maps.Marker({
            position: new naver.maps.LatLng(h.lat, h.lng),
            map,
            title: h.representLabel,
            icon: makeMarkerIcon(h.groupId, {
              orderNumber: getDisplayOrder(h),
            }),
          });
          naver.maps.Event.addListener(mk, "click", () =>
            focusHousehold(h.id, { fromMarker: true, openDetail: true })
          );
          markerByHouseId.set(h.id, mk);
        });
        updateMarkerAppearance();
      }
      function updateMarkerAppearance() {
        markerByHouseId.forEach((mk, id) => {
          const h = households.find((x) => x.id === id);
          if (!h) return;
          const focused = uiState.focusedHouseholdId === h.id;
          const inGroup =
            uiState.focusedGroupId != null &&
            h.groupId === uiState.focusedGroupId;
          const emphasized = focused || inGroup;
          mk.setIcon(
            makeMarkerIcon(h.groupId, {
              focused: emphasized,
              dimmed: !emphasized,
              orderNumber: getDisplayOrder(h),
            })
          );
        });
      }

      /* ===== ÏöîÏïΩ/Î¶¨Ïä§Ìä∏/ÏÉÅÏÑ∏/Ïù∏Ìè¨ÏúàÎèÑÏö∞ ===== */
      function renderGroupSummary() {
        const c = document.getElementById("group-summary");
        c.innerHTML = "";
        if (!groups.length) return;
        const s = [...groups].sort((a, b) => a.id - b.id);
        for (const g of s) {
          const ms = g.memberIds.map((id) =>
            households.find((h) => h.id === id)
          );
          const hc = ms.length,
            ic = ms.reduce((s, h) => s + h.totalParts, 0),
            cbm = ms.reduce((s, h) => s + h.cbmSum, 0).toFixed(CBM_PRECISION);
          const chip = document.createElement("div");
          chip.className =
            "group-chip" + (uiState.focusedGroupId === g.id ? " active" : "");
          const dot = document.createElement("span");
          dot.className = "color-dot";
          dot.style.backgroundColor = getGroupColor(g.id);
          chip.appendChild(dot);
          const text = document.createElement("span");
          text.textContent = `${g.id} (${hc}Í∞ÄÍµ¨ / ÌíàÎ™© ${ic}Í∞ú / CBM ${cbm})`;
          chip.appendChild(text);
          chip.onclick = () => focusGroup(g.id);
          c.appendChild(chip);
        }
      }

      function renderGroupList() {
        const list = document.getElementById("group-list"),
          headerWrap = document.getElementById("group-header-fixed");
        list.innerHTML = "";
        headerWrap.innerHTML = "";
        if (!groups.length) {
          list.textContent = "ÌëúÏãúÌï† Í∑∏Î£πÏù¥ ÏóÜÏäµÎãàÎã§.";
          return;
        }
        const gid = uiState.focusedGroupId || (groups[0] && groups[0].id);
        const g = groups.find((x) => x.id === gid);
        if (!g) {
          list.textContent = "ÌëúÏãúÌï† Í∑∏Î£πÏù¥ ÏóÜÏäµÎãàÎã§.";
          return;
        }

        const members = g.memberIds
          .map((id) => households.find((h) => h.id === id))
          .slice()
          .sort(
            (a, b) => (getDisplayOrder(a) ?? 999) - (getDisplayOrder(b) ?? 999)
          );

        const hc = members.length,
          ic = members.reduce((s, h) => s + h.totalParts, 0),
          cbm = members
            .reduce((s, h) => s + h.cbmSum, 0)
            .toFixed(CBM_PRECISION);
        const header = document.createElement("div");
        header.className = "group-header active";
        const left = document.createElement("div");
        left.className = "group-header-left";
        const pill = document.createElement("div");
        pill.className = "group-color-pill";
        pill.style.backgroundColor = getGroupColor(g.id);
        left.appendChild(pill);
        left.appendChild(
          Object.assign(document.createElement("span"), {
            textContent: `Í∑∏Î£π ${g.id}`,
          })
        );
        const right = document.createElement("span");
        right.textContent = `${hc}Í∞ÄÍµ¨ ¬∑ ÌíàÎ™© ${ic}Í∞ú ¬∑ CBM ${cbm}`;
        header.appendChild(left);
        header.appendChild(right);
        headerWrap.appendChild(header);

        const body = document.createElement("div");
        body.className = "group-body";
        members.forEach((h) => {
          const row = document.createElement("div");
          row.className =
            "house-item" +
            (uiState.focusedHouseholdId === h.id ? " active" : "");
          row.onclick = (e) => {
            if (e.target.tagName.toLowerCase() === "select") return;
            focusHousehold(h.id, { fromList: true, openDetail: true });
          };

          const summaryText =
            formatSetPartSummary(h.totalSets, h.totalParts) +
            ` ¬∑ CBM ${h.cbmSum.toFixed(CBM_PRECISION)}`;
          const repHtml = `ÎåÄÌëú: <a href="${makeCoupangUrl(
            escapeHtml(h.representLabel)
          )}" target="_blank" class="link-product">${escapeHtml(
            h.representLabel
          )}</a>`;
          const dispOrder = getDisplayOrder(h) ?? "-";
          const phoneHtml = h.phone
            ? `<div class="house-sub">üìû <a href="${formatTelHref(
                h.phone
              )}" class="link-product">${escapeHtml(h.phone)}</a></div>`
            : "";

          row.innerHTML = `
            <div class="house-main">[${dispOrder}] ${escapeHtml(
            h.rawAddress
          )}</div>
            <div class="house-rep">${repHtml}</div>
            ${phoneHtml}
            <div class="house-sub">${summaryText}</div>
            <div class="house-bottom">
              <span style="font-size:11px;color:#6b7280;">Í∑∏Î£π ${h.groupId}${
            h.isOutskirts ? " ¬∑ Ïô∏Í≥Ω" : ""
          }${h.city !== "OTHER" ? " ¬∑ " + h.city : ""}</span>
              <select data-house-id="${h.id}">${renderGroupOptions(
            h.groupId
          )}</select>
            </div>`;
          row.querySelector("select").addEventListener("change", (ev) => {
            changeHouseholdGroup(h.id, parseInt(ev.target.value, 10));
          });
          body.appendChild(row);
        });

        const block = document.createElement("div");
        block.className = "group-block";
        block.appendChild(body);
        list.appendChild(block);
      }
      function renderGroupOptions(selId) {
        const s = [...groups].sort((a, b) => a.id - b.id);
        return s
          .map(
            (g) =>
              `<option value="${g.id}" ${g.id == selId ? "selected" : ""}>${
                g.id
              }</option>`
          )
          .join("");
      }

      function renderDetail(h) {
        const el = document.getElementById("detail");
        if (!el) return;
        if (!h) {
          el.style.display = "none";
          el.innerHTML = "";
          return;
        }
        const cbm = h.cbmSum.toFixed(CBM_PRECISION),
          color = getGroupColor(h.groupId || 0);
        const phoneHtml = h.phone
          ? `<div class="detail-summary">Ï†ÑÌôî: <a href="${formatTelHref(
              h.phone
            )}" class="link-product">${escapeHtml(h.phone)}</a></div>`
          : "";

        let html = `
          <div class="detail-header" style="background:${color};">
            <div class="detail-header-title">Í∑∏Î£π ${h.groupId} ¬∑ ÏàúÏÑú ${
          getDisplayOrder(h) ?? "-"
        }</div>
            <div class="detail-header-addr">${escapeHtml(h.rawAddress)}</div>
          </div>
          <div class="detail-body">
            <div class="detail-summary">${formatSetPartSummary(
              h.totalSets,
              h.totalParts
            )} ¬∑ CBM ${cbm}</div>
            ${phoneHtml}
        `;

        // ÏÑ∏Ìä∏ ÎåÄÌëúÎ™Ö + (Î∂ÄÌíà XÍ∞ú), Î∂ÄÌíà Î¶¨Ïä§Ìä∏Îäî 1Í∞úÎ©¥ ÌëúÏãú X / 2Í∞ú Ïù¥ÏÉÅÏù¥Î©¥ Ï¢åÏ∏° ÏÉÅÏÑ∏/Î¶¨Ïä§Ìä∏ÏóêÏÑúÎßå ÌëúÏãú
        const idxSKUName = findHeaderIndex(["SKU Name"], 9);
        h.sets.forEach((s, idx) => {
          const url = makeCoupangUrl(s.representName);
          html += `<div class="detail-set-title">${
            idx + 1
          }) <a href="${url}" target="_blank" class="link-product">${escapeHtml(
            s.representName
          )}</a> (Î∂ÄÌíà ${s.skuCount}Í∞ú)</div>`;
          if (s.skuCount <= 1) return; // ÏÉÅÏÑ∏ÏóêÏÑúÎèÑ Î¶¨Ïä§Ìä∏Îäî ÏÉùÎûµ
        });

        html += "</div>";
        el.innerHTML = html;
        el.style.display = "block";
      }

      // Ïù∏Ìè¨ÏúàÎèÑÏö∞: ÏµúÏÜå Ï†ïÎ≥¥ + Í∑∏Î£π Î≥ÄÍ≤ΩÎßå (Î∂ÄÌíà Î¶¨Ïä§Ìä∏ Ï†úÍ±∞)
      function buildInfoWindowContent(h) {
        const cbm = h.cbmSum.toFixed(CBM_PRECISION),
          color = getGroupColor(h.groupId || 0);
        const groupSelect = `<select id="info-group-select" style="font-size:11px;">${renderGroupOptions(
          h.groupId
        )}</select>`;
        const phoneHtml = h.phone
          ? `<div class="info-card-group-line">Ï†ÑÌôî: <a href="${formatTelHref(
              h.phone
            )}" class="link-product">${escapeHtml(h.phone)}</a></div>`
          : "";

        return `
          <div class="info-card">
            <div class="info-card-header" style="background:${color};">
              <div class="info-card-header-top"><span>Í∑∏Î£π ${
                h.groupId
              } ¬∑ ÏàúÏÑú ${
          getDisplayOrder(h) ?? "-"
        }</span><span>CBM ${cbm}</span></div>
              <div class="info-card-header-title">${escapeHtml(
                h.rawAddress
              )}</div>
            </div>
            <div class="info-card-body">
              <div class="info-card-summary">${formatSetPartSummary(
                h.totalSets,
                h.totalParts
              )}</div>
              <div class="info-card-group-line">Í∑∏Î£π Î≥ÄÍ≤Ω: ${groupSelect}</div>
              ${phoneHtml}
            </div>
          </div>`;
      }

      function focusGroup(id) {
        ensureMap();
        uiState.focusedGroupId = id;
        uiState.focusedHouseholdId = null;
        const g = groups.find((x) => x.id === id);
        if (g) {
          const v = g.memberIds
            .map((i) => households.find((h) => h.id === i))
            .filter((h) => h && h.lat != null);
          if (v.length > 0) {
            const f = v[0];
            const b = new naver.maps.LatLngBounds(
              new naver.maps.LatLng(f.lat, f.lng),
              new naver.maps.LatLng(f.lat, f.lng)
            );
            v.forEach((h) => b.extend(new naver.maps.LatLng(h.lat, h.lng)));
            map.fitBounds(b);
            map.panTo(b.getCenter());
            if (map.getZoom() > 16) map.setZoom(16);
          }
        }
        renderGroupSummary();
        renderGroupList();
        renderDetail(null);
        updateMarkerAppearance();
      }
      function focusHousehold(id, opts = {}) {
        ensureMap();
        const h = households.find((x) => x.id === id);
        if (!h) return;
        uiState.focusedHouseholdId = id;
        uiState.focusedGroupId = h.groupId;
        const mk = markerByHouseId.get(id);
        if (mk) {
          map.panTo(mk.getPosition());
          updateMarkerAppearance();
          const html = buildInfoWindowContent(h);
          infoWindow.setContent(html);
          infoWindow.open(map, mk);
          setTimeout(() => {
            const sel = document.getElementById("info-group-select");
            if (sel) {
              sel.addEventListener("change", (e) => {
                changeHouseholdGroup(h.id, parseInt(e.target.value, 10));
                focusHousehold(h.id, {
                  fromMarker: true,
                  openDetail: opts.openDetail,
                });
              });
            }
          }, 0);
        }
        renderGroupSummary();
        renderGroupList();
        if (opts.openDetail) renderDetail(h);
        else renderDetail(null);
      }
      function changeHouseholdGroup(id, newGroupId) {
        const h = households.find((x) => x.id === id);
        if (!h || h.groupId === newGroupId) return;
        const old = h.groupId;
        h.groupId = newGroupId;
        groups.forEach((g) => {
          g.memberIds = households
            .filter((hh) => hh.groupId === g.id)
            .map((hh) => hh.id);
        });
        computeOrdersForAllGroups();
        logInfo(`Í∞ÄÍµ¨ Í∑∏Î£π Î≥ÄÍ≤Ω: ${h.rawAddress} (${old} ‚Üí ${newGroupId})`);
        uiState.focusedHouseholdId = null;
        updateMarkerAppearance();
        renderGroupSummary();
        renderGroupList();
      }

      /* ===== ÏóëÏÖÄ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ===== */
      function buildExportData() {
        const res = [],
          headerRow = [...headers, "GROUP"];
        res.push(headerRow);
        const s = [...groups].sort((a, b) => a.id - b.id);
        for (const g of s) {
          const gid = String(g.id).padStart(2, "0");
          const ms = g.memberIds.map((id) =>
            households.find((h) => h.id === id)
          );
          for (const h of ms) {
            for (const row of h.rows) {
              res.push([...row.cells, gid]);
            }
          }
          const hc = ms.length,
            ic = ms.reduce((sum, hh) => sum + hh.totalParts, 0),
            cbm = ms
              .reduce((sum, hh) => sum + hh.cbmSum, 0)
              .toFixed(CBM_PRECISION);
          res.push([
            `${gid} Ìï©Í≥Ñ`,
            `Í∞ÄÍµ¨Ïàò: ${hc}`,
            `ÌíàÎ™©Ïàò(Î∂ÄÌíà): ${ic}`,
            `CBM: ${cbm}`,
          ]);
          res.push([]);
          res.push([]);
        }
        return res;
      }
      function validateExport(data) {
        try {
          const hlen = headers.length;
          const rows = data.filter(
            (r, i) =>
              i !== 0 &&
              r &&
              r.length &&
              !(r[0] && typeof r[0] === "string" && r[0].includes("Ìï©Í≥Ñ"))
          );
          if (rows.length !== originalRows.length)
            throw new Error(
              `Ìñâ Í∞úÏàò Î∂àÏùºÏπò: ÏõêÎ≥∏ ${originalRows.length}, ÎÇ¥Î≥¥ÎÇº Í≤É ${rows.length}`
            );
          const norm = (a) =>
            JSON.stringify(a.map((v) => (v == null ? "" : String(v))));
          const orig = originalRows.map((r) => norm(r.cells)).sort();
          const exp = rows.map((r) => norm(r.slice(0, hlen))).sort();
          for (let i = 0; i < orig.length; i++) {
            if (orig[i] !== exp[i])
              throw new Error(`Îç∞Ïù¥ÌÑ∞ ÎÇ¥Ïö© Î∂àÏùºÏπò(${i + 1})`);
          }
          return true;
        } catch (e) {
          logError("Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ Ïã§Ìå®: " + e.message);
          return false;
        }
      }
      function exportExcel() {
        try {
          if (!originalRows.length) {
            alert("Î®ºÏ†Ä ÏóëÏÖÄ ÌååÏùºÏùÑ Î∂àÎü¨Ïò§ÏÑ∏Ïöî.");
            return;
          }
          const data = buildExportData();
          if (!validateExport(data)) {
            alert("‚ö†Ô∏è Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ Ïã§Ìå®");
            return;
          }
          const ws = XLSX.utils.aoa_to_sheet(data),
            wb = XLSX.utils.book_new();
          XLSX.utils.book_append_sheet(wb, ws, "Î∞∞Ï∞® Í≤∞Í≥º");
          XLSX.writeFile(wb, "dispatch_result.xlsx");
          logInfo("ÏóëÏÖÄ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ÏôÑÎ£å");
        } catch (e) {
          logError("ÏóëÏÖÄ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Ïò§Î•ò", e);
        }
      }

      /* ===== Í≥µÌÜµ Î†åÎçî ===== */
      function renderAll() {
        ensureMap();
        renderMarkers();
        renderGroupSummary();
        renderGroupList();
        renderDetail(null);
      }

      /* ===== Ï¥àÍ∏∞Ìôî ===== */
      window.addEventListener("load", () => {
        document.getElementById("fileInput").addEventListener("change", (e) => {
          const f = e.target.files[0];
          if (!f) return;
          document.getElementById("file-name").textContent = f.name;
          handleFile(f);
        });
        document
          .getElementById("exportBtn")
          .addEventListener("click", exportExcel);
        document.getElementById("regroupBtn").addEventListener("click", () => {
          if (!households.length) {
            alert("Î®ºÏ†Ä ÏóëÏÖÄÏùÑ Î∂àÎü¨Ïò§ÏÑ∏Ïöî.");
            return;
          }
          let v = parseInt(document.getElementById("truckCount").value, 10);
          if (isNaN(v) || v <= 0) v = 1;
          v = Math.min(v, households.length);
          targetGroupCount = v;
          logInfo(`Ï∞®Îüâ Ïàò ${v} Í∏∞Ï§Ä Ïû¨Î∞∞Ïπò...`);
          autoGroupRegional();
          fitGroupCountToTarget();
          renderAll();
          logInfo(`ÏôÑÎ£å (Í∑∏Î£πÏàò=${groups.length})`);
        });
        document
          .getElementById("orderToggleBtn")
          .addEventListener("click", () => {
            uiState.orderReverse = !uiState.orderReverse;
            document.getElementById("orderToggleBtn").textContent =
              uiState.orderReverse ? "ÏàúÏÑú Ïó≠Î∞©Ìñ•" : "ÏàúÏÑú Ï†ïÎ∞©Ìñ•";
            renderGroupList();
            updateMarkerAppearance();
          });

        if (!window.map) {
          window.map = new naver.maps.Map("map", {
            center: new naver.maps.LatLng(START_POINT_LAT, START_POINT_LNG),
            zoom: 11,
          });
          new naver.maps.Marker({
            position: new naver.maps.LatLng(START_POINT_LAT, START_POINT_LNG),
            map: window.map,
            title: "Ï∂úÎ∞úÏßÄ",
          });
          naver.maps.Event.addListener(window.map, "click", () => {
            infoWindow.close();
            uiState.focusedHouseholdId = null;
            renderDetail(null);
            renderGroupList();
            updateMarkerAppearance();
          });
          map = window.map;
        }
        logInfo("ÏóëÏÖÄ ÌååÏùºÏùÑ Î∂àÎü¨Ïò§ÏÑ∏Ïöî.");
      });
    </script>
  </body>
</html>
