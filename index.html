<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>ì£¼ì†Œ â†’ ë„¤ì´ë²„ ì§€ë„ & ê·¸ë£¹ ë¬¶ê¸°</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- NAVER Maps JS v3 (ì‹ ê·œ ncpKeyId ë°©ì‹) -->
    <script
      type="text/javascript"
      src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=ms2yp98bvf&submodules=geocoder"
    ></script>

    <!-- ì—‘ì…€ ì²˜ë¦¬ìš© SheetJS -->
    <script
      type="text/javascript"
      src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"
    ></script>

    <style>
      html,
      body,
      #map {
        height: 100%;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: linear-gradient(135deg, #eef2ff, #f5f7fa);
      }

      /* ì™¼ìª½ íŒ¨ë„ í† ê¸€ ë²„íŠ¼ */
      #togglePanelBtn {
        position: fixed;
        left: 10px;
        top: 10px;
        z-index: 1100;
        border: none;
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 13px;
        background: rgba(15, 23, 42, 0.9);
        color: #fff;
        cursor: pointer;
        box-shadow: 0 4px 10px rgba(15, 23, 42, 0.3);
      }

      #togglePanelBtn:hover {
        transform: translateY(-1px);
      }

      #controls {
        position: fixed;
        left: 10px;
        top: 48px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.96);
        backdrop-filter: blur(10px);
        padding: 10px 12px;
        border-radius: 14px;
        box-shadow: 0 10px 30px rgba(15, 23, 42, 0.18);
        font-size: 13px;
        max-width: 380px;
        max-height: 90vh;
        overflow-y: auto;
        border: 1px solid rgba(148, 163, 184, 0.4);
        transition: transform 0.25s ease, opacity 0.25s ease;
      }

      #controls.hidden {
        transform: translateX(-110%);
        opacity: 0;
        pointer-events: none;
      }

      #controls-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 6px;
      }

      #controls-title {
        font-weight: 700;
        font-size: 14px;
        color: #0f172a;
      }

      #controls-badge {
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 999px;
        background: #e0f2fe;
        color: #0369a1;
      }

      #addrInput {
        width: 100%;
        box-sizing: border-box;
        border-radius: 8px;
        border: 1px solid #d1d5db;
        font-size: 12px;
        padding: 6px;
        resize: vertical;
      }

      #addrInput:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.3);
      }

      #status {
        margin-top: 6px;
        font-size: 12px;
        color: #374151;
        word-break: break-all;
      }

      #groupInfo {
        margin-top: 6px;
        font-size: 12px;
        color: #111827;
        border-top: 1px solid #e5e7eb;
        padding-top: 4px;
        max-height: 260px;
        overflow-y: auto;
      }

      .row {
        margin-top: 6px;
      }

      button {
        padding: 5px 8px;
        cursor: pointer;
        font-size: 12px;
        border-radius: 8px;
        border: none;
        background: #2563eb;
        color: #fff;
        box-shadow: 0 2px 6px rgba(37, 99, 235, 0.4);
      }

      button.secondary {
        background: #e5e7eb;
        color: #111827;
        box-shadow: none;
      }

      button.danger {
        background: #dc2626;
        box-shadow: 0 2px 6px rgba(220, 38, 38, 0.4);
      }

      button.chip {
        background: #e5e7eb;
        color: #111827;
        box-shadow: none;
        border-radius: 999px;
        padding: 3px 8px;
        font-size: 11px;
      }

      button.chip.active {
        background: #2563eb;
        color: #fff;
      }

      button:disabled {
        opacity: 0.4;
        cursor: default;
        box-shadow: none;
      }

      button:hover:not(:disabled) {
        transform: translateY(-1px);
      }

      label {
        font-size: 12px;
        color: #4b5563;
      }

      input[type="number"],
      input[type="file"] {
        font-size: 12px;
        border-radius: 6px;
        border: 1px solid #d1d5db;
        padding: 2px 4px;
      }

      input[type="number"]:focus,
      input[type="file"]:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.25);
      }

      details summary {
        cursor: pointer;
        font-weight: 600;
        margin-top: 2px;
        list-style: none;
      }

      details ul {
        margin: 4px 0 6px 8px;
        padding-left: 8px;
      }

      details li {
        list-style: disc;
        margin-left: 10px;
        margin-bottom: 2px;
        padding: 3px 2px;
        border-radius: 4px;
      }

      details li:hover {
        background: #e5f0ff;
      }

      select {
        border-radius: 6px;
        border: 1px solid #d1d5db;
        font-size: 11px;
        padding: 1px 3px;
      }

      select:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.25);
      }

      /* ê·¸ë£¹ ì¹´ë“œ ìŠ¤íƒ€ì¼ */
      #groupInfo details[data-group-id],
      #groupInfo details[data-unresolved] {
        border-radius: 8px;
        padding: 4px 6px;
        margin-bottom: 4px;
        background: #f9fafb;
        border: 1px solid #e5e7eb;
      }

      #groupInfo details[data-group-id][open] {
        background: #eff6ff;
        border-color: #bfdbfe;
      }

      #groupInfo details[data-unresolved][open] {
        background: #fef2f2;
        border-color: #fecaca;
      }

      /* ê· í˜• ì¡°ì • ì¹´ë“œ */
      .suggestion-card {
        border-radius: 8px;
        border: 1px dashed #f97316;
        background: #fff7ed;
        padding: 4px 6px;
        margin-top: 4px;
        margin-bottom: 4px;
      }

      .suggestion-card summary {
        font-size: 12px;
        color: #c2410c;
      }

      .suggestion-card li {
        list-style: disc;
      }

      .section-divider {
        border: none;
        border-top: 1px dashed #e5e7eb;
        margin: 4px 0;
      }

      /* ìƒ‰ìƒ ë²”ë¡€ */
      #groupLegend {
        position: fixed;
        right: 10px;
        bottom: 10px;
        z-index: 900;
        background: rgba(255, 255, 255, 0.94);
        border-radius: 10px;
        padding: 6px 8px;
        font-size: 11px;
        border: 1px solid rgba(148, 163, 184, 0.5);
        box-shadow: 0 8px 20px rgba(15, 23, 42, 0.25);
        max-width: 220px;
      }

      #groupLegend.hidden {
        display: none;
      }

      #groupLegend .legend-row {
        display: flex;
        align-items: center;
        gap: 4px;
        margin-top: 2px;
      }

      #groupLegend .color-box {
        width: 10px;
        height: 10px;
        border-radius: 3px;
        border: 1px solid rgba(15, 23, 42, 0.2);
      }

      /* ê¸´ ë¦¬ìŠ¤íŠ¸ ìŠ¤í¬ë¡¤ + ë“œë˜ê·¸ ì»¤ì„œ */
      #groupInfo li[draggable="true"] {
        cursor: grab;
      }

      #groupInfo li[draggable="true"]:active {
        cursor: grabbing;
      }
    </style>
  </head>
  <body>
    <button id="togglePanelBtn">Â«</button>

    <div id="controls">
      <div id="controls-header">
        <div id="controls-title">ì£¼ì†Œ â†’ ì§€ë„ & ê·¸ë£¹ ë¬¶ê¸°</div>
        <div id="controls-badge">NAVER ì§€ë„ + ì—‘ì…€</div>
      </div>

      <div style="font-size: 11px; color: #6b7280; margin-bottom: 4px">
        â–¸ <b>ìµœëŒ€ ê°€êµ¬ ìˆ˜</b>ëŠ” ëª©í‘œì¹˜ì…ë‹ˆë‹¤. ë¶€ì¡±í•˜ë©´
        <b>ì¶œë°œì  ê°€ê¹Œìš´ ê·¸ë£¹ë¶€í„°</b> ì´ˆê³¼ë  ìˆ˜ ìˆì–´ìš”.<br />
        â–¸ <b>ì¶”ì²œ ê·¸ë£¹ ìˆ˜</b>ëŠ” <b>ì „ì²´ ê°€êµ¬ ìˆ˜ / ìµœëŒ€ ê°€êµ¬ ìˆ˜</b> ê¸°ì¤€ ì´ë¡ ìƒ
        ì´ˆê³¼ ì—†ëŠ” ìµœì†Œ ê°’ì…ë‹ˆë‹¤.<br />
        â–¸ ì—‘ì…€ ì—…ë¡œë“œ ì‹œ ì›ë³¸ í–‰ì€ ê·¸ëŒ€ë¡œ ë‘ê³  ë§ˆì§€ë§‰ ì—´ì— <b>ê·¸ë£¹ëª…</b>ë§Œ
        ì¶”ê°€í•´ìš”.<br />
        â–¸ ì£¼ì†Œ/ê·¸ë£¹/ì§€ì˜¤ì½”ë”© ê²°ê³¼ëŠ” ë¸Œë¼ìš°ì € <b>localStorage</b>ì— ì €ì¥ë©ë‹ˆë‹¤.
      </div>

      <!-- ì—‘ì…€ ì—…ë¡œë“œ -->
      <div class="row">
        <label>
          ì—‘ì…€ íŒŒì¼
          <input
            type="file"
            id="excelFile"
            accept=".xlsx,.xls"
            style="font-size: 11px; width: 180px"
          />
        </label>
        <div style="font-size: 10px; color: #6b7280; margin-top: 2px">
          íŒŒì¼ ì„ íƒ ì‹œ ìë™ìœ¼ë¡œ ì½ìŠµë‹ˆë‹¤.
        </div>
      </div>
      <div class="row" style="font-size: 11px">
        ì£¼ì†Œì—´:
        <input id="colAddress" type="number" min="1" value="14" />
        &nbsp; í’ˆëª©ì—´:
        <input id="colItem" type="number" min="1" value="10" />
      </div>

      <!-- ì§ì ‘ ì£¼ì†Œ ë¶™ì—¬ë„£ê¸° -->
      <div class="row">
        <textarea
          id="addrInput"
          rows="8"
          placeholder="ë„ë¡œëª… ì£¼ì†Œë¥¼ í•œ ì¤„ì— í•˜ë‚˜ì”© ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.&#10;ì—‘ì…€ì„ ë¶ˆëŸ¬ì˜¤ë©´ ì—¬ê¸°ì—ë„ ì£¼ì†Œê°€ ìë™ìœ¼ë¡œ ë“¤ì–´ì˜µë‹ˆë‹¤."
        ></textarea>
      </div>

      <div class="row">
        <button id="geocodeBtn">1ë‹¨ê³„: ì£¼ì†Œ ì§€ì˜¤ì½”ë”©</button>
        <button id="resetGroupBtn" class="secondary">ê·¸ë£¹ í•´ì œ</button>
        <button id="exportExcelBtn" class="secondary">ì—‘ì…€ë¡œ ë‚´ë³´ë‚´ê¸°</button>
      </div>

      <div class="row">
        <label>
          ìµœëŒ€ ê°€êµ¬ ìˆ˜
          <input id="maxGroupSize" type="number" min="1" value="12" />
        </label>
      </div>
      <div class="row">
        <label>
          ê·¸ë£¹ ìˆ˜
          <input id="numGroups" type="number" min="1" placeholder="ì˜ˆ: 4" />
        </label>
        <button id="applyGroupBtn">2ë‹¨ê³„: ì¡°ê±´ìœ¼ë¡œ ê·¸ë£¹ ë¬¶ê¸°</button>
      </div>

      <div class="row" id="filterRow" style="font-size: 11px">
        ë³´ê¸°:
        <button class="chip active" data-mode="all">ëª¨ë‘</button>
        <button class="chip" data-mode="group">ê·¸ë£¹ë§Œ</button>
        <button class="chip" data-mode="unresolved">ë¯¸ì§€ì •ë§Œ</button>
      </div>

      <div id="status"></div>
      <div id="groupInfo"></div>
    </div>

    <div id="map"></div>

    <div id="groupLegend" class="hidden"></div>

    <script>
      // ===== ê¸°ë³¸ ì„¤ì • =====
      const START_POINT = new naver.maps.LatLng(37.158135, 127.103159);
      const MAX_REALLOC_POINT_DIST_KM = 4;

      const GEO_CACHE_KEY = "naver_geo_cache_v1";
      const STATE_KEY = "naver_group_state_v1";

      let map;
      let markers = [];
      let points = []; // { original, used, lat, lng, items: [] }
      let geocodeCache = {}; // addrKey -> { used, lat, lng }

      // ì—‘ì…€ ê´€ë ¨
      let excelSheetRows = [];
      let excelRows = []; // { row, address, item }
      let excelHouseholdMap = new Map();
      let excelMaxCols = 0;

      // ì§€ì˜¤ì½”ë”© ì‹¤íŒ¨ / ë¯¸ì§€ì •
      let unresolvedPoints = []; // { original, items:[] }
      let unresolvedAssignments = [];

      // ê·¸ë£¹ ìƒíƒœ
      let currentAssignments = null; // points ì¸ë±ìŠ¤ë³„ ê·¸ë£¹ (0..N-1), -1=ë¯¸ì§€ì •
      let lastMaxSizeForGrouping = null;
      let lastNumGroupsForGrouping = null;
      let recommendedGroupsGlobal = null;

      // í‘œì‹œ í•„í„°
      let filterMode = "all";

      let sharedInfoWindow = null;

      // ë“œë˜ê·¸ ì¤‘ ìë™ ìŠ¤í¬ë¡¤
      let dragScrollInterval = null;

      const groupColors = [
        "#e74c3c",
        "#3498db",
        "#2ecc71",
        "#9b59b6",
        "#f1c40f",
        "#e67e22",
        "#1abc9c",
        "#34495e",
        "#ff6b81",
        "#8e44ad",
      ];

      const statusEl = document.getElementById("status");
      const groupInfoEl = document.getElementById("groupInfo");
      const maxGroupInput = document.getElementById("maxGroupSize");
      const numGroupsInput = document.getElementById("numGroups");
      const legendEl = document.getElementById("groupLegend");

      window.navermap_authFailure = function () {
        alert(
          "ë„¤ì´ë²„ ì§€ë„ Open API ì¸ì¦ ì‹¤íŒ¨! (í´ë¼ì´ì–¸íŠ¸ ID / ë„ë©”ì¸ ì„¤ì • í™•ì¸ í•„ìš”)"
        );
      };

      function normalizeAddress(str) {
        return String(str || "")
          .trim()
          .replace(/\s+/g, " ");
      }

      // ===== localStorage ìœ í‹¸ =====
      function loadGeocodeCacheFromStorage() {
        try {
          const raw = localStorage.getItem(GEO_CACHE_KEY);
          if (!raw) return;
          const obj = JSON.parse(raw);
          if (obj && typeof obj === "object") {
            geocodeCache = obj;
          }
        } catch (e) {
          console.warn("ì§€ì˜¤ì½”ë”© ìºì‹œ ë¡œë“œ ì‹¤íŒ¨:", e);
        }
      }

      function saveGeocodeCacheToStorage() {
        try {
          localStorage.setItem(GEO_CACHE_KEY, JSON.stringify(geocodeCache));
        } catch (e) {
          console.warn("ì§€ì˜¤ì½”ë”© ìºì‹œ ì €ì¥ ì‹¤íŒ¨:", e);
        }
      }

      function saveStateToStorage() {
        try {
          const state = {
            points,
            currentAssignments,
            unresolvedPoints,
            unresolvedAssignments,
            maxGroupSize: maxGroupInput.value,
            numGroups: numGroupsInput.value,
            lastMaxSizeForGrouping,
            lastNumGroupsForGrouping,
            recommendedGroupsGlobal,
            filterMode,
          };
          localStorage.setItem(STATE_KEY, JSON.stringify(state));
        } catch (e) {
          console.warn("ìƒíƒœ ì €ì¥ ì‹¤íŒ¨:", e);
        }
      }

      function restoreStateFromStorage() {
        try {
          const raw = localStorage.getItem(STATE_KEY);
          if (!raw) return;
          const st = JSON.parse(raw);
          if (!st || !Array.isArray(st.points)) return;

          points = st.points || [];
          currentAssignments = st.currentAssignments || null;
          unresolvedPoints = st.unresolvedPoints || [];
          unresolvedAssignments = st.unresolvedAssignments || [];
          lastMaxSizeForGrouping = st.lastMaxSizeForGrouping || null;
          lastNumGroupsForGrouping = st.lastNumGroupsForGrouping || null;
          recommendedGroupsGlobal = st.recommendedGroupsGlobal || null;
          filterMode = st.filterMode || "all";

          if (st.maxGroupSize) maxGroupInput.value = st.maxGroupSize;
          if (st.numGroups) numGroupsInput.value = st.numGroups;

          updateFilterButtons();

          if (points.length || unresolvedPoints.length) {
            statusEl.textContent =
              `ì´ì „ ì‘ì—… ìƒíƒœë¥¼ ë³µì›í–ˆìŠµë‹ˆë‹¤. ` +
              `ì¢Œí‘œ ìˆëŠ” ê°€êµ¬: ${points.length}ê°œ, ë¯¸ì§€ì •/ì‹¤íŒ¨: ${unresolvedPoints.length}ê°€êµ¬.`;
            renderMarkers(currentAssignments, lastMaxSizeForGrouping);
            updateRecommendedGroups();
          }
        } catch (e) {
          console.warn("ìƒíƒœ ë³µì› ì‹¤íŒ¨:", e);
        }
      }

      loadGeocodeCacheFromStorage();

      // ===== ì§€ë„ ì´ˆê¸°í™” =====
      function initMap() {
        map = new naver.maps.Map("map", {
          center: START_POINT,
          zoom: 12,
        });

        sharedInfoWindow = new naver.maps.InfoWindow({ content: "" });

        new naver.maps.Marker({
          position: START_POINT,
          map: map,
          icon: {
            content:
              '<div style="width:20px;height:20px;border-radius:50%;background:#e74c3c;border:2px solid #fff;box-shadow:0 0 3px rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;color:#fff;font-size:11px;">S</div>',
            size: new naver.maps.Size(20, 20),
            anchor: new naver.maps.Point(10, 10),
          },
          title: "ì¶œë°œì ",
        });

        naver.maps.Event.addListener(map, "click", function () {
          if (sharedInfoWindow && sharedInfoWindow.getMap()) {
            sharedInfoWindow.close();
          }
        });

        restoreStateFromStorage();
      }

      if (window.naver && naver.maps) {
        naver.maps.onJSContentLoaded = initMap;
      } else {
        window.addEventListener("load", initMap);
      }

      // íŒ¨ë„ í† ê¸€
      (function () {
        const btn = document.getElementById("togglePanelBtn");
        const panel = document.getElementById("controls");
        let hidden = false;
        btn.addEventListener("click", () => {
          hidden = !hidden;
          panel.classList.toggle("hidden", hidden);
          btn.textContent = hidden ? "Â»" : "Â«";
        });
      })();

      // ===== í•„í„° ë²„íŠ¼ =====
      function updateFilterButtons() {
        const btns = document.querySelectorAll("#filterRow button.chip");
        btns.forEach((b) => {
          const mode = b.getAttribute("data-mode");
          if (mode === filterMode) b.classList.add("active");
          else b.classList.remove("active");
        });
      }

      document.querySelectorAll("#filterRow button.chip").forEach((btn) => {
        btn.addEventListener("click", () => {
          const mode = btn.getAttribute("data-mode");
          if (!mode) return;
          filterMode = mode;
          updateFilterButtons();
          renderMarkers(currentAssignments, lastMaxSizeForGrouping);
          saveStateToStorage();
        });
      });

      // ===== ì£¼ì†Œ ì „ì²˜ë¦¬/í›„ë³´ =====
      function simplifyKoreanAddress(addr) {
        if (!addr) return addr;
        let s = addr.replace(/\(.*?\)/g, " ");
        s = s.replace(/\s+/g, " ").trim();
        const tokens = s.split(" ");
        let cutIndex = -1;
        for (let i = 0; i < tokens.length - 1; i++) {
          const t = tokens[i];
          const next = tokens[i + 1];
          if (/[ë¡œê¸¸]$/.test(t) && /^[0-9\-]+$/.test(next)) {
            cutIndex = i + 1;
          }
        }
        if (cutIndex !== -1) {
          return tokens
            .slice(0, cutIndex + 1)
            .join(" ")
            .trim();
        }
        return s;
      }

      function extractJibeon(addr) {
        const m = addr.match(/\(([^)]+)\)/);
        if (!m) return null;
        const inner = m[1];
        const firstPart = inner.split(",")[0];
        const parts = firstPart.split(/\s+/).filter(Boolean);
        if (parts.length >= 2) {
          return parts.slice(0, 2).join(" ");
        }
        return firstPart.trim();
      }

      function buildCandidates(originalAddr) {
        const candidates = [];
        const seen = new Set();
        const add = (s) => {
          if (!s) return;
          const n = normalizeAddress(s);
          if (!n || seen.has(n)) return;
          seen.add(n);
          candidates.push(n);
        };

        add(originalAddr);
        const simplified = simplifyKoreanAddress(originalAddr);
        add(simplified);

        const base = simplified || originalAddr;
        if (base) {
          const t = base.split(" ").filter(Boolean);
          if (t.length >= 2) {
            if (/^ê²½ê¸°(ë„)?$/.test(t[0])) {
              add(t.slice(1).join(" "));
            }
            const cityIdx = t.findIndex((x) => x.endsWith("ì‹œ"));
            if (cityIdx >= 0) {
              const city = t[cityIdx];
              const afterCity = t.slice(cityIdx + 1);
              if (afterCity.length >= 2) {
                add(city + " " + afterCity.join(" "));
                const roadNum = afterCity.slice(-2).join(" ");
                add(city + " " + roadNum);
              }
            }
            const roadNum2 = t.slice(-2).join(" ");
            add(roadNum2);
          }
        }

        const jibeon = extractJibeon(originalAddr);
        if (jibeon) {
          add(jibeon);
          add("í‰íƒì‹œ " + jibeon);
        }

        return candidates;
      }

      // ===== ë„¤ì´ë²„ ì§€ì˜¤ì½”ë”© =====
      function geocodeNaver(query) {
        return new Promise((resolve) => {
          if (!query) {
            resolve(null);
            return;
          }

          if (
            !naver.maps.Service ||
            typeof naver.maps.Service.geocode !== "function"
          ) {
            console.error("Geocoder ì„œë¸Œëª¨ë“ˆì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
            resolve(null);
            return;
          }

          naver.maps.Service.geocode({ query }, (status, response) => {
            if (status !== naver.maps.Service.Status.OK) {
              resolve(null);
              return;
            }
            const addrObj =
              response &&
              response.v2 &&
              response.v2.addresses &&
              response.v2.addresses[0];
            if (!addrObj) {
              resolve(null);
              return;
            }
            const lng = parseFloat(addrObj.x);
            const lat = parseFloat(addrObj.y);
            if (isNaN(lat) || isNaN(lng)) {
              resolve(null);
            } else {
              resolve({ lat, lng });
            }
          });
        });
      }

      async function geocodeWithFallback(originalAddr) {
        const cand = buildCandidates(originalAddr);
        for (let i = 0; i < cand.length; i++) {
          const q = cand[i];
          const p = await geocodeNaver(q);
          if (p) return { point: p, usedAddress: q };
        }
        return null;
      }

      // ===== ê±°ë¦¬ ê³„ì‚°(km) =====
      function distanceKmPoint(p1, p2) {
        const R = 6371.0088;
        const lat1 = (p1.lat * Math.PI) / 180;
        const lat2 = (p2.lat * Math.PI) / 180;
        const dLat = lat2 - lat1;
        const dLon = ((p2.lng - p1.lng) * Math.PI) / 180;
        const a =
          Math.sin(dLat / 2) ** 2 +
          Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      // ===== k-means =====
      function runKMeans(numGroups, maxIter = 20) {
        const n = points.length;
        let k = Math.min(numGroups, n);
        const indices = Array.from({ length: n }, (_, i) => i);
        for (let i = n - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [indices[i], indices[j]] = [indices[j], indices[i]];
        }

        let centroids = [];
        for (let i = 0; i < k; i++) {
          const p = points[indices[i]];
          centroids.push({ lat: p.lat, lng: p.lng });
        }

        let assignments = new Array(n).fill(0);

        for (let iter = 0; iter < maxIter; iter++) {
          for (let i = 0; i < n; i++) {
            let best = 0;
            let bestDist = Infinity;
            for (let c = 0; c < k; c++) {
              const d = distanceKmPoint(points[i], centroids[c]);
              if (d < bestDist) {
                bestDist = d;
                best = c;
              }
            }
            assignments[i] = best;
          }

          const sumLat = new Array(k).fill(0);
          const sumLng = new Array(k).fill(0);
          const count = new Array(k).fill(0);

          for (let i = 0; i < n; i++) {
            const g = assignments[i];
            sumLat[g] += points[i].lat;
            sumLng[g] += points[i].lng;
            count[g] += 1;
          }

          for (let c = 0; c < k; c++) {
            if (count[c] > 0) {
              centroids[c] = {
                lat: sumLat[c] / count[c],
                lng: sumLng[c] / count[c],
              };
            } else {
              const idx = Math.floor(Math.random() * n);
              centroids[c] = { lat: points[idx].lat, lng: points[idx].lng };
            }
          }
        }

        return { assignments, centroids };
      }

      // ===== ì „ì²´ ê°€êµ¬ ìˆ˜ & ì¶”ì²œ ê·¸ë£¹ ìˆ˜ =====
      function getTotalHouseholdCount() {
        return points.length + unresolvedPoints.length;
      }

      function updateRecommendedGroups() {
        const total = getTotalHouseholdCount();
        const maxSize = parseInt(maxGroupInput.value, 10);
        if (!total || !maxSize || maxSize <= 0) {
          recommendedGroupsGlobal = null;
          return null;
        }

        const minGroups = Math.ceil(total / maxSize);
        recommendedGroupsGlobal = minGroups;
        if (!numGroupsInput.value) {
          numGroupsInput.value = minGroups;
        }

        statusEl.textContent =
          `ì „ì²´ ê°€êµ¬ ìˆ˜: ${total}ê°œ / ìµœëŒ€ ${maxSize}ê°€êµ¬ ê¸°ì¤€ ` +
          `ì´ë¡ ìƒ ì´ˆê³¼ ì—†ì´ ë°°ì¹˜ ê°€ëŠ¥í•œ ìµœì†Œ ê·¸ë£¹ ìˆ˜: ì•½ ${minGroups}ê°œ`;

        return minGroups;
      }

      // ===== ê·¸ë£¹í•‘ =====
      function groupWithConstraints(maxSize, numGroups) {
        const n = points.length;
        if (n === 0) return null;
        if (numGroups <= 0) numGroups = 1;
        if (numGroups > n) numGroups = n;
        if (maxSize <= 0) maxSize = n;

        const totalHouseholds = getTotalHouseholdCount();
        const recommendedGroups =
          recommendedGroupsGlobal ||
          (maxSize > 0 ? Math.ceil(totalHouseholds / maxSize) : null);
        const capacity = maxSize * numGroups;

        let msg;
        if (capacity < totalHouseholds) {
          msg =
            `ì°¸ê³ : ì „ì²´ ${totalHouseholds}ê°€êµ¬ë¥¼ ` +
            `${numGroups}ê·¸ë£¹ Ã— ìµœëŒ€ ${maxSize}ê°€êµ¬ë¡œëŠ” ì´ë¡ ìƒ ë‹¤ ëª» ì±„ì›Œì„œ ` +
            "ì¼ë¶€ ê·¸ë£¹ì€ ê¸°ì¤€ì„ ì´ˆê³¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ì¶œë°œì  ê°€ê¹Œìš´ ê·¸ë£¹ë¶€í„° ì´ˆê³¼ í—ˆìš©)";
        } else {
          msg = `ìµœëŒ€ ${maxSize}ê°€êµ¬ Ã— ${numGroups}ê·¸ë£¹ìœ¼ë¡œ ë°°ì¹˜ ì‹œë„ ì¤‘...`;
        }

        if (recommendedGroups) {
          if (numGroups < recommendedGroups) {
            msg += ` / âš  ì¶”ì²œ ê·¸ë£¹ ìˆ˜(${recommendedGroups}ê°œ)ë³´ë‹¤ ì ê²Œ ì…ë ¥ë˜ì–´, ì´ë¡ ìƒë„ ì´ˆê³¼ ê·¸ë£¹ì´ ìƒê¸¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`;
          } else if (numGroups === recommendedGroups) {
            msg += ` / ì¶”ì²œ ìµœì†Œ ê·¸ë£¹ ìˆ˜ì™€ ë™ì¼í•œ ì„¤ì •ì…ë‹ˆë‹¤.`;
          } else {
            msg += ` / ì¶”ì²œê°’(${recommendedGroups}ê°œ)ë³´ë‹¤ ì—¬ìœ  ìˆëŠ” ê·¸ë£¹ ìˆ˜ì…ë‹ˆë‹¤. (ê°€êµ¬ ìˆ˜ ë¶„ì‚° ê°€ëŠ¥)`;
          }
        }
        statusEl.textContent = msg;

        let { assignments, centroids } = runKMeans(numGroups);

        let groups = Array.from({ length: numGroups }, () => []);
        for (let i = 0; i < n; i++) {
          groups[assignments[i]].push(i);
        }

        function recomputeCentroids() {
          centroids = [];
          for (let g = 0; g < numGroups; g++) {
            if (groups[g].length === 0) {
              const idx = Math.floor(Math.random() * n);
              centroids[g] = { lat: points[idx].lat, lng: points[idx].lng };
            } else {
              let sLat = 0,
                sLng = 0;
              groups[g].forEach((i) => {
                sLat += points[i].lat;
                sLng += points[i].lng;
              });
              centroids[g] = {
                lat: sLat / groups[g].length,
                lng: sLng / groups[g].length,
              };
            }
          }
        }

        recomputeCentroids();

        // 1ì°¨: ì´ˆê³¼ ê·¸ë£¹ì—ì„œ ë¨¼ ê²ƒë“¤ overflowë¡œ
        let overflow = [];
        for (let g = 0; g < numGroups; g++) {
          if (groups[g].length > maxSize) {
            const center = centroids[g];
            groups[g].sort((a, b) => {
              const da = distanceKmPoint(points[a], center);
              const db = distanceKmPoint(points[b], center);
              return da - db;
            });
            while (groups[g].length > maxSize) {
              overflow.push(groups[g].pop());
            }
          }
        }

        recomputeCentroids();

        // 2ì°¨: overflow ì¬ë°°ì¹˜ (ë„ˆë¬´ ë¨¼ ê·¸ë£¹ ì œì™¸)
        overflow.forEach((idx) => {
          let bestGroup = -1;
          let bestScore = Infinity;

          for (let g = 0; g < numGroups; g++) {
            if (groups[g].length >= maxSize) continue;
            const dPoint = distanceKmPoint(points[idx], centroids[g]);
            if (dPoint > MAX_REALLOC_POINT_DIST_KM) continue;

            const dStart = distanceKmPoint(centroids[g], {
              lat: START_POINT.y,
              lng: START_POINT.x,
            });
            const score = dPoint + 0.2 * dStart;
            if (score < bestScore) {
              bestScore = score;
              bestGroup = g;
            }
          }

          if (bestGroup === -1) {
            let best = -1;
            let bestScore2 = Infinity;
            for (let g = 0; g < numGroups; g++) {
              const dPoint = distanceKmPoint(points[idx], centroids[g]);
              const dStart = distanceKmPoint(centroids[g], {
                lat: START_POINT.y,
                lng: START_POINT.x,
              });
              const score = dPoint + 0.3 * dStart;
              if (score < bestScore2) {
                bestScore2 = score;
                best = g;
              }
            }
            bestGroup = best;
          }

          groups[bestGroup].push(idx);
          const gm = groups[bestGroup];
          let sLat = 0,
            sLng = 0;
          gm.forEach((i) => {
            sLat += points[i].lat;
            sLng += points[i].lng;
          });
          centroids[bestGroup] = {
            lat: sLat / gm.length,
            lng: sLng / gm.length,
          };
        });

        const finalAssignments = new Array(n).fill(-1);
        for (let g = 0; g < numGroups; g++) {
          groups[g].forEach((i) => {
            finalAssignments[i] = g;
          });
        }
        return finalAssignments;
      }

      // ===== ê· í˜• ì¡°ì • ì œì•ˆ =====
      function computeBalanceSuggestions(assignments) {
        if (!assignments || !points.length) return [];
        const n = points.length;
        let maxGroupIdx = -1;
        assignments.forEach((g) => {
          if (g != null && g >= 0 && g > maxGroupIdx) maxGroupIdx = g;
        });
        const numGroupsLocal = maxGroupIdx + 1;
        if (numGroupsLocal <= 1) return [];

        const counts = new Array(numGroupsLocal).fill(0);
        const sumLat = new Array(numGroupsLocal).fill(0);
        const sumLng = new Array(numGroupsLocal).fill(0);

        for (let i = 0; i < n; i++) {
          const g = assignments[i];
          if (g == null || g < 0) continue;
          counts[g]++;
          sumLat[g] += points[i].lat;
          sumLng[g] += points[i].lng;
        }

        const centroids = [];
        let totalAssigned = 0;
        for (let g = 0; g < numGroupsLocal; g++) {
          if (counts[g] > 0) {
            centroids[g] = {
              lat: sumLat[g] / counts[g],
              lng: sumLng[g] / counts[g],
            };
            totalAssigned += counts[g];
          } else {
            centroids[g] = null;
          }
        }

        if (totalAssigned === 0) return [];
        const avgCount = totalAssigned / numGroupsLocal;
        const suggestions = [];

        for (let i = 0; i < n; i++) {
          const g = assignments[i];
          if (g == null || g < 0) continue;
          if (!centroids[g]) continue;

          const fromSize = counts[g];
          if (fromSize <= avgCount + 1) continue;

          const pt = { lat: points[i].lat, lng: points[i].lng };
          const dFrom = distanceKmPoint(pt, centroids[g]);

          let bestOther = -1;
          let bestOtherDist = Infinity;
          for (let h = 0; h < numGroupsLocal; h++) {
            if (h === g) continue;
            if (!centroids[h]) continue;
            const toSize = counts[h];
            if (toSize >= avgCount - 1) continue;
            const dTo = distanceKmPoint(pt, centroids[h]);
            if (dTo < bestOtherDist) {
              bestOtherDist = dTo;
              bestOther = h;
            }
          }

          if (bestOther === -1) continue;
          if (bestOtherDist > dFrom + 1) continue;

          suggestions.push({
            pointIndex: i,
            fromGroup: g + 1,
            toGroup: bestOther + 1,
            fromSize: fromSize,
            toSize: counts[bestOther],
            distFrom: dFrom,
            distTo: bestOtherDist,
            address: points[i].original,
          });
        }

        return suggestions.slice(0, 20);
      }

      // ===== í•˜ì´ë¼ì´íŠ¸ =====
      let highlightedIndices = [];

      function clearHighlight() {
        if (!markers.length || !highlightedIndices.length) {
          highlightedIndices = [];
          return;
        }
        highlightedIndices.forEach((i) => {
          const marker = markers[i];
          if (!marker || !marker.getElement) return;
          const el = marker.getElement();
          if (!el) return;
          const inner = el.querySelector("div") || el;
          inner.style.transform = "";
          inner.style.boxShadow = "";
        });
        highlightedIndices = [];
      }

      function highlightMarkers(indices) {
        clearHighlight();
        indices.forEach((i) => {
          const marker = markers[i];
          if (!marker || !marker.getElement) return;
          const el = marker.getElement();
          if (!el) return;
          const inner = el.querySelector("div") || el;
          inner.style.transform = "scale(1.4)";
          inner.style.boxShadow = "0 0 8px rgba(0, 0, 0, 0.7)";
        });
        highlightedIndices = indices.slice();
      }

      window.clearHighlight = clearHighlight;

      function clearMarkers() {
        markers.forEach((m) => m.setMap(null));
        markers = [];
      }

      function escapeHtml(str) {
        return String(str || "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      function buildGroupOptionsHtml(currentGroupId, numGroups) {
        let html = `<option value="0"${
          currentGroupId === 0 ? " selected" : ""
        }>ë¯¸ì§€ì •</option>`;
        for (let g = 1; g <= numGroups; g++) {
          const selected = currentGroupId === g ? " selected" : "";
          html += `<option value="${g}"${selected}>ê·¸ë£¹ ${g}</option>`;
        }
        return html;
      }

      // ===== ë“œë˜ê·¸ & ë“œë + ìë™ ìŠ¤í¬ë¡¤ =====
      function stopDragScroll() {
        if (dragScrollInterval) {
          clearInterval(dragScrollInterval);
          dragScrollInterval = null;
        }
      }

      function setDragScroll(delta) {
        stopDragScroll();
        if (!delta) return;
        dragScrollInterval = setInterval(() => {
          groupInfoEl.scrollTop += delta;
        }, 20);
      }

      window.addrDragStart = function (ev) {
        if (!ev || !ev.dataTransfer) return;
        const el = ev.currentTarget;
        if (!el || !el.dataset) return;
        const kind = el.dataset.kind; // 'point' | 'unresolved'
        const index = parseInt(el.dataset.index, 10);
        if (isNaN(index)) return;

        ev.dataTransfer.effectAllowed = "move";
        ev.dataTransfer.setData("text/plain", JSON.stringify({ kind, index }));
      };

      window.addrDragEnd = function () {
        stopDragScroll();
      };

      window.groupDragOver = function (ev) {
        ev.preventDefault();
        if (ev.dataTransfer) ev.dataTransfer.dropEffect = "move";

        // ë“œë˜ê·¸ ì¤‘ ìë™ ìŠ¤í¬ë¡¤
        const rect = groupInfoEl.getBoundingClientRect();
        const threshold = 40;
        const y = ev.clientY;
        let delta = 0;
        if (y - rect.top < threshold) {
          delta = -8;
        } else if (rect.bottom - y < threshold) {
          delta = 8;
        }
        setDragScroll(delta);
      };

      window.groupDrop = function (ev) {
        ev.preventDefault();
        stopDragScroll();

        const container = ev.currentTarget;
        if (!container || !container.dataset) return;

        let targetGroupId = 0;
        if (container.dataset.groupId) {
          targetGroupId = parseInt(container.dataset.groupId, 10);
          if (isNaN(targetGroupId) || targetGroupId < 0) targetGroupId = 0;
        } else if (container.dataset.unresolved) {
          targetGroupId = 0;
        }

        try {
          const raw = ev.dataTransfer.getData("text/plain");
          if (!raw) return;
          const data = JSON.parse(raw);
          if (!data || typeof data.index !== "number") return;

          if (data.kind === "point") {
            changeGroupTo(data.index, targetGroupId);
          } else if (data.kind === "unresolved") {
            changeUnresolvedGroupTo(data.index, targetGroupId);
          }
        } catch (e) {
          console.warn("ë“œë˜ê·¸ ë“œë¡­ íŒŒì‹± ì˜¤ë¥˜:", e);
        }
      };

      document.addEventListener("dragend", stopDragScroll);
      document.addEventListener("drop", stopDragScroll);

      function updateLegend(groupCounts) {
        if (!groupCounts || !Object.keys(groupCounts).length) {
          legendEl.classList.add("hidden");
          legendEl.innerHTML = "";
          return;
        }
        const groupIds = Object.keys(groupCounts)
          .map((x) => parseInt(x, 10))
          .sort((a, b) => a - b);

        let html =
          '<div style="font-weight:600;margin-bottom:2px;">ê·¸ë£¹ ìƒ‰ìƒ ì•ˆë‚´</div>';
        groupIds.forEach((id) => {
          const color = groupColors[(id - 1) % groupColors.length];
          html += `<div class="legend-row">
            <div class="color-box" style="background:${color};"></div>
            ê·¸ë£¹ ${id} (${groupCounts[id]} ê°€êµ¬)
          </div>`;
        });

        legendEl.innerHTML = html;
        legendEl.classList.remove("hidden");
      }

      // ===== ê·¸ë£¹ í¬ì»¤ìŠ¤ =====
      window.focusGroup = function (groupId) {
        if (!currentAssignments || !points.length) return;
        const gIndex = groupId - 1;
        const indices = [];
        for (let i = 0; i < points.length; i++) {
          if (currentAssignments[i] === gIndex) indices.push(i);
        }
        if (!indices.length) return;
        highlightMarkers(indices);
        let bounds = null;
        indices.forEach((idx) => {
          const p = points[idx];
          const pos = new naver.maps.LatLng(p.lat, p.lng);
          if (!bounds) bounds = new naver.maps.LatLngBounds(pos, pos);
          else bounds.extend(pos);
        });
        if (bounds) map.fitBounds(bounds);
      };

      window.focusPoint = function (idx) {
        const p = points[idx];
        if (!p) return;
        const pos = new naver.maps.LatLng(p.lat, p.lng);
        const z = map.getZoom();
        if (z < 14) map.setZoom(14);
        map.panTo(pos);
        highlightMarkers([idx]);
      };

      // ===== ê·¸ë£¹ ë³€ê²½ =====
      window.onLiGroupChange = function (kind, idx, value) {
        const gid = parseInt(value, 10);
        const groupId = isNaN(gid) ? 0 : gid;
        if (kind === "point") {
          changeGroupTo(idx, groupId);
        } else if (kind === "unresolved") {
          changeUnresolvedGroupTo(idx, groupId);
        }
      };

      function changeGroupTo(pointIndex, newGroupId) {
        if (!points.length) return;
        if (!currentAssignments) {
          currentAssignments = new Array(points.length).fill(-1);
        }
        const numGroups =
          lastNumGroupsForGrouping || recommendedGroupsGlobal || 0;
        if (newGroupId < 0) newGroupId = 0;
        if (numGroups && newGroupId > numGroups) newGroupId = numGroups;
        currentAssignments[pointIndex] = newGroupId === 0 ? -1 : newGroupId - 1;
        renderMarkers(currentAssignments, lastMaxSizeForGrouping);
        saveStateToStorage();
      }

      function changeUnresolvedGroupTo(idx, newGroupId) {
        if (!unresolvedPoints.length) return;
        if (
          !unresolvedAssignments ||
          unresolvedAssignments.length !== unresolvedPoints.length
        ) {
          unresolvedAssignments = new Array(unresolvedPoints.length).fill(0);
        }
        const numGroups =
          lastNumGroupsForGrouping || recommendedGroupsGlobal || 0;
        if (newGroupId < 0) newGroupId = 0;
        if (numGroups && newGroupId > numGroups) newGroupId = numGroups;
        unresolvedAssignments[idx] = newGroupId;
        renderMarkers(currentAssignments, lastMaxSizeForGrouping);
        saveStateToStorage();
      }

      // ===== ë§ˆì»¤/ë¦¬ìŠ¤íŠ¸ ë Œë”ë§ =====
      function renderMarkers(assignments, maxSizeForLabel) {
        const openState = {};
        groupInfoEl.querySelectorAll("details[data-key]").forEach((d) => {
          const key = d.getAttribute("data-key");
          if (key) openState[key] = d.open;
        });

        clearMarkers();
        groupInfoEl.innerHTML = "";
        clearHighlight();
        legendEl.classList.add("hidden");
        legendEl.innerHTML = "";

        if (!points.length && !unresolvedPoints.length) return;

        const hasGrouping = Array.isArray(assignments);
        let bounds = null;

        // ë§ˆì»¤ ìƒì„±
        for (let i = 0; i < points.length; i++) {
          const p = points[i];
          const pos = new naver.maps.LatLng(p.lat, p.lng);

          const assign = hasGrouping ? assignments[i] : null;
          const isAssigned = assign != null && assign >= 0;

          let showMarker = true;
          if (filterMode === "group" && !isAssigned) showMarker = false;
          if (filterMode === "unresolved" && isAssigned) showMarker = false;

          let groupIdDisplay = null;
          let icon = null;

          if (isAssigned) {
            const gIndex = assign;
            const groupId = gIndex + 1;
            groupIdDisplay = groupId;
            const color = groupColors[gIndex % groupColors.length];
            icon = {
              content: `<div style="
                width:24px;height:24px;border-radius:50%;
                background:${color};
                color:#fff;display:flex;align-items:center;justify-content:center;
                font-size:12px;border:2px solid #fff;box-shadow:0 0 2px rgba(0,0,0,0.5);
              ">${groupId}</div>`,
              size: new naver.maps.Size(24, 24),
              anchor: new naver.maps.Point(12, 12),
            };
          }

          let popupHtml = `<div style="padding:6px;font-size:12px;">`;
          if (groupIdDisplay != null) {
            popupHtml += `<b>ê·¸ë£¹ ${groupIdDisplay}</b><br><br>`;
          }
          popupHtml += `<b>ì›ë³¸ ì£¼ì†Œ</b><br>${escapeHtml(p.original)}<br><br>`;
          popupHtml += `<b>ê²€ìƒ‰ì— ì‚¬ìš©í•œ ì£¼ì†Œ</b><br>${escapeHtml(
            p.used
          )}<br>${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}`;
          if (p.items && p.items.length) {
            const maxShow = 5;
            popupHtml += `<hr style="margin:4px 0;"><b>í’ˆëª© (${p.items.length})</b><br>`;
            p.items.slice(0, maxShow).forEach((it) => {
              popupHtml += `${escapeHtml(it)}<br>`;
            });
            if (p.items.length > maxShow) {
              popupHtml += `â€¦ ì™¸ ${p.items.length - maxShow}ê±´`;
            }
          }
          popupHtml += `</div>`;

          const marker = new naver.maps.Marker({
            position: pos,
            map: showMarker ? map : null,
            icon: icon || undefined,
          });

          naver.maps.Event.addListener(marker, "click", () => {
            if (!sharedInfoWindow) return;
            sharedInfoWindow.setContent(popupHtml);
            sharedInfoWindow.open(map, marker);
          });

          markers.push(marker);

          if (showMarker) {
            if (!bounds) bounds = new naver.maps.LatLngBounds(pos, pos);
            else bounds.extend(pos);
          }
        }

        if (bounds) {
          map.fitBounds(bounds);
        }

        // ë¦¬ìŠ¤íŠ¸/í†µê³„
        let html = "";

        const totalPointHouseholds = points.length;
        const unresolvedHouseholds = unresolvedPoints.length;

        html += `<div style="margin-bottom:4px;">
          ì¢Œí‘œ ìˆëŠ” ê°€êµ¬: ${totalPointHouseholds}ê°œ / ë¯¸ì§€ì •Â·ì§€ì˜¤ì½”ë”© ì‹¤íŒ¨: ${unresolvedHouseholds}ê°€êµ¬
        </div>`;

        let groupCounts = {};
        let groupItemCounts = {};
        let groupMembersPoints = {};
        let groupMembersUnresolved = {};
        let numGroupsLocal = 0;

        if (hasGrouping) {
          for (let i = 0; i < points.length; i++) {
            const gIndex = assignments[i];
            if (gIndex == null || gIndex < 0) continue;
            const groupId = gIndex + 1;
            if (groupId > numGroupsLocal) numGroupsLocal = groupId;
            if (!groupCounts[groupId]) {
              groupCounts[groupId] = 0;
              groupItemCounts[groupId] = 0;
              groupMembersPoints[groupId] = [];
            }
            groupCounts[groupId] += 1;
            const itemCount = points[i].items ? points[i].items.length : 0;
            groupItemCounts[groupId] += itemCount;
            groupMembersPoints[groupId].push(i);
          }
        }

        if (unresolvedPoints.length) {
          for (let j = 0; j < unresolvedPoints.length; j++) {
            const gId = unresolvedAssignments[j] || 0;
            if (gId > 0) {
              if (gId > numGroupsLocal) numGroupsLocal = gId;
              if (!groupCounts[gId]) {
                groupCounts[gId] = 0;
                groupItemCounts[gId] = 0;
              }
              groupCounts[gId] += 1;
              const itemCount = unresolvedPoints[j].items
                ? unresolvedPoints[j].items.length
                : 0;
              groupItemCounts[gId] += itemCount;
              if (!groupMembersUnresolved[gId])
                groupMembersUnresolved[gId] = [];
              groupMembersUnresolved[gId].push(j);
            }
          }
        }

        if (hasGrouping && numGroupsLocal > 0) {
          const countsForLegend = {};
          for (let g = 1; g <= numGroupsLocal; g++) {
            if (groupCounts[g]) countsForLegend[g] = groupCounts[g];
          }
          updateLegend(countsForLegend);
        }

        // ê· í˜• ì¡°ì • ì¹´ë“œ
        if (hasGrouping && points.length > 0) {
          const suggestions = computeBalanceSuggestions(assignments);
          if (suggestions && suggestions.length) {
            const key = "suggestions";
            const openAttr = openState[key] ? "open" : "";
            html += `<div class="suggestion-card">
              <details data-key="${key}" ${openAttr}>
                <summary>âš– ê· í˜• ì¡°ì • ì œì•ˆ (${suggestions.length}ê°œ)</summary>
                <ul>`;
            suggestions.forEach((s) => {
              html += `<li>
                <span style="font-weight:600;">ê·¸ë£¹ ${s.fromGroup} â†’ ê·¸ë£¹ ${
                s.toGroup
              }</span><br/>
                <span style="color:#6b7280;">${escapeHtml(
                  s.address
                )}</span><br/>
                <span style="font-size:11px;color:#9ca3af;">
                  í˜„ì¬ ê·¸ë£¹ ${s.fromGroup}: ${s.fromSize}ê°€êµ¬,
                  ëŒ€ìƒ ê·¸ë£¹ ${s.toGroup}: ${s.toSize}ê°€êµ¬
                </span>
              </li>`;
            });
            html += `</ul>
              </details>
            </div>
            <hr class="section-divider" />`;
          }
        }

        // ê·¸ë£¹ ëª©ë¡
        if (hasGrouping && numGroupsLocal > 0) {
          const groupIds = [];
          for (let g = 1; g <= numGroupsLocal; g++) {
            if (groupCounts[g]) groupIds.push(g);
          }
          groupIds.sort((a, b) => a - b);

          if (groupIds.length) {
            html += `<div style="margin-top:4px;margin-bottom:2px;font-weight:600;">
              ğŸ“¦ ê·¸ë£¹ ëª©ë¡
            </div>`;
            const totalGroupsHouseholds = groupIds.reduce(
              (sum, g) => sum + (groupCounts[g] || 0),
              0
            );
            const avgCount = totalGroupsHouseholds / groupIds.length;

            groupIds.forEach((groupId) => {
              const count = groupCounts[groupId] || 0;
              const itemsCount = groupItemCounts[groupId] || 0;
              const key = `group-${groupId}`;
              const openAttr = openState[key] ? "open" : "";
              let overText = "";
              if (maxSizeForLabel && count > maxSizeForLabel) {
                overText = ` <span style="color:#dc2626;">(ê¸°ì¤€ ${maxSizeForLabel}ê°€êµ¬ ì´ˆê³¼)</span>`;
              }
              let imbalanceText = "";
              if (count > avgCount * 1.4) {
                imbalanceText = ` <span style="color:#f97316;">(ë‹¤ë¥¸ ê·¸ë£¹ë³´ë‹¤ ë§ì´ ëª°ë¦¼)</span>`;
              } else if (count < avgCount * 0.6) {
                imbalanceText = ` <span style="color:#0ea5e9;">(ë‹¤ë¥¸ ê·¸ë£¹ë³´ë‹¤ ì ìŒ)</span>`;
              }

              html += `<details data-key="${key}" data-group-id="${groupId}"
                ${openAttr}
                ondragover="groupDragOver(event)"
                ondrop="groupDrop(event)">
                <summary onmouseenter="focusGroup(${groupId})" onmouseleave="clearHighlight()">
                  ê·¸ë£¹ ${groupId} (${count} ê°€êµ¬, í’ˆëª© ${itemsCount}ê°œ)${overText}${imbalanceText}
                </summary>
                <ul>
              `;

              const pointIdxList = groupMembersPoints[groupId] || [];
              pointIdxList.forEach((idx) => {
                const p = points[idx];
                const itemCount = p.items ? p.items.length : 0;
                const currentGid =
                  assignments &&
                  assignments[idx] != null &&
                  assignments[idx] >= 0
                    ? assignments[idx] + 1
                    : 0;

                html += `<li draggable="true"
                    data-kind="point"
                    data-index="${idx}"
                    ondragstart="addrDragStart(event)"
                    ondragend="addrDragEnd(event)"
                    onmouseenter="focusPoint(${idx})"
                    onmouseleave="clearHighlight()">
                    ${escapeHtml(p.original)}
                    ${
                      itemCount
                        ? `<span style="color:#6b7280;"> (í’ˆëª© ${itemCount}ê°œ)</span>`
                        : ""
                    }<br/>
                    <span style="font-size:11px;color:#9ca3af;">${escapeHtml(
                      p.used
                    )}</span>
                    &nbsp;
                    <select onchange="onLiGroupChange('point', ${idx}, this.value)">
                      ${buildGroupOptionsHtml(currentGid, numGroupsLocal)}
                    </select>
                  </li>`;
              });

              const unresIdxList = groupMembersUnresolved[groupId] || [];
              unresIdxList.forEach((idx) => {
                const u = unresolvedPoints[idx];
                const itemCount = u.items ? u.items.length : 0;
                const currentGid = unresolvedAssignments[idx] || 0;
                html += `<li draggable="true"
                    data-kind="unresolved"
                    data-index="${idx}"
                    ondragstart="addrDragStart(event)"
                    ondragend="addrDragEnd(event)">
                    âš  (ì¢Œí‘œ ì—†ìŒ) ${escapeHtml(u.original || "")}
                    ${
                      itemCount
                        ? `<span style="color:#6b7280;"> (í’ˆëª© ${itemCount}ê°œ)</span>`
                        : ""
                    }
                    &nbsp;
                    <select onchange="onLiGroupChange('unresolved', ${idx}, this.value)">
                      ${buildGroupOptionsHtml(currentGid, numGroupsLocal)}
                    </select>
                  </li>`;
              });

              html += `</ul></details>`;
            });
          }
        }

        // ë¯¸ì§€ì • / ì§€ì˜¤ì½”ë”© ì‹¤íŒ¨
        const unresKey = "unresolved";
        const unresOpen = openState[unresKey] ? "open" : "";
        const unassignedPointIndices = [];

        if (hasGrouping) {
          for (let i = 0; i < points.length; i++) {
            const gIndex = assignments[i];
            if (gIndex == null || gIndex < 0) unassignedPointIndices.push(i);
          }
        }

        const unresolvedUnassigned = [];
        for (let j = 0; j < unresolvedPoints.length; j++) {
          const gId = unresolvedAssignments[j] || 0;
          if (gId === 0) unresolvedUnassigned.push(j);
        }

        if (unassignedPointIndices.length || unresolvedUnassigned.length) {
          const numGroupsLocalForSelect =
            numGroupsLocal || lastNumGroupsForGrouping || 0;
          html += `<details data-key="${unresKey}" data-unresolved="1"
            ${unresOpen}
            ondragover="groupDragOver(event)"
            ondrop="groupDrop(event)">
            <summary>ğŸš© ë¯¸ì§€ì • / ì§€ì˜¤ì½”ë”© ì‹¤íŒ¨ (${
              unassignedPointIndices.length + unresolvedUnassigned.length
            } ê°€êµ¬)</summary>
            <ul>
          `;

          unassignedPointIndices.forEach((idx) => {
            const p = points[idx];
            const itemCount = p.items ? p.items.length : 0;
            const currentGid = 0;
            html += `<li draggable="true"
                data-kind="point"
                data-index="${idx}"
                ondragstart="addrDragStart(event)"
                ondragend="addrDragEnd(event)"
                onmouseenter="focusPoint(${idx})"
                onmouseleave="clearHighlight()">
                (ì¢Œí‘œ ìˆìŒ, ê·¸ë£¹ ë¯¸ì§€ì •) ${escapeHtml(p.original)}
                ${
                  itemCount
                    ? `<span style="color:#6b7280;"> (í’ˆëª© ${itemCount}ê°œ)</span>`
                    : ""
                }
                ${
                  numGroupsLocalForSelect
                    ? `&nbsp;<select onchange="onLiGroupChange('point', ${idx}, this.value)">
                        ${buildGroupOptionsHtml(
                          currentGid,
                          numGroupsLocalForSelect
                        )}
                      </select>`
                    : ""
                }
              </li>`;
          });

          unresolvedUnassigned.forEach((idx) => {
            const u = unresolvedPoints[idx];
            const itemCount = u.items ? u.items.length : 0;
            const currentGid = 0;
            html += `<li draggable="true"
                data-kind="unresolved"
                data-index="${idx}"
                ondragstart="addrDragStart(event)"
                ondragend="addrDragEnd(event)">
                âš  (ì¢Œí‘œ ì—†ìŒ) ${escapeHtml(u.original || "")}
                ${
                  numGroupsLocalForSelect
                    ? `&nbsp;<select onchange="onLiGroupChange('unresolved', ${idx}, this.value)">
                        ${buildGroupOptionsHtml(
                          currentGid,
                          numGroupsLocalForSelect
                        )}
                      </select>`
                    : ""
                }
                ${
                  itemCount
                    ? `<span style="color:#6b7280;"> (í’ˆëª© ${itemCount}ê°œ)</span>`
                    : ""
                }
              </li>`;
          });

          html += `</ul></details>`;
        }

        groupInfoEl.innerHTML = html;
      }

      // ===== ì—‘ì…€ ì²˜ë¦¬ =====
      function rebuildExcelMappings() {
        excelRows = [];
        excelHouseholdMap = new Map();
        if (!excelSheetRows || !excelSheetRows.length) return;

        const colAddrIdx =
          parseInt(document.getElementById("colAddress").value, 10) - 1;
        const colItemIdx =
          parseInt(document.getElementById("colItem").value, 10) - 1;

        excelMaxCols = 0;

        excelSheetRows.forEach((row) => {
          if (!row || row.length === 0) return;
          if (row.length > excelMaxCols) excelMaxCols = row.length;
        });

        excelSheetRows.forEach((row) => {
          if (!row || row.length === 0) return;
          const addr =
            colAddrIdx >= 0 && row[colAddrIdx] != null
              ? String(row[colAddrIdx])
              : "";
          const item =
            colItemIdx >= 0 && row[colItemIdx] != null
              ? String(row[colItemIdx])
              : "";

          const infoIndex = excelRows.length;
          const info = { row, address: addr, item };
          excelRows.push(info);

          if (addr && addr.toString().trim()) {
            const key = normalizeAddress(addr);
            let hh = excelHouseholdMap.get(key);
            if (!hh) {
              hh = { originalAddress: addr, items: [], rowIndices: [] };
              excelHouseholdMap.set(key, hh);
            }
            if (item) hh.items.push(item);
            hh.rowIndices.push(infoIndex);
          }
        });

        attachItemsToHouseholds();
      }

      function fillAddrInputFromExcel() {
        if (!excelHouseholdMap || !excelHouseholdMap.size) return;
        const lines = [];
        excelHouseholdMap.forEach((hh) => {
          lines.push(hh.originalAddress || "");
        });
        document.getElementById("addrInput").value = lines.join("\n");
      }

      function attachItemsToHouseholds() {
        if (!excelHouseholdMap || !excelHouseholdMap.size) {
          points.forEach((p) => (p.items = []));
          unresolvedPoints.forEach((u) => (u.items = []));
          return;
        }
        points.forEach((p) => {
          const key = normalizeAddress(p.original);
          const hh = excelHouseholdMap.get(key);
          p.items = hh ? hh.items.slice() : [];
        });
        unresolvedPoints.forEach((u) => {
          const key = normalizeAddress(u.original || "");
          const hh = excelHouseholdMap.get(key);
          u.items = hh ? hh.items.slice() : [];
        });
      }

      document
        .getElementById("excelFile")
        .addEventListener("change", function (e) {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = function (evt) {
            const data = new Uint8Array(evt.target.result);
            const wb = XLSX.read(data, { type: "array" });
            const sheetName = wb.SheetNames[0];
            const ws = wb.Sheets[sheetName];
            const rows = XLSX.utils.sheet_to_json(ws, {
              header: 1,
              blankrows: false,
            });
            excelSheetRows = rows;
            rebuildExcelMappings();
            fillAddrInputFromExcel();
            statusEl.textContent = `ì—‘ì…€ ë¡œë“œ ì™„ë£Œ: í–‰ ${excelRows.length}ê°œ (ê°€êµ¬ ${excelHouseholdMap.size}ê°œ)`;
            attachItemsToHouseholds();
            renderMarkers(currentAssignments, lastMaxSizeForGrouping);
            saveStateToStorage();
          };
          reader.readAsArrayBuffer(file);
        });

      document.getElementById("colAddress").addEventListener("change", () => {
        if (!excelSheetRows || !excelSheetRows.length) return;
        rebuildExcelMappings();
        fillAddrInputFromExcel();
        attachItemsToHouseholds();
        renderMarkers(currentAssignments, lastMaxSizeForGrouping);
        saveStateToStorage();
      });

      document.getElementById("colItem").addEventListener("change", () => {
        if (!excelSheetRows || !excelSheetRows.length) return;
        rebuildExcelMappings();
        attachItemsToHouseholds();
        renderMarkers(currentAssignments, lastMaxSizeForGrouping);
        saveStateToStorage();
      });

      // ===== ì§€ì˜¤ì½”ë”© ë²„íŠ¼ =====
      document
        .getElementById("geocodeBtn")
        .addEventListener("click", async () => {
          const raw = document.getElementById("addrInput").value.trim();
          if (!raw) {
            alert("ë„ë¡œëª… ì£¼ì†Œë¥¼ ë¶™ì—¬ë„£ì–´ ì£¼ì„¸ìš” ë˜ëŠ” ì—‘ì…€ì„ ë¨¼ì € ë¶ˆëŸ¬ì˜¤ì„¸ìš”.");
            return;
          }

          const rawList = raw
            .split(/\r?\n/)
            .map((s) => s.trim())
            .filter(Boolean);

          const seen = new Set();
          const deduped = [];
          let dupCount = 0;

          rawList.forEach((addr) => {
            const key = normalizeAddress(addr);
            if (!seen.has(key)) {
              seen.add(key);
              deduped.push({ original: addr, key });
            } else {
              dupCount++;
            }
          });

          let newPoints = [];
          let newUnresolved = [];
          let skipCount = 0;
          let newGeocodeSuccess = 0;
          let newGeocodeFail = 0;

          const toGeocode = [];

          deduped.forEach((item) => {
            const cached = geocodeCache[item.key];
            if (cached) {
              skipCount++;
              newPoints.push({
                original: item.original,
                used: cached.used,
                lat: cached.lat,
                lng: cached.lng,
                items: [],
              });
            } else {
              toGeocode.push(item);
            }
          });

          statusEl.textContent =
            `ì´ ì…ë ¥: ${rawList.length}ê°œ, ì¤‘ë³µ ì œê±° í›„: ${deduped.length}ê°œ` +
            (dupCount > 0 ? ` (ì¤‘ë³µ ${dupCount}ê°œ ì œì™¸ë¨)` : "") +
            (skipCount > 0 ? ` / ìºì‹œ ì‚¬ìš©: ${skipCount}ê°œ` : "");

          for (let i = 0; i < toGeocode.length; i++) {
            const { original, key } = toGeocode[i];
            statusEl.textContent =
              `(${i + 1}/${
                toGeocode.length
              }) "${original}" ìƒˆ ì¢Œí‘œ ë³€í™˜ ì¤‘...` +
              (skipCount > 0 ? ` / ìºì‹œ ì‚¬ìš©: ${skipCount}ê°œ` : "");
            try {
              const result = await geocodeWithFallback(original);
              if (result && result.point) {
                newGeocodeSuccess++;
                const p = {
                  original,
                  used: result.usedAddress,
                  lat: result.point.lat,
                  lng: result.point.lng,
                  items: [],
                };
                geocodeCache[key] = {
                  used: p.used,
                  lat: p.lat,
                  lng: p.lng,
                };
                newPoints.push(p);
              } else {
                newGeocodeFail++;
                newUnresolved.push({ original });
              }
            } catch (e) {
              console.error(e);
              newGeocodeFail++;
              newUnresolved.push({ original });
            }
            await new Promise((r) => setTimeout(r, 150));
          }

          points = newPoints;
          unresolvedPoints = newUnresolved;
          unresolvedAssignments = new Array(unresolvedPoints.length).fill(0);
          currentAssignments = null;
          lastMaxSizeForGrouping = null;
          lastNumGroupsForGrouping = null;

          attachItemsToHouseholds();
          saveGeocodeCacheToStorage();

          let summary =
            `ì§€ì˜¤ì½”ë”© ì™„ë£Œ: ìƒˆ ë³€í™˜ ${newGeocodeSuccess}ê°œ, ì‹¤íŒ¨ ${newGeocodeFail}ê°œ` +
            (skipCount > 0 ? `, ìºì‹œ ì‚¬ìš© ${skipCount}ê°œ` : "") +
            ` / ì¢Œí‘œ ìˆëŠ” ê°€êµ¬: ${points.length}ê°œ, ë¯¸ì§€ì •/ì‹¤íŒ¨: ${unresolvedPoints.length}ê°€êµ¬`;
          statusEl.textContent = summary;

          renderMarkers();
          updateRecommendedGroups();
          saveStateToStorage();
        });

      // ===== ê·¸ë£¹ í•´ì œ =====
      document.getElementById("resetGroupBtn").addEventListener("click", () => {
        if (!points.length && !unresolvedPoints.length) {
          alert("ë¨¼ì € ì£¼ì†Œ ì§€ì˜¤ì½”ë”©ì„ í•´ì£¼ì„¸ìš”.");
          return;
        }
        currentAssignments = null;
        lastMaxSizeForGrouping = null;
        lastNumGroupsForGrouping = null;
        if (unresolvedPoints.length) {
          unresolvedAssignments = new Array(unresolvedPoints.length).fill(0);
        }
        statusEl.textContent = `ê·¸ë£¹ í•´ì œë¨ / ì¢Œí‘œ ìˆëŠ” ê°€êµ¬: ${points.length}ê°œ, ë¯¸ì§€ì •Â·ì‹¤íŒ¨: ${unresolvedPoints.length}ê°€êµ¬`;
        renderMarkers(null, null);
        updateRecommendedGroups();
        saveStateToStorage();
      });

      // ===== ê·¸ë£¹ ë¬¶ê¸° =====
      document.getElementById("applyGroupBtn").addEventListener("click", () => {
        if (!points.length) {
          alert("ë¨¼ì € ì£¼ì†Œ ì§€ì˜¤ì½”ë”©ì„ í•´ì£¼ì„¸ìš”.");
          return;
        }
        const maxSize = parseInt(maxGroupInput.value, 10);
        const numGroups = parseInt(numGroupsInput.value, 10);

        if (!maxSize || maxSize <= 0 || !numGroups || numGroups <= 0) {
          alert("ìµœëŒ€ ê°€êµ¬ ìˆ˜ì™€ ê·¸ë£¹ ìˆ˜ë¥¼ ëª¨ë‘ ì˜¬ë°”ë¥´ê²Œ ì…ë ¥í•´ ì£¼ì„¸ìš”.");
          return;
        }

        const assignments = groupWithConstraints(maxSize, numGroups);
        if (!assignments) return;

        currentAssignments = assignments;
        lastMaxSizeForGrouping = maxSize;
        lastNumGroupsForGrouping = numGroups;

        renderMarkers(currentAssignments, maxSize);
        saveStateToStorage();
      });

      // ===== ì—‘ì…€ ë‚´ë³´ë‚´ê¸° =====
      document
        .getElementById("exportExcelBtn")
        .addEventListener("click", exportToExcel);

      function exportToExcel() {
        if (!excelRows || !excelRows.length) {
          alert("ë¨¼ì € ì—‘ì…€ íŒŒì¼ì„ ë¶ˆëŸ¬ì™€ ì£¼ì„¸ìš”.");
          return;
        }

        const colAddrIdx =
          parseInt(document.getElementById("colAddress").value, 10) - 1;
        if (isNaN(colAddrIdx) || colAddrIdx < 0) {
          alert("ì£¼ì†Œì—´ ë²ˆí˜¸ê°€ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤.");
          return;
        }

        const addrToGroup = new Map();

        if (points && points.length) {
          for (let i = 0; i < points.length; i++) {
            const key = normalizeAddress(points[i].original);
            let gId = 0;
            if (
              currentAssignments &&
              currentAssignments[i] != null &&
              currentAssignments[i] >= 0
            ) {
              gId = currentAssignments[i] + 1;
            } else {
              gId = 0;
            }
            addrToGroup.set(key, gId);
          }
        }

        if (unresolvedPoints && unresolvedPoints.length) {
          for (let j = 0; j < unresolvedPoints.length; j++) {
            const u = unresolvedPoints[j];
            const key = normalizeAddress(u.original || "");
            if (!key) continue;
            const gId =
              unresolvedAssignments && unresolvedAssignments[j] != null
                ? unresolvedAssignments[j]
                : 0;
            addrToGroup.set(key, gId);
          }
        }

        const groupBuckets = {};
        const dataRowFlags = new Array(excelRows.length).fill(false);

        excelRows.forEach((info, idx) => {
          const key = normalizeAddress(info.address || "");
          const gId = key && addrToGroup.has(key) ? addrToGroup.get(key) : 0;

          if (!groupBuckets[gId]) {
            groupBuckets[gId] = {
              rows: [],
              itemCount: 0,
              householdKeys: new Set(),
            };
          }
          const bucket = groupBuckets[gId];
          bucket.rows.push(idx);
          if (info.item && String(info.item).trim()) bucket.itemCount++;
          if (key) bucket.householdKeys.add(key);
          dataRowFlags[idx] = true;
        });

        const covered = dataRowFlags.filter(Boolean).length;
        if (covered !== excelRows.length) {
          alert(
            `ì—‘ì…€ ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨: ì›ë³¸ í–‰ ${excelRows.length}ê°œ ì¤‘ ${covered}ê°œë§Œ ë§¤í•‘ë˜ì—ˆìŠµë‹ˆë‹¤. ë‚´ë³´ë‚´ê¸°ë¥¼ ì¤‘ë‹¨í•©ë‹ˆë‹¤.`
          );
          return;
        }

        const wsData = [];
        const maxCols =
          excelMaxCols ||
          excelRows.reduce((m, r) => Math.max(m, r.row.length), 0) ||
          0;

        const groupIds = Object.keys(groupBuckets)
          .map((x) => parseInt(x, 10))
          .sort((a, b) => a - b);

        groupIds.forEach((gId) => {
          const bucket = groupBuckets[gId];
          if (!bucket || !bucket.rows.length) return;

          const groupLabel = gId === 0 ? "ë¯¸ì§€ì •" : `ê·¸ë£¹ ${gId}`;
          const householdCount = bucket.householdKeys.size;
          const itemCount = bucket.itemCount;

          bucket.rows.forEach((rowIndex) => {
            const info = excelRows[rowIndex];
            const rowCopy = info.row.slice();
            while (rowCopy.length < maxCols) rowCopy.push("");
            rowCopy.push(groupLabel);
            wsData.push(rowCopy);
          });

          const summaryRow = new Array(maxCols + 1).fill("");
          summaryRow[
            colAddrIdx
          ] = `${groupLabel} ìš”ì•½: ê°€êµ¬ìˆ˜ ${householdCount}ê°œ, í’ˆëª©ìˆ˜ ${itemCount}ê°œ`;
          wsData.push(summaryRow);

          const blankRow = new Array(maxCols + 1).fill("");
          wsData.push(blankRow);
        });

        if (!wsData.length) {
          alert("ë‚´ë³´ë‚¼ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
          return;
        }

        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(wsData);
        XLSX.utils.book_append_sheet(wb, ws, "ê·¸ë£¹ê²°ê³¼");

        XLSX.writeFile(wb, "ê·¸ë£¹_ë°°ì •_ê²°ê³¼.xlsx");

        statusEl.textContent += ` / ì—‘ì…€ ë‚´ë³´ë‚´ê¸° ì™„ë£Œ (ì›ë³¸ ${excelRows.length}í–‰ ê·¸ëŒ€ë¡œ ë°˜ì˜, ê·¸ë£¹/ìš”ì•½ í–‰ ì¶”ê°€)`;
      }
    </script>
  </body>
</html>
