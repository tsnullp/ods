<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>주소 → 네이버 지도 & 그룹 묶기</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- NAVER Maps JS v3 (신규 ncpKeyId 방식) -->
    <script
      type="text/javascript"
      src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=ms2yp98bvf&submodules=geocoder"
    ></script>

    <!-- 엑셀 처리용 SheetJS -->
    <script
      type="text/javascript"
      src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"
    ></script>

    <style>
      html,
      body,
      #map {
        height: 100%;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: linear-gradient(135deg, #eef2ff, #f5f7fa);
      }

      /* 왼쪽 패널 토글 버튼 */
      #togglePanelBtn {
        position: fixed;
        left: 10px;
        top: 10px;
        z-index: 1100;
        border: none;
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 13px;
        background: rgba(15, 23, 42, 0.9);
        color: #fff;
        cursor: pointer;
        box-shadow: 0 4px 10px rgba(15, 23, 42, 0.3);
      }

      #togglePanelBtn:hover {
        transform: translateY(-1px);
      }

      #controls {
        position: fixed;
        left: 10px;
        top: 48px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.96);
        backdrop-filter: blur(10px);
        padding: 10px 12px;
        border-radius: 14px;
        box-shadow: 0 10px 30px rgba(15, 23, 42, 0.18);
        font-size: 13px;
        max-width: 380px;
        max-height: 90vh;
        overflow-y: auto;
        border: 1px solid rgba(148, 163, 184, 0.4);
        transition: transform 0.25s ease, opacity 0.25s ease;
      }

      #controls.hidden {
        transform: translateX(-110%);
        opacity: 0;
        pointer-events: none;
      }

      #controls-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 6px;
      }

      #controls-title {
        font-weight: 700;
        font-size: 14px;
        color: #0f172a;
      }

      #controls-badge {
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 999px;
        background: #e0f2fe;
        color: #0369a1;
      }

      #addrInput {
        width: 100%;
        box-sizing: border-box;
        border-radius: 8px;
        border: 1px solid #d1d5db;
        font-size: 12px;
        padding: 6px;
        resize: vertical;
      }

      #addrInput:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.3);
      }

      #status {
        margin-top: 6px;
        font-size: 12px;
        color: #374151;
        word-break: break-all;
      }

      #groupInfo {
        margin-top: 6px;
        font-size: 12px;
        color: #111827;
        border-top: 1px solid #e5e7eb;
        padding-top: 4px;
      }

      .row {
        margin-top: 6px;
      }

      button {
        padding: 5px 8px;
        cursor: pointer;
        font-size: 12px;
        border-radius: 8px;
        border: none;
        background: #2563eb;
        color: #fff;
        box-shadow: 0 2px 6px rgba(37, 99, 235, 0.4);
      }

      button.secondary {
        background: #e5e7eb;
        color: #111827;
        box-shadow: none;
      }

      button.danger {
        background: #dc2626;
        box-shadow: 0 2px 6px rgba(220, 38, 38, 0.4);
      }

      button.chip {
        background: #e5e7eb;
        color: #111827;
        box-shadow: none;
        border-radius: 999px;
        padding: 3px 8px;
        font-size: 11px;
      }

      button.chip.active {
        background: #2563eb;
        color: #fff;
      }

      button:disabled {
        opacity: 0.4;
        cursor: default;
        box-shadow: none;
      }

      button:hover:not(:disabled) {
        transform: translateY(-1px);
      }

      label {
        font-size: 12px;
        color: #4b5563;
      }

      input[type="number"],
      input[type="file"] {
        font-size: 12px;
        border-radius: 6px;
        border: 1px solid #d1d5db;
        padding: 2px 4px;
      }

      input[type="number"]:focus,
      input[type="file"]:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.25);
      }

      details summary {
        cursor: pointer;
        font-weight: 600;
        margin-top: 2px;
      }

      details ul {
        margin: 2px 0 6px 12px;
        padding: 0;
      }

      details li {
        list-style: disc;
        margin-left: 12px;
        margin-bottom: 2px;
      }

      select {
        border-radius: 6px;
        border: 1px solid #d1d5db;
        font-size: 11px;
        padding: 1px 3px;
      }

      select:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.25);
      }

      /* 색상 범례 */
      #groupLegend {
        position: fixed;
        right: 10px;
        bottom: 10px;
        z-index: 900;
        background: rgba(255, 255, 255, 0.94);
        border-radius: 10px;
        padding: 6px 8px;
        font-size: 11px;
        border: 1px solid rgba(148, 163, 184, 0.5);
        box-shadow: 0 8px 20px rgba(15, 23, 42, 0.25);
        max-width: 200px;
      }

      #groupLegend.hidden {
        display: none;
      }

      #groupLegend .legend-row {
        display: flex;
        align-items: center;
        gap: 4px;
        margin-top: 2px;
      }

      #groupLegend .color-box {
        width: 10px;
        height: 10px;
        border-radius: 3px;
        border: 1px solid rgba(15, 23, 42, 0.2);
      }

      /* 긴 리스트 스크롤 */
      #groupInfo {
        max-height: 260px;
        overflow-y: auto;
      }
    </style>
  </head>
  <body>
    <button id="togglePanelBtn">«</button>

    <div id="controls">
      <div id="controls-header">
        <div id="controls-title">주소 → 지도 & 그룹 묶기</div>
        <div id="controls-badge">NAVER 지도 + 엑셀</div>
      </div>

      <div style="font-size: 11px; color: #6b7280; margin-bottom: 4px">
        ▸ <b>최대 가구 수</b>는 목표치입니다. 부족하면
        <b>출발점 가까운 그룹부터</b> 초과할 수 있어요.<br />
        ▸ <b>추천 그룹 수</b>는 <b>전체 가구 수 / 최대 가구 수</b> 기준 이론상
        초과 없는 최소 값입니다.<br />
        ▸ 엑셀 업로드 시 원본 행은 그대로 두고 마지막 열에 <b>그룹명</b>만
        추가해요.<br />
        ▸ 주소/그룹/지오코딩 결과는 브라우저 <b>localStorage</b>에 저장됩니다.
      </div>

      <!-- 엑셀 업로드 -->
      <div class="row">
        <label>
          엑셀 파일
          <input
            type="file"
            id="excelFile"
            accept=".xlsx,.xls"
            style="font-size: 11px; width: 180px"
          />
        </label>
        <div style="font-size: 10px; color: #6b7280; margin-top: 2px">
          파일 선택 시 자동으로 읽습니다.
        </div>
      </div>
      <div class="row" style="font-size: 11px">
        주소열:
        <input id="colAddress" type="number" min="1" value="14" />
        &nbsp; 품목열:
        <input id="colItem" type="number" min="1" value="10" />
      </div>

      <!-- 직접 주소 붙여넣기 -->
      <div class="row">
        <textarea
          id="addrInput"
          rows="8"
          placeholder="도로명 주소를 한 줄에 하나씩 붙여넣으세요.&#10;엑셀을 불러오면 여기에도 주소가 자동으로 들어옵니다."
        ></textarea>
      </div>

      <div class="row">
        <button id="geocodeBtn">1단계: 주소 지오코딩</button>
        <button id="resetGroupBtn" class="secondary">그룹 해제</button>
        <button id="exportExcelBtn" class="secondary">엑셀로 내보내기</button>
      </div>

      <div class="row">
        <label>
          최대 가구 수
          <input id="maxGroupSize" type="number" min="1" value="12" />
        </label>
      </div>
      <div class="row">
        <label>
          그룹 수
          <input id="numGroups" type="number" min="1" placeholder="예: 4" />
        </label>
        <button id="applyGroupBtn">2단계: 조건으로 그룹 묶기</button>
      </div>

      <div class="row" id="filterRow" style="font-size: 11px">
        보기:
        <button class="chip active" data-mode="all">모두</button>
        <button class="chip" data-mode="group">그룹만</button>
        <button class="chip" data-mode="unresolved">미지정만</button>
      </div>

      <div id="status"></div>
      <div id="groupInfo"></div>
    </div>

    <div id="map"></div>

    <div id="groupLegend" class="hidden"></div>

    <script>
      // ===== 기본 설정 =====
      const START_POINT = new naver.maps.LatLng(37.158135, 127.103159);
      const MAX_REALLOC_POINT_DIST_KM = 4;

      const GEO_CACHE_KEY = "naver_geo_cache_v1";
      const STATE_KEY = "naver_group_state_v1";

      let map;
      let markers = [];
      let points = []; // { original, used, lat, lng, items: [] }
      let geocodeCache = {}; // 주소 -> { used, lat, lng }

      // 엑셀 원본
      let excelRows = [];
      let excelHouseholdMap = new Map(); // key -> { originalAddress, items: [] }

      // 지오코딩 실패/미지정 주소
      let unresolvedPoints = []; // {original, items:[]}
      let unresolvedAssignments = []; // 0=미지정, 1..N

      // 그룹 상태
      let currentAssignments = null; // points 인덱스별 그룹 (0..N-1), -1=미지정
      let lastMaxSizeForGrouping = null;
      let lastNumGroupsForGrouping = null;
      let recommendedGroupsGlobal = null;

      // 표시 필터 (all | group | unresolved)
      let filterMode = "all";

      let sharedInfoWindow = null;

      const groupColors = [
        "#e74c3c",
        "#3498db",
        "#2ecc71",
        "#9b59b6",
        "#f1c40f",
        "#e67e22",
        "#1abc9c",
        "#34495e",
        "#ff6b81",
        "#8e44ad",
      ];

      const statusEl = document.getElementById("status");
      const groupInfoEl = document.getElementById("groupInfo");
      const maxGroupInput = document.getElementById("maxGroupSize");
      const numGroupsInput = document.getElementById("numGroups");
      const legendEl = document.getElementById("groupLegend");

      window.navermap_authFailure = function () {
        alert(
          "네이버 지도 Open API 인증 실패! (클라이언트 ID / 도메인 설정 확인 필요)"
        );
      };

      function normalizeAddress(str) {
        return String(str || "")
          .trim()
          .replace(/\s+/g, " ");
      }

      // ===== localStorage 유틸 =====
      function loadGeocodeCacheFromStorage() {
        try {
          const raw = localStorage.getItem(GEO_CACHE_KEY);
          if (!raw) return;
          const obj = JSON.parse(raw);
          if (obj && typeof obj === "object") {
            geocodeCache = obj;
            console.log(
              "[geocode cache] loaded",
              Object.keys(geocodeCache).length
            );
          }
        } catch (e) {
          console.warn("지오코딩 캐시 로드 실패:", e);
        }
      }

      function saveGeocodeCacheToStorage() {
        try {
          localStorage.setItem(GEO_CACHE_KEY, JSON.stringify(geocodeCache));
        } catch (e) {
          console.warn("지오코딩 캐시 저장 실패:", e);
        }
      }

      function saveStateToStorage() {
        try {
          const state = {
            points,
            currentAssignments,
            unresolvedPoints,
            unresolvedAssignments,
            maxGroupSize: maxGroupInput.value,
            numGroups: numGroupsInput.value,
            lastMaxSizeForGrouping,
            lastNumGroupsForGrouping,
            recommendedGroupsGlobal,
            filterMode,
          };
          localStorage.setItem(STATE_KEY, JSON.stringify(state));
        } catch (e) {
          console.warn("상태 저장 실패:", e);
        }
      }

      function restoreStateFromStorage() {
        try {
          const raw = localStorage.getItem(STATE_KEY);
          if (!raw) return;
          const st = JSON.parse(raw);
          if (!st || !Array.isArray(st.points)) return;

          points = st.points || [];
          currentAssignments = st.currentAssignments || null;
          unresolvedPoints = st.unresolvedPoints || [];
          unresolvedAssignments = st.unresolvedAssignments || [];
          lastMaxSizeForGrouping = st.lastMaxSizeForGrouping || null;
          lastNumGroupsForGrouping = st.lastNumGroupsForGrouping || null;
          recommendedGroupsGlobal = st.recommendedGroupsGlobal || null;
          filterMode = st.filterMode || "all";

          if (st.maxGroupSize) maxGroupInput.value = st.maxGroupSize;
          if (st.numGroups) numGroupsInput.value = st.numGroups;

          updateFilterButtons();

          if (points.length || unresolvedPoints.length) {
            statusEl.textContent =
              `이전 작업 상태를 복원했습니다. ` +
              `좌표 있는 가구: ${points.length}개, 미지정/실패: ${unresolvedPoints.length}개.`;
            renderMarkers(currentAssignments, lastMaxSizeForGrouping);
            updateRecommendedGroups();
          }
        } catch (e) {
          console.warn("상태 복원 실패:", e);
        }
      }

      loadGeocodeCacheFromStorage();

      // ===== 지도 초기화 =====
      function initMap() {
        map = new naver.maps.Map("map", {
          center: START_POINT,
          zoom: 12,
        });

        sharedInfoWindow = new naver.maps.InfoWindow({ content: "" });

        new naver.maps.Marker({
          position: START_POINT,
          map: map,
          icon: {
            content:
              '<div style="width:20px;height:20px;border-radius:50%;background:#e74c3c;border:2px solid #fff;box-shadow:0 0 3px rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;color:#fff;font-size:11px;">S</div>',
            size: new naver.maps.Size(20, 20),
            anchor: new naver.maps.Point(10, 10),
          },
          title: "출발점",
        });

        naver.maps.Event.addListener(map, "click", function () {
          if (sharedInfoWindow && sharedInfoWindow.getMap()) {
            sharedInfoWindow.close();
          }
        });

        restoreStateFromStorage();
      }

      if (window.naver && naver.maps) {
        naver.maps.onJSContentLoaded = initMap;
      } else {
        window.addEventListener("load", initMap);
      }

      // 패널 토글
      (function () {
        const btn = document.getElementById("togglePanelBtn");
        const panel = document.getElementById("controls");
        let hidden = false;
        btn.addEventListener("click", () => {
          hidden = !hidden;
          panel.classList.toggle("hidden", hidden);
          btn.textContent = hidden ? "»" : "«";
        });
      })();

      // ===== 필터 버튼 =====
      function updateFilterButtons() {
        const btns = document.querySelectorAll("#filterRow button.chip");
        btns.forEach((b) => {
          const mode = b.getAttribute("data-mode");
          if (mode === filterMode) b.classList.add("active");
          else b.classList.remove("active");
        });
      }

      document.querySelectorAll("#filterRow button.chip").forEach((btn) => {
        btn.addEventListener("click", () => {
          const mode = btn.getAttribute("data-mode");
          if (!mode) return;
          filterMode = mode;
          updateFilterButtons();
          renderMarkers(currentAssignments, lastMaxSizeForGrouping);
          saveStateToStorage();
        });
      });

      // ===== 주소 전처리/후보 =====
      function simplifyKoreanAddress(addr) {
        if (!addr) return addr;
        let s = addr.replace(/\(.*?\)/g, " ");
        s = s.replace(/\s+/g, " ").trim();
        const tokens = s.split(" ");
        let cutIndex = -1;
        for (let i = 0; i < tokens.length - 1; i++) {
          const t = tokens[i];
          const next = tokens[i + 1];
          if (/[로길]$/.test(t) && /^[0-9\-]+$/.test(next)) {
            cutIndex = i + 1;
          }
        }
        if (cutIndex !== -1) {
          return tokens
            .slice(0, cutIndex + 1)
            .join(" ")
            .trim();
        }
        return s;
      }

      function extractJibeon(addr) {
        const m = addr.match(/\(([^)]+)\)/);
        if (!m) return null;
        const inner = m[1];
        const firstPart = inner.split(",")[0];
        const parts = firstPart.split(/\s+/).filter(Boolean);
        if (parts.length >= 2) {
          return parts.slice(0, 2).join(" ");
        }
        return firstPart.trim();
      }

      function buildCandidates(originalAddr) {
        const candidates = [];
        const seen = new Set();
        const add = (s) => {
          if (!s) return;
          const n = normalizeAddress(s);
          if (!n || seen.has(n)) return;
          seen.add(n);
          candidates.push(n);
        };

        add(originalAddr);
        const simplified = simplifyKoreanAddress(originalAddr);
        add(simplified);

        const base = simplified || originalAddr;
        if (base) {
          const t = base.split(" ").filter(Boolean);
          if (t.length >= 2) {
            if (/^경기(도)?$/.test(t[0])) {
              add(t.slice(1).join(" "));
            }
            const cityIdx = t.findIndex((x) => x.endsWith("시"));
            if (cityIdx >= 0) {
              const city = t[cityIdx];
              const afterCity = t.slice(cityIdx + 1);
              if (afterCity.length >= 2) {
                add(city + " " + afterCity.join(" "));
                const roadNum = afterCity.slice(-2).join(" ");
                add(city + " " + roadNum);
              }
            }
            const roadNum2 = t.slice(-2).join(" ");
            add(roadNum2);
          }
        }

        const jibeon = extractJibeon(originalAddr);
        if (jibeon) {
          add(jibeon);
          add("평택시 " + jibeon);
        }

        return candidates;
      }

      // ===== 네이버 지오코딩 =====
      function geocodeNaver(query) {
        return new Promise((resolve) => {
          if (!query) {
            resolve(null);
            return;
          }

          if (
            !naver.maps.Service ||
            typeof naver.maps.Service.geocode !== "function"
          ) {
            console.error("Geocoder 서브모듈이 로드되지 않았습니다.");
            resolve(null);
            return;
          }

          naver.maps.Service.geocode({ query }, (status, response) => {
            if (status !== naver.maps.Service.Status.OK) {
              resolve(null);
              return;
            }
            const addrObj =
              response &&
              response.v2 &&
              response.v2.addresses &&
              response.v2.addresses[0];
            if (!addrObj) {
              resolve(null);
              return;
            }
            const lng = parseFloat(addrObj.x);
            const lat = parseFloat(addrObj.y);
            if (isNaN(lat) || isNaN(lng)) {
              resolve(null);
            } else {
              resolve({ lat, lng });
            }
          });
        });
      }

      async function geocodeWithFallback(originalAddr) {
        const cand = buildCandidates(originalAddr);
        for (let i = 0; i < cand.length; i++) {
          const q = cand[i];
          const p = await geocodeNaver(q);
          if (p) return { point: p, usedAddress: q };
        }
        return null;
      }

      // ===== 거리 계산(km) =====
      function distanceKmPoint(p1, p2) {
        const R = 6371.0088;
        const lat1 = (p1.lat * Math.PI) / 180;
        const lat2 = (p2.lat * Math.PI) / 180;
        const dLat = lat2 - lat1;
        const dLon = ((p2.lng - p1.lng) * Math.PI) / 180;
        const a =
          Math.sin(dLat / 2) ** 2 +
          Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      // ===== k-means =====
      function runKMeans(numGroups, maxIter = 20) {
        const n = points.length;
        let k = Math.min(numGroups, n);
        const indices = Array.from({ length: n }, (_, i) => i);
        for (let i = n - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [indices[i], indices[j]] = [indices[j], indices[i]];
        }

        let centroids = [];
        for (let i = 0; i < k; i++) {
          const p = points[indices[i]];
          centroids.push({ lat: p.lat, lng: p.lng });
        }

        let assignments = new Array(n).fill(0);

        for (let iter = 0; iter < maxIter; iter++) {
          for (let i = 0; i < n; i++) {
            let best = 0;
            let bestDist = Infinity;
            for (let c = 0; c < k; c++) {
              const d = distanceKmPoint(points[i], centroids[c]);
              if (d < bestDist) {
                bestDist = d;
                best = c;
              }
            }
            assignments[i] = best;
          }

          const sumLat = new Array(k).fill(0);
          const sumLng = new Array(k).fill(0);
          const count = new Array(k).fill(0);

          for (let i = 0; i < n; i++) {
            const g = assignments[i];
            sumLat[g] += points[i].lat;
            sumLng[g] += points[i].lng;
            count[g] += 1;
          }

          for (let c = 0; c < k; c++) {
            if (count[c] > 0) {
              centroids[c] = {
                lat: sumLat[c] / count[c],
                lng: sumLng[c] / count[c],
              };
            } else {
              const idx = Math.floor(Math.random() * n);
              centroids[c] = { lat: points[idx].lat, lng: points[idx].lng };
            }
          }
        }

        return { assignments, centroids };
      }

      // ===== 전체 가구 수 & 추천 그룹 수 =====
      function getTotalHouseholdCount() {
        return points.length + unresolvedPoints.length;
      }

      function updateRecommendedGroups() {
        const total = getTotalHouseholdCount();
        const maxSize = parseInt(maxGroupInput.value, 10);
        if (!total || !maxSize || maxSize <= 0) {
          recommendedGroupsGlobal = null;
          return null;
        }

        const minGroups = Math.ceil(total / maxSize);
        recommendedGroupsGlobal = minGroups;
        if (!numGroupsInput.value) {
          numGroupsInput.value = minGroups;
        }

        statusEl.textContent =
          `전체 가구 수: ${total}개 / 최대 ${maxSize}가구 기준 ` +
          `이론상 초과 없이 배치 가능한 최소 그룹 수: 약 ${minGroups}개`;

        return minGroups;
      }

      // ===== 그룹핑 =====
      function groupWithConstraints(maxSize, numGroups) {
        const n = points.length;
        if (n === 0) return null;
        if (numGroups <= 0) numGroups = 1;
        if (numGroups > n) numGroups = n;
        if (maxSize <= 0) maxSize = n;

        const totalHouseholds = getTotalHouseholdCount();
        const recommendedGroups =
          recommendedGroupsGlobal ||
          (maxSize > 0 ? Math.ceil(totalHouseholds / maxSize) : null);
        const capacity = maxSize * numGroups;

        let msg;
        if (capacity < totalHouseholds) {
          msg =
            `참고: 전체 ${totalHouseholds}가구를 ` +
            `${numGroups}그룹 × 최대 ${maxSize}가구로는 이론상 다 못 채워서 ` +
            "일부 그룹은 기준을 초과할 수 있습니다. (출발점 가까운 그룹부터 초과 허용)";
        } else {
          msg = `최대 ${maxSize}가구 × ${numGroups}그룹으로 배치 시도 중...`;
        }

        if (recommendedGroups) {
          if (numGroups < recommendedGroups) {
            msg += ` / ⚠ 추천 그룹 수(${recommendedGroups}개)보다 적게 입력되어, 이론상도 초과 그룹이 생길 수 있습니다.`;
          } else if (numGroups === recommendedGroups) {
            msg += ` / 추천 최소 그룹 수와 동일한 설정입니다.`;
          } else {
            msg += ` / 추천값(${recommendedGroups}개)보다 여유 있는 그룹 수입니다. (가구 수 분산 가능)`;
          }
        }
        statusEl.textContent = msg;

        let { assignments, centroids } = runKMeans(numGroups);

        let groups = Array.from({ length: numGroups }, () => []);
        for (let i = 0; i < n; i++) {
          groups[assignments[i]].push(i);
        }

        function recomputeCentroids() {
          centroids = [];
          for (let g = 0; g < numGroups; g++) {
            if (groups[g].length === 0) {
              const idx = Math.floor(Math.random() * n);
              centroids[g] = { lat: points[idx].lat, lng: points[idx].lng };
            } else {
              let sLat = 0,
                sLng = 0;
              groups[g].forEach((i) => {
                sLat += points[i].lat;
                sLng += points[i].lng;
              });
              centroids[g] = {
                lat: sLat / groups[g].length,
                lng: sLng / groups[g].length,
              };
            }
          }
        }

        recomputeCentroids();

        // 1차: 초과 그룹에서 먼 것들 overflow로
        let overflow = [];
        for (let g = 0; g < numGroups; g++) {
          if (groups[g].length > maxSize) {
            const center = centroids[g];
            groups[g].sort((a, b) => {
              const da = distanceKmPoint(points[a], center);
              const db = distanceKmPoint(points[b], center);
              return da - db;
            });
            while (groups[g].length > maxSize) {
              overflow.push(groups[g].pop());
            }
          }
        }

        recomputeCentroids();

        // 2차: overflow 재배치 (너무 먼 그룹 제외)
        overflow.forEach((idx) => {
          let bestGroup = -1;
          let bestScore = Infinity;

          for (let g = 0; g < numGroups; g++) {
            if (groups[g].length >= maxSize) continue;
            const dPoint = distanceKmPoint(points[idx], centroids[g]);
            if (dPoint > MAX_REALLOC_POINT_DIST_KM) continue;

            const dStart = distanceKmPoint(centroids[g], {
              lat: START_POINT.y,
              lng: START_POINT.x,
            });
            const score = dPoint + 0.2 * dStart;
            if (score < bestScore) {
              bestScore = score;
              bestGroup = g;
            }
          }

          if (bestGroup === -1) {
            let best = -1;
            let bestScore2 = Infinity;
            for (let g = 0; g < numGroups; g++) {
              const dPoint = distanceKmPoint(points[idx], centroids[g]);
              const dStart = distanceKmPoint(centroids[g], {
                lat: START_POINT.y,
                lng: START_POINT.x,
              });
              const score = dPoint + 0.3 * dStart;
              if (score < bestScore2) {
                bestScore2 = score;
                best = g;
              }
            }
            bestGroup = best;
          }

          groups[bestGroup].push(idx);
          const gm = groups[bestGroup];
          let sLat = 0,
            sLng = 0;
          gm.forEach((i) => {
            sLat += points[i].lat;
            sLng += points[i].lng;
          });
          centroids[bestGroup] = {
            lat: sLat / gm.length,
            lng: sLng / gm.length,
          };
        });

        const finalAssignments = new Array(n).fill(-1);
        for (let g = 0; g < numGroups; g++) {
          groups[g].forEach((i) => {
            finalAssignments[i] = g;
          });
        }
        return finalAssignments;
      }

      // ===== 균형 조정 제안 =====
      function computeBalanceSuggestions(assignments) {
        if (!assignments || !points.length) return [];
        const n = points.length;
        let maxGroupIdx = -1;
        assignments.forEach((g) => {
          if (g != null && g >= 0 && g > maxGroupIdx) maxGroupIdx = g;
        });
        const numGroupsLocal = maxGroupIdx + 1;
        if (numGroupsLocal <= 1) return [];

        const counts = new Array(numGroupsLocal).fill(0);
        const sumLat = new Array(numGroupsLocal).fill(0);
        const sumLng = new Array(numGroupsLocal).fill(0);

        for (let i = 0; i < n; i++) {
          const g = assignments[i];
          if (g == null || g < 0) continue;
          counts[g]++;
          sumLat[g] += points[i].lat;
          sumLng[g] += points[i].lng;
        }

        const centroids = [];
        let totalAssigned = 0;
        for (let g = 0; g < numGroupsLocal; g++) {
          if (counts[g] > 0) {
            centroids[g] = {
              lat: sumLat[g] / counts[g],
              lng: sumLng[g] / counts[g],
            };
            totalAssigned += counts[g];
          } else {
            centroids[g] = null;
          }
        }

        if (totalAssigned === 0) return [];
        const avgCount = totalAssigned / numGroupsLocal;
        const suggestions = [];

        for (let i = 0; i < n; i++) {
          const g = assignments[i];
          if (g == null || g < 0) continue;
          if (!centroids[g]) continue;

          const fromSize = counts[g];
          if (fromSize <= avgCount + 1) continue; // 너무 큰 그룹만 후보

          const pt = { lat: points[i].lat, lng: points[i].lng };
          const dFrom = distanceKmPoint(pt, centroids[g]);

          let bestOther = -1;
          let bestOtherDist = Infinity;
          for (let h = 0; h < numGroupsLocal; h++) {
            if (h === g) continue;
            if (!centroids[h]) continue;
            const toSize = counts[h];
            if (toSize >= avgCount - 1) continue; // 많이 부족한 그룹 위주
            const dTo = distanceKmPoint(pt, centroids[h]);
            if (dTo < bestOtherDist) {
              bestOtherDist = dTo;
              bestOther = h;
            }
          }

          if (bestOther === -1) continue;

          // 다른 그룹과의 거리 차이가 너무 크면 제외
          if (bestOtherDist > dFrom + 1) continue;

          suggestions.push({
            pointIndex: i,
            fromGroup: g + 1,
            toGroup: bestOther + 1,
            fromSize: fromSize,
            toSize: counts[bestOther],
            distFrom: dFrom,
            distTo: bestOtherDist,
            address: points[i].original,
          });
        }

        // 너무 많아지지 않게 상위 20개만
        return suggestions.slice(0, 20);
      }

      // ===== 하이라이트 =====
      let highlightedIndices = [];

      function clearHighlight() {
        if (!markers.length || !highlightedIndices.length) {
          highlightedIndices = [];
          return;
        }
        highlightedIndices.forEach((i) => {
          const marker = markers[i];
          if (!marker || !marker.getElement) return;
          const el = marker.getElement();
          if (!el) return;
          const inner = el.querySelector("div") || el;
          inner.style.transform = "";
          inner.style.boxShadow = "";
        });
        highlightedIndices = [];
      }

      function highlightMarkers(indices) {
        clearHighlight();
        indices.forEach((i) => {
          const marker = markers[i];
          if (!marker || !marker.getElement) return;
          const el = marker.getElement();
          if (!el) return;
          const inner = el.querySelector("div") || el;
          inner.style.transform = "scale(1.4)";
          inner.style.boxShadow = "0 0 8px rgba(0, 0, 0, 0.7)";
        });
        highlightedIndices = indices.slice();
      }

      window.clearHighlight = clearHighlight;

      function clearMarkers() {
        markers.forEach((m) => m.setMap(null));
        markers = [];
      }

      function escapeHtml(str) {
        return String(str || "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      function buildGroupOptionsHtml(currentGroupId, numGroups) {
        let html = `<option value="0"${
          currentGroupId === 0 ? " selected" : ""
        }>미지정</option>`;
        for (let g = 1; g <= numGroups; g++) {
          const selected = currentGroupId === g ? " selected" : "";
          html += `<option value="${g}"${selected}>그룹 ${g}</option>`;
        }
        return html;
      }

      // ===== Drag & Drop =====
      window.onAddressDragStart = function (ev, kind, idx) {
        if (!ev || !ev.dataTransfer) return;
        ev.dataTransfer.effectAllowed = "move";
        ev.dataTransfer.setData(
          "text/plain",
          JSON.stringify({ type: kind, index: idx })
        );
      };

      window.onGroupDragOver = function (ev) {
        ev.preventDefault();
        if (ev.dataTransfer) ev.dataTransfer.dropEffect = "move";
      };

      window.onGroupDrop = function (ev, groupDisplayId) {
        ev.preventDefault();
        try {
          const raw = ev.dataTransfer.getData("text/plain");
          if (!raw) return;
          const data = JSON.parse(raw);
          if (!data || typeof data.index !== "number") return;
          const gId = parseInt(groupDisplayId, 10);
          if (isNaN(gId) || gId < 0) return;

          if (data.type === "point") {
            changeGroupTo(data.index, gId);
          } else if (data.type === "unresolved") {
            changeUnresolvedGroupTo(data.index, gId);
          }
        } catch (e) {
          console.warn("드래그 드롭 파싱 오류:", e);
        }
      };

      function updateLegend(groupCounts) {
        if (!groupCounts || !Object.keys(groupCounts).length) {
          legendEl.classList.add("hidden");
          legendEl.innerHTML = "";
          return;
        }
        const groupIds = Object.keys(groupCounts)
          .map((x) => parseInt(x, 10))
          .sort((a, b) => a - b);
        let html = `<div style="font-weight:600;margin-bottom:2px;">그룹 색상 안내</div>`;
        groupIds.forEach((id) => {
          const color = groupColors[(id - 1) % groupColors.length];
          html += `<div class="legend-row">
            <div class="color-box" style="background:${color};"></div>
            <span>그룹 ${id} (${groupCounts[id]} 가구)</span>
          </div>`;
        });
        legendEl.innerHTML = html;
        legendEl.classList.remove("hidden");
      }

      // ===== 마커 + 리스트 렌더링 =====
      function renderMarkers(assignments, maxSizeForLabel) {
        const prevOpenGroups = new Set();
        const oldDetails =
          groupInfoEl.querySelectorAll &&
          groupInfoEl.querySelectorAll("details[data-group-id]");
        if (oldDetails && oldDetails.length) {
          oldDetails.forEach((d) => {
            const id = parseInt(d.getAttribute("data-group-id"), 10);
            if (!isNaN(id) && d.open) prevOpenGroups.add(id);
          });
        }

        clearMarkers();
        groupInfoEl.textContent = "";
        clearHighlight();

        legendEl.classList.add("hidden");
        legendEl.innerHTML = "";

        if (!points.length && !unresolvedPoints.length) return;

        const bounds = new naver.maps.LatLngBounds();
        const hasGrouping = Array.isArray(assignments);
        const groupCounts = {};
        const groupMembers = {};

        let numGroupsLocal = 0;
        if (hasGrouping) {
          numGroupsLocal =
            lastNumGroupsForGrouping ||
            Math.max(0, ...assignments.map((g) => (g == null ? -1 : g))) + 1;
        }

        // 지도 마커
        for (let i = 0; i < points.length; i++) {
          const p = points[i];
          const pos = new naver.maps.LatLng(p.lat, p.lng);

          let showForFilter =
            filterMode === "all" || filterMode === "group" ? true : false;

          if (showForFilter) bounds.extend(pos);

          let icon = null;
          let popupHtml =
            `<b>원본 주소</b><br>${escapeHtml(p.original)}<br><br>` +
            `<b>검색에 사용한 주소</b><br>${escapeHtml(p.used)}<br>` +
            `${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}`;

          // 품목 리스트는 접을 수 있게 안내만
          if (p.items && p.items.length) {
            popupHtml += `<br><br><b>품목 ${p.items.length}개</b><ul style='margin:2px 0 0 1.2em;'>`;
            p.items.forEach((it) => {
              const txt = escapeHtml(it.itemName || "[품목명 없음]");
              popupHtml += `<li>${txt}</li>`;
            });
            popupHtml += "</ul>";
          }

          let displayGroupId = 0;
          if (
            hasGrouping &&
            typeof assignments[i] === "number" &&
            assignments[i] >= 0
          ) {
            const g = assignments[i];
            displayGroupId = g + 1;
            const color = groupColors[g % groupColors.length];

            const groupId = displayGroupId;
            groupCounts[groupId] = (groupCounts[groupId] || 0) + 1;
            if (!groupMembers[groupId]) groupMembers[groupId] = [];
            groupMembers[groupId].push({ address: p.original, index: i });

            icon = {
              content: `<div style="
                width:24px;height:24px;border-radius:50%;
                background:${color};
                color:#fff;
                display:flex;
                align-items:center;
                justify-content:center;
                font-size:12px;
                border:2px solid #fff;
                box-shadow:0 0 2px rgba(0,0,0,0.5);
              ">${groupId}</div>`,
              size: new naver.maps.Size(24, 24),
              anchor: new naver.maps.Point(12, 12),
            };

            const optionsHtml = buildGroupOptionsHtml(
              displayGroupId,
              numGroupsLocal
            );
            popupHtml =
              `<b>그룹 ${groupId}</b><br><br>` +
              popupHtml +
              `<br><br><label style="font-size:11px;">그룹 변경:
<select onchange="changeGroupTo(${i}, this.value)" style="font-size:11px;">
${optionsHtml}
</select></label>`;
          } else if (hasGrouping && numGroupsLocal > 0) {
            const optionsHtml = buildGroupOptionsHtml(0, numGroupsLocal);
            popupHtml += `<br><br><label style="font-size:11px;">그룹 지정:
<select onchange="changeGroupTo(${i}, this.value)" style="font-size:11px;">
${optionsHtml}
</select></label>`;
          }

          const marker = new naver.maps.Marker({
            position: pos,
            map: showForFilter ? map : null,
            icon: icon || undefined,
          });

          naver.maps.Event.addListener(marker, "click", () => {
            if (!sharedInfoWindow) return;
            sharedInfoWindow.setContent(
              `<div style="padding:6px;font-size:12px;">${popupHtml}</div>`
            );
            sharedInfoWindow.open(map, marker);
          });

          markers.push(marker);
        }

        if (
          markers.length &&
          (filterMode === "all" || filterMode === "group")
        ) {
          try {
            if (!bounds.isEmpty()) {
              map.fitBounds(bounds);
            }
          } catch (e) {
            map.fitBounds(bounds);
          }
        }

        // ===== 리스트 HTML =====
        let html = "";
        let imbalanceInfo = {};
        let suggestions = [];

        if (hasGrouping && numGroupsLocal > 0 && filterMode !== "unresolved") {
          const groupIds = Object.keys(groupCounts)
            .map((x) => parseInt(x, 10))
            .sort((a, b) => a - b);

          if (groupIds.length) {
            // 불균형 판단용
            const totalCount = groupIds.reduce(
              (sum, id) => sum + (groupCounts[id] || 0),
              0
            );
            const avgCount = totalCount / groupIds.length;
            groupIds.forEach((id) => {
              const c = groupCounts[id] || 0;
              const ratio = avgCount > 0 ? c / avgCount : 1;
              if (ratio <= 0.5) imbalanceInfo[id] = "low";
              else if (ratio >= 1.5) imbalanceInfo[id] = "high";
              else imbalanceInfo[id] = "normal";
            });

            // 경계 가구 제안
            if (currentAssignments) {
              suggestions = computeBalanceSuggestions(currentAssignments);
              if (suggestions.length) {
                html += `<details open>
  <summary>균형 조정 제안 (${suggestions.length}개)</summary>
  <ul>`;
                suggestions.forEach((s, idx) => {
                  html += `<li onmouseenter="focusPoint(${
                    s.pointIndex
                  })" onmouseleave="clearHighlight()">
  [${idx + 1}] 그룹 ${s.fromGroup} (${s.fromSize}가구) → 그룹 ${s.toGroup} (${
                    s.toSize
                  }가구) 이동 추천<br/>
  ${escapeHtml(s.address)}
  <button class="chip" style="margin-left:4px;" onclick="changeGroupTo(${
    s.pointIndex
  }, ${s.toGroup});">적용</button>
</li>`;
                });
                html += `</ul></details>`;
              }
            }

            html += `그룹 수: ${groupIds.length}개<br>`;
            groupIds.forEach((id) => {
              const count = groupCounts[id] || 0;
              const members = groupMembers[id] || [];
              const over =
                maxSizeForLabel && count > maxSizeForLabel
                  ? ` <span style="color:#ef4444;">(기준 ${maxSizeForLabel}가구 초과)</span>`
                  : "";

              let imbalanceText = "";
              if (imbalanceInfo[id] === "low") {
                imbalanceText = ` <span style="color:#f97316;">(가구 수 적음)</span>`;
              } else if (imbalanceInfo[id] === "high") {
                imbalanceText = ` <span style="color:#f97316;">(가구 수 많음)</span>`;
              }

              const openAttr = prevOpenGroups.has(id) ? "open" : "";

              html += `<details data-group-id="${id}" ${openAttr} ondragover="onGroupDragOver(event)" ondrop="onGroupDrop(event, ${id})">
  <summary onmouseenter="focusGroup(${id})" onmouseleave="clearHighlight()">그룹 ${id} (${count} 가구${over})${imbalanceText}</summary>
  <ul>`;
              members.forEach(({ address, index }) => {
                const p = points[index];
                const assignment =
                  currentAssignments && currentAssignments[index] != null
                    ? currentAssignments[index]
                    : -1;
                const displayGroupId2 = assignment >= 0 ? assignment + 1 : 0;
                const optionsHtml = buildGroupOptionsHtml(
                  displayGroupId2,
                  numGroupsLocal
                );
                const itemCount = p.items ? p.items.length : 0;

                let itemListHtml = "";
                if (itemCount > 0) {
                  itemListHtml = `<details style="margin-top:2px;font-size:11px;">
  <summary>품목 ${itemCount}개</summary>
  <ul style='margin:2px 0 4px 1.2em;font-size:11px;'>`;
                  p.items.forEach((it) => {
                    const txt = escapeHtml(it.itemName || "[품목명 없음]");
                    itemListHtml += `<li>${txt}</li>`;
                  });
                  itemListHtml += `</ul></details>`;
                }

                html += `<li draggable="true" ondragstart="onAddressDragStart(event, 'point', ${index})"
  onmouseenter="focusPoint(${index})" onmouseleave="clearHighlight()">
  ${escapeHtml(address)}${
                  itemCount
                    ? ` <span style="color:#6b7280;">(품목 ${itemCount}개)</span>`
                    : ""
                }
  <select onchange="changeGroupTo(${index}, this.value)" style="margin-left:4px;font-size:11px;">
    ${optionsHtml}
  </select>
  ${itemListHtml}
</li>`;
              });
              html += `</ul></details>`;
            });
          } else {
            html +=
              "그룹 정보가 없습니다. (좌표 있는 가구가 없거나 모두 미지정 상태입니다)";
          }
        } else if (filterMode !== "unresolved") {
          html +=
            "아직 그룹이 적용되지 않았습니다. (2단계 버튼으로 그룹을 묶어주세요)";
        }

        // 색상 범례 업데이트
        if (hasGrouping && filterMode !== "unresolved") {
          updateLegend(groupCounts);
        } else {
          legendEl.classList.add("hidden");
          legendEl.innerHTML = "";
        }

        // ===== 지오코딩 실패 / 미지정 =====
        if (unresolvedPoints.length) {
          html += `<hr style="border:none;border-top:1px solid #e5e7eb;margin:6px 0;" />`;
          const openAttr = filterMode === "unresolved" ? "open" : "";
          html += `<details data-unresolved="1" ${openAttr}
  ondragover="onGroupDragOver(event)" ondrop="onGroupDrop(event, 0)">
  <summary>미지정 / 지오코딩 실패 (${unresolvedPoints.length} 가구)</summary>
  <ul>`;
          const numGroupsLocal2 = numGroupsLocal || 0;
          unresolvedPoints.forEach((p, idx) => {
            const displayGroupId =
              unresolvedAssignments[idx] && unresolvedAssignments[idx] > 0
                ? unresolvedAssignments[idx]
                : 0;
            const optionsHtml = buildGroupOptionsHtml(
              displayGroupId,
              numGroupsLocal2
            );
            const itemCount = p.items ? p.items.length : 0;

            let itemListHtml = "";
            if (itemCount > 0) {
              itemListHtml = `<details style="margin-top:2px;font-size:11px;">
  <summary>품목 ${itemCount}개</summary>
  <ul style='margin:2px 0 4px 1.2em;font-size:11px;'>`;
              p.items.forEach((it) => {
                const txt = escapeHtml(it.itemName || "[품목명 없음]");
                itemListHtml += `<li>${txt}</li>`;
              });
              itemListHtml += `</ul></details>`;
            }

            html += `<li draggable="true" ondragstart="onAddressDragStart(event, 'unresolved', ${idx})">
  ${escapeHtml(p.original)}${
              itemCount
                ? ` <span style="color:#6b7280;">(품목 ${itemCount}개)</span>`
                : ""
            }
  <select onchange="changeUnresolvedGroupTo(${idx}, this.value)" style="margin-left:4px;font-size:11px;">
    ${optionsHtml}
  </select>
  ${itemListHtml}
</li>`;
          });
          html += `</ul></details>`;
        }

        groupInfoEl.innerHTML = html;
      }

      // ===== 리스트 포커스 =====
      window.focusGroup = function (groupDisplayId) {
        if (!currentAssignments || !markers.length) return;
        const gIdx = parseInt(groupDisplayId, 10) - 1;
        if (isNaN(gIdx) || gIdx < 0) return;

        const b = new naver.maps.LatLngBounds();
        const indices = [];
        for (let i = 0; i < currentAssignments.length; i++) {
          if (currentAssignments[i] === gIdx && markers[i]) {
            b.extend(markers[i].getPosition());
            indices.push(i);
          }
        }
        if (indices.length) {
          map.fitBounds(b);
          highlightMarkers(indices);
        }
      };

      window.focusPoint = function (pointIndex) {
        const idx = parseInt(pointIndex, 10);
        if (isNaN(idx) || !markers[idx]) return;
        const pos = markers[idx].getPosition();
        map.panTo(pos);
        if (map.getZoom() < 15) {
          map.setZoom(15);
        }
        highlightMarkers([idx]);
      };

      // ===== 그룹 변경 (좌표 있는 주소) =====
      window.changeGroupTo = function (pointIndex, groupDisplayId) {
        if (!currentAssignments || !Array.isArray(currentAssignments)) {
          alert("먼저 그룹을 생성한 뒤에 사용해 주세요.");
          return;
        }
        const numGroups =
          lastNumGroupsForGrouping ||
          Math.max(0, ...currentAssignments.map((g) => (g == null ? -1 : g))) +
            1;

        let gId = parseInt(groupDisplayId, 10);
        if (isNaN(gId) || gId < 0) return;
        if (gId > numGroups) gId = numGroups;

        if (gId === 0) {
          currentAssignments[pointIndex] = -1;
        } else {
          currentAssignments[pointIndex] = gId - 1;
        }
        renderMarkers(currentAssignments, lastMaxSizeForGrouping);
        saveStateToStorage();
      };

      // ===== 그룹 변경 (지오코딩 실패 / 좌표 없는 주소) =====
      window.changeUnresolvedGroupTo = function (unresIndex, groupDisplayId) {
        const numGroups =
          lastNumGroupsForGrouping ||
          (currentAssignments
            ? Math.max(
                0,
                ...currentAssignments.map((g) => (g == null ? -1 : g))
              ) + 1
            : 0);

        let gId = parseInt(groupDisplayId, 10);
        if (isNaN(gId) || gId < 0) return;
        if (gId > numGroups) gId = numGroups;

        unresolvedAssignments[unresIndex] = gId;
        renderMarkers(currentAssignments, lastMaxSizeForGrouping);
        saveStateToStorage();
      };

      // ===== 그룹 적용 공통 =====
      function applyGroupingFromInputs() {
        if (!points.length && !unresolvedPoints.length) {
          alert("먼저 주소 지오코딩을 해주세요.");
          return;
        }
        const maxSize = parseInt(maxGroupInput.value, 10);
        const numGroups = parseInt(numGroupsInput.value, 10);

        if (!maxSize || maxSize <= 0 || !numGroups || numGroups <= 0) {
          alert("최대 가구 수와 그룹 수를 모두 올바르게 입력해 주세요.");
          return;
        }

        const assignments = groupWithConstraints(maxSize, numGroups);
        if (!assignments) return;

        currentAssignments = assignments.slice();
        lastMaxSizeForGrouping = maxSize;
        lastNumGroupsForGrouping = numGroups;

        if (!unresolvedAssignments.length) {
          unresolvedAssignments = unresolvedPoints.map(() => 0);
        }

        renderMarkers(assignments, maxSize);
        saveStateToStorage();
      }

      // ===== 엑셀 → 가구/품목 구조 =====
      function rebuildHouseholdsFromExcel(resetPointsAndMap) {
        if (!excelRows.length) return;
        if (!window.XLSX) {
          alert("XLSX 라이브러리가 로드되지 않았습니다.");
          return;
        }

        const addrColIdx =
          parseInt(document.getElementById("colAddress").value, 10) - 1;
        const itemColIdx =
          parseInt(document.getElementById("colItem").value, 10) - 1;

        if (isNaN(addrColIdx) || addrColIdx < 0) {
          statusEl.textContent = "주소 열 번호를 올바르게 입력해 주세요.";
          return;
        }

        excelHouseholdMap = new Map();
        let totalRows = 0;
        let addressRows = 0;
        let itemRows = 0;

        excelRows.forEach((row, idx) => {
          if (!row || row.length === 0) return;
          totalRows++;
          const addr = normalizeAddress(row[addrColIdx]);
          if (!addr) return;
          addressRows++;

          const key = normalizeAddress(addr);
          let house = excelHouseholdMap.get(key);
          if (!house) {
            house = { originalAddress: addr, items: [] };
            excelHouseholdMap.set(key, house);
          }

          let itemName =
            itemColIdx >= 0 && row[itemColIdx] !== undefined
              ? String(row[itemColIdx])
              : "";

          if (itemName) {
            itemRows++;
            house.items.push({
              itemName,
              excelRow: idx + 1,
            });
          }
        });

        const households = Array.from(excelHouseholdMap.values());
        document.getElementById("addrInput").value = households
          .map((h) => h.originalAddress)
          .join("\n");

        if (resetPointsAndMap) {
          points = [];
          currentAssignments = null;
          lastMaxSizeForGrouping = null;
          lastNumGroupsForGrouping = null;
          unresolvedPoints = [];
          unresolvedAssignments = [];
          clearMarkers();
          groupInfoEl.textContent = "";

          statusEl.textContent =
            `엑셀 읽기 완료: 총 ${totalRows}행, 주소 있는 행 ${addressRows}개, ` +
            `가구 수 ${households.length}개, 품목 행 ${itemRows}개. ` +
            `→ 1단계 버튼으로 지오코딩을 진행하세요.`;
          saveStateToStorage();
        } else {
          const keyToItems = new Map();
          excelHouseholdMap.forEach((house, key) => {
            keyToItems.set(key, house.items);
          });
          points.forEach((p) => {
            const key = normalizeAddress(p.original);
            const items = keyToItems.get(key);
            p.items = items ? items.slice() : [];
          });

          unresolvedPoints.forEach((p) => {
            const key = normalizeAddress(p.original);
            const items = keyToItems.get(key);
            p.items = items ? items.slice() : [];
          });

          statusEl.textContent =
            `엑셀 열 매핑 변경 반영: 가구 수 ${households.length}개, 품목 행 ${itemRows}개` +
            (points.length
              ? ` / 지도 가구 수 ${points.length}개 (좌표 유지)`
              : "");

          if (points.length || unresolvedPoints.length) {
            renderMarkers(currentAssignments, lastMaxSizeForGrouping);
          }
          saveStateToStorage();
        }
      }

      // ===== 엑셀 파일 선택 시 자동 로드 =====
      document.getElementById("excelFile").addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;
        if (!window.XLSX) {
          alert("XLSX 라이브러리가 로드되지 않았습니다.");
          return;
        }

        const reader = new FileReader();
        reader.onload = function (ev) {
          const data = new Uint8Array(ev.target.result);
          const wb = XLSX.read(data, { type: "array" });
          const sheet = wb.Sheets[wb.SheetNames[0]];
          excelRows = XLSX.utils.sheet_to_json(sheet, {
            header: 1,
            defval: "",
          });

          rebuildHouseholdsFromExcel(true);
        };
        reader.readAsArrayBuffer(file);
      });

      ["colAddress", "colItem"].forEach((id) => {
        const el = document.getElementById(id);
        el.addEventListener("change", () => {
          if (!excelRows.length) return;
          rebuildHouseholdsFromExcel(false);
        });
      });

      // ===== 지오코딩 버튼 =====
      document
        .getElementById("geocodeBtn")
        .addEventListener("click", async () => {
          const raw = document.getElementById("addrInput").value.trim();
          if (!raw) {
            alert("도로명 주소를 붙여넣어 주세요.");
            return;
          }

          groupInfoEl.textContent = "";

          const rawList = raw
            .split(/\r?\n/)
            .map((s) => s.trim())
            .filter(Boolean);

          const seen = new Set();
          const dedupedList = [];
          let dupCount = 0;

          for (const addr of rawList) {
            const key = normalizeAddress(addr);
            if (!seen.has(key)) {
              seen.add(key);
              dedupedList.push(addr);
            } else {
              dupCount++;
            }
          }

          let newPoints = [];
          let skipCount = 0;
          let newGeocodeSuccess = 0;
          let newGeocodeFail = 0;

          // 1) 캐시 사용
          for (const addr of dedupedList) {
            const key = normalizeAddress(addr);
            const cached = geocodeCache[key];
            const excelHouse = excelHouseholdMap.get(key);
            if (cached) {
              skipCount++;
              newPoints.push({
                original: addr,
                used: cached.used,
                lat: cached.lat,
                lng: cached.lng,
                items: excelHouse ? excelHouse.items.slice() : [],
              });
            }
          }

          // 2) 캐시에 없는 주소만 리스트업
          const toGeocode = [];
          for (const addr of dedupedList) {
            const key = normalizeAddress(addr);
            if (!geocodeCache[key]) {
              toGeocode.push({ addr, key });
            }
          }

          statusEl.textContent =
            `총 입력: ${rawList.length}개, 중복 제거 후: ${dedupedList.length}개` +
            (dupCount > 0 ? ` (중복 ${dupCount}개 제외됨)` : "") +
            (skipCount > 0 ? ` / 캐시 사용으로 스킵: ${skipCount}개` : "");

          // 3) 새 주소만 지오코딩
          for (let i = 0; i < toGeocode.length; i++) {
            const { addr, key } = toGeocode[i];
            statusEl.textContent =
              `(${i + 1}/${toGeocode.length}) "${addr}" 새 좌표 변환 중...` +
              (skipCount > 0 ? ` / 캐시 스킵: ${skipCount}개` : "");

            try {
              const result = await geocodeWithFallback(addr);
              if (result && result.point) {
                newGeocodeSuccess++;
                const excelHouse = excelHouseholdMap.get(key);
                const p = {
                  original: addr,
                  used: result.usedAddress,
                  lat: result.point.lat,
                  lng: result.point.lng,
                  items: excelHouse ? excelHouse.items.slice() : [],
                };
                geocodeCache[key] = {
                  used: p.used,
                  lat: p.lat,
                  lng: p.lng,
                };
                newPoints.push(p);
                saveGeocodeCacheToStorage();
              } else {
                newGeocodeFail++;
              }
            } catch (e) {
              console.error(e);
              newGeocodeFail++;
            }

            await new Promise((r) => setTimeout(r, 120));
          }

          points = newPoints;
          currentAssignments = null;
          lastMaxSizeForGrouping = null;
          lastNumGroupsForGrouping = null;

          // 지오코딩 실패/미지정 주소
          const resolvedKeySet = new Set(
            points.map((p) => normalizeAddress(p.original))
          );
          unresolvedPoints = [];
          unresolvedAssignments = [];

          dedupedList.forEach((addr) => {
            const key = normalizeAddress(addr);
            if (!resolvedKeySet.has(key)) {
              const excelHouse = excelHouseholdMap.get(key);
              unresolvedPoints.push({
                original: addr,
                items: excelHouse ? excelHouse.items.slice() : [],
              });
              unresolvedAssignments.push(0);
            }
          });

          let summary =
            `지오코딩 완료: 새 변환 ${newGeocodeSuccess}개, 실패 ${newGeocodeFail}개` +
            (skipCount > 0 ? `, 캐시 사용 ${skipCount}개` : "") +
            ` / 좌표 있는 가구: ${points.length}개` +
            (unresolvedPoints.length
              ? `, 지오코딩 실패/미지정: ${unresolvedPoints.length}개`
              : "");
          statusEl.textContent = summary;

          if (points.length || unresolvedPoints.length) {
            renderMarkers();
            const recommended = updateRecommendedGroups();
            if (recommended && points.length) {
              applyGroupingFromInputs();
            }
          }

          saveStateToStorage();
        });

      // ===== 그룹 해제 =====
      document.getElementById("resetGroupBtn").addEventListener("click", () => {
        if (!points.length && !unresolvedPoints.length) {
          alert("먼저 주소 지오코딩을 해주세요.");
          return;
        }
        currentAssignments = points.map(() => -1);
        lastMaxSizeForGrouping = null;
        lastNumGroupsForGrouping = null;
        unresolvedAssignments = unresolvedPoints.map(() => 0);

        renderMarkers(currentAssignments, null);
        statusEl.textContent = `그룹 해제됨 / 좌표 있는 가구: ${points.length}개, 미지정/실패: ${unresolvedPoints.length}개`;
        updateRecommendedGroups();
        saveStateToStorage();
      });

      maxGroupInput.addEventListener("change", () => {
        if (!points.length && !unresolvedPoints.length) return;
        updateRecommendedGroups();
        saveStateToStorage();
      });

      document.getElementById("applyGroupBtn").addEventListener("click", () => {
        applyGroupingFromInputs();
      });

      // ===== 엑셀 내보내기 =====
      document
        .getElementById("exportExcelBtn")
        .addEventListener("click", () => {
          if (!excelRows.length) {
            alert("먼저 엑셀 파일을 불러와 주세요.");
            return;
          }
          if (!window.XLSX) {
            alert("XLSX 라이브러리가 로드되지 않았습니다.");
            return;
          }
          if (!points.length && !unresolvedPoints.length) {
            alert("지오코딩 및 그룹 작업 후 내보내기를 실행해 주세요.");
            return;
          }
          if (!currentAssignments) {
            alert("2단계에서 그룹 묶기를 먼저 실행해 주세요.");
            return;
          }

          const addrColIdx =
            parseInt(document.getElementById("colAddress").value, 10) - 1;
          if (isNaN(addrColIdx) || addrColIdx < 0) {
            alert("주소 열 번호를 올바르게 입력해 주세요.");
            return;
          }

          const addressToGroup = new Map();

          const numGroups =
            lastNumGroupsForGrouping ||
            Math.max(
              0,
              ...currentAssignments.map((g) => (g == null ? -1 : g))
            ) + 1;

          // 좌표 있는 주소
          for (let i = 0; i < points.length; i++) {
            const p = points[i];
            const key = normalizeAddress(p.original);
            const assignment =
              currentAssignments && currentAssignments[i] != null
                ? currentAssignments[i]
                : -1;
            const displayGroupId = assignment >= 0 ? assignment + 1 : 0;
            if (!addressToGroup.has(key)) {
              addressToGroup.set(key, displayGroupId);
            }
          }

          // 지오코딩 실패/미지정 주소
          for (let i = 0; i < unresolvedPoints.length; i++) {
            const addr = unresolvedPoints[i].original;
            const key = normalizeAddress(addr);
            const gId = unresolvedAssignments[i] || 0;
            addressToGroup.set(key, gId);
          }

          const maxCols = excelRows.reduce(
            (m, row) => Math.max(m, row ? row.length : 0),
            0
          );

          const addressRowIndices = [];
          excelRows.forEach((row, idx) => {
            if (!row || row.length === 0) return;
            const addr = normalizeAddress(row[addrColIdx]);
            if (addr) addressRowIndices.push(idx);
          });

          const groupRows = new Map();

          addressRowIndices.forEach((idx) => {
            const row = excelRows[idx];
            const addr = normalizeAddress(row[addrColIdx]);
            const key = addr;
            const gId = addressToGroup.has(key) ? addressToGroup.get(key) : 0;
            if (!groupRows.has(gId)) groupRows.set(gId, []);
            groupRows.get(gId).push(idx);
          });

          const usedRowSet = new Set();
          groupRows.forEach((rows) => {
            rows.forEach((idx) => usedRowSet.add(idx));
          });

          const missingRows = addressRowIndices.filter(
            (idx) => !usedRowSet.has(idx)
          );
          if (missingRows.length > 0) {
            alert(
              `유효성 검사 실패: 주소가 있는 원본 행 ${addressRowIndices.length}개 중 ` +
                `${missingRows.length}개가 어떤 그룹에도 포함되지 않았습니다. 내보내기를 중단합니다.`
            );
            return;
          }

          // 유효성 OK
          statusEl.textContent =
            `유효성 검사 OK: 주소 행 ${addressRowIndices.length}개, ` +
            `그룹에 포함된 주소 행 ${usedRowSet.size}개. 엑셀 파일을 생성합니다.`;

          const data = [];
          const sortedGroupIds = Array.from(groupRows.keys()).sort(
            (a, b) => a - b
          );

          sortedGroupIds.forEach((gId) => {
            const rowIndices = groupRows.get(gId);
            if (!rowIndices || !rowIndices.length) return;

            const groupLabel = gId === 0 ? "미지정" : `그룹 ${gId}`;

            const addrSet = new Set();
            rowIndices.forEach((idx) => {
              const row = excelRows[idx];
              const addr = normalizeAddress(row[addrColIdx]);
              if (addr) addrSet.add(addr);
            });
            const householdCount = addrSet.size;
            const itemCount = rowIndices.length;

            rowIndices.forEach((idx) => {
              const orig = excelRows[idx] || [];
              const row = orig.slice();
              while (row.length < maxCols) row.push("");
              row.push(groupLabel);
              data.push(row);
            });

            const summaryRow = new Array(maxCols + 1).fill("");
            summaryRow[
              addrColIdx
            ] = `가구수 ${householdCount}, 품목수 ${itemCount}`;
            summaryRow[maxCols] = groupLabel;
            data.push(summaryRow);

            data.push(new Array(maxCols + 1).fill(""));
            data.push(new Array(maxCols + 1).fill(""));
          });

          const wb = XLSX.utils.book_new();
          const ws = XLSX.utils.aoa_to_sheet(data);
          XLSX.utils.book_append_sheet(wb, ws, "그룹결과");
          XLSX.writeFile(wb, "grouped_result.xlsx");
        });
    </script>
  </body>
</html>
