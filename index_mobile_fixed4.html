<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>Î∞∞Ï∞® ÏãúÏä§ÌÖú (PC Î∞∞Ï∞® / Î™®Î∞îÏùº Í∏∞ÏÇ¨)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- NAVER ÏßÄÎèÑ -->
    <script
      type="text/javascript"
      src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=ms2yp98bvf&submodules=geocoder"
    ></script>

    <!-- Excel ÏùΩÍ∏∞/Ïì∞Í∏∞ -->
    <script src="https://unpkg.com/read-excel-file@5.7.1/bundle/read-excel-file.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <style>
      :root {
        --mobile-panel-height: 42%;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #f9fafb;
        color: #111827;
        display: flex;
        flex-direction: column;
      }

      header {
        background: #3b82f6;
        color: #fff;
        padding: 10px 16px;
        font-weight: 700;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      header .file-name {
        font-size: 13px;
        opacity: 0.9;
      }

      #container {
        flex: 1;
        min-height: 0;
        display: flex;
      }

      /* Í∏∞Î≥∏: PC Î†àÏù¥ÏïÑÏõÉ */
      #map-wrapper {
        position: relative;
        flex: 2;
        min-width: 0;
      }
      #map {
        width: 100%;
        height: 100%;
      }

      #group-summary {
        position: absolute;
        left: 8px;
        right: 8px;
        top: 8px;
        z-index: 20;
        background: rgba(243, 244, 246, 0.95);
        border-radius: 16px;
        padding: 6px 8px;
        border: 1px solid #e5e7eb;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        max-height: 120px;
        overflow: auto;
      }
      .group-chip {
        font-size: 11px;
        padding: 4px 10px;
        border-radius: 999px;
        cursor: pointer;
        white-space: nowrap;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        background: #e5e7eb;
        border: 1px solid transparent;
      }
      .group-chip .color-dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
      }
      .group-chip.active {
        border-color: #111827;
        background: #dbeafe;
        font-weight: 700;
      }

      #detail {
        position: absolute;
        left: 12px;
        bottom: 12px;
        width: 340px;
        max-height: 62%;
        border-radius: 14px;
        border: 1px solid #e5e7eb;
        background: rgba(249, 250, 251, 0.97);
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.25);
        overflow: hidden;
        font-size: 12px;
        display: none;
        z-index: 15;
      }
      .detail-header {
        padding: 8px 10px;
        color: #fff;
      }
      .detail-header-title {
        font-size: 11px;
        opacity: 0.9;
      }
      .detail-header-addr {
        font-size: 13px;
        font-weight: 700;
        margin-top: 2px;
      }
      .detail-body {
        padding: 8px 10px 10px;
        background: #f9fafb;
      }
      .detail-summary {
        font-size: 11px;
        color: #4b5563;
        margin-bottom: 6px;
      }
      .detail-set-title {
        font-weight: 700;
        margin-top: 6px;
        font-size: 12px;
      }
      .detail-body ul {
        margin: 2px 0 4px 18px;
        padding: 0;
      }

      #sidebar {
        flex: 1;
        min-width: 340px;
        max-width: 480px;
        border-left: 1px solid #e5e7eb;
        background: #fff;
        display: flex;
        flex-direction: column;
      }
      #group-header-fixed {
        padding: 8px 10px 0;
      }
      #group-list {
        flex: 1;
        padding: 4px 10px 10px;
        overflow: auto;
      }
      .group-header {
        padding: 8px 10px;
        font-size: 13px;
        font-weight: 700;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-radius: 10px;
        background: #e5e7eb;
      }
      .group-header.active {
        box-shadow: inset 0 0 0 1px #111827;
        background: #e5effe;
      }
      .group-header-left {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .group-color-pill {
        width: 14px;
        height: 14px;
        border-radius: 999px;
        margin-right: 6px;
      }
      .group-body {
        padding: 6px 8px 8px;
      }

      .house-item {
        margin-top: 6px;
        padding: 6px 8px;
        background: #fff;
        border-radius: 8px;
        border: 1px solid #e5e7eb;
        font-size: 12px;
        cursor: pointer;
        display: grid;
        gap: 3px;
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.05);
        line-height: 1.35;
      }
      .house-item.active {
        border-color: #3b82f6;
        box-shadow: 0 0 0 1px #3b82f6;
      }
      .house-main {
        font-weight: 700;
        font-size: 13px;
      }
      .house-rep {
        font-size: 12px;
        color: #1d4ed8;
      }
      .house-sub {
        font-size: 11px;
        color: #6b7280;
      }
      .house-bottom {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 2px;
      }

      .desktop-phone-link {
        color: #2563eb;
        text-decoration: none;
        font-weight: 600;
        display: inline-flex;
        align-items: center;
        gap: 4px;
      }
      .desktop-phone-link::before {
        content: "üìû";
      }

      footer {
        padding: 6px 12px;
        border-top: 1px solid #e5e7eb;
        background: #f3f4f6;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 12px;
        gap: 8px;
      }
      input[type="file"] {
        display: none;
      }
      label.upload-btn {
        background: #3b82f6;
        color: #fff;
        border-radius: 6px;
        padding: 6px 10px;
        cursor: pointer;
        font-size: 12px;
      }
      button.export-btn {
        background: #10b981;
        color: #fff;
        border-radius: 6px;
        padding: 6px 10px;
        cursor: pointer;
        font-size: 12px;
        border: 0;
      }
      button.small-btn {
        background: #6b7280;
        color: #fff;
        border-radius: 6px;
        padding: 4px 8px;
        font-size: 11px;
        border: 0;
        cursor: pointer;
      }
      #truckCount {
        width: 52px;
        padding: 3px 4px;
        font-size: 11px;
      }
      #log {
        font-size: 11px;
        color: #6b7280;
        max-width: 280px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .info-card {
        font-size: 11px;
        border-radius: 10px;
        overflow: hidden;
        min-width: 260px;
        max-width: 320px;
        box-shadow: 0 8px 16px rgba(15, 23, 42, 0.25);
        background: #f9fafb;
      }
      .info-card-header {
        padding: 6px 8px;
        color: #fff;
      }
      .info-card-header-top {
        font-size: 11px;
        opacity: 0.9;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .info-card-header-title {
        font-size: 13px;
        font-weight: 700;
        margin-top: 2px;
      }
      .info-card-body {
        padding: 6px 8px 8px;
        background: #f9fafb;
      }
      .info-card-summary {
        margin-bottom: 4px;
        color: #4b5563;
      }
      .info-card-group-line {
        margin-bottom: 4px;
      }
      .link-product {
        color: #2563eb;
        text-decoration: none;
      }
      .link-product:hover {
        text-decoration: underline;
      }

      .mobile-phone-link {
        color: #2563eb;
        text-decoration: none;
        font-weight: 600;
        display: inline-flex;
        align-items: center;
        gap: 4px;
      }
      .mobile-phone-link::before {
        content: "üìû";
      }

      .desktop-only {
        display: inline-flex;
      }
      .mobile-only {
        display: none;
      }

      /* ===== Î™®Î∞îÏùº Ï†ÑÏö© ÌïòÎã® Ìå®ÎÑê ===== */
      #mobile-panel {
        display: none;
        background: #ffffff;
        border-top-left-radius: 14px;
        border-top-right-radius: 14px;
        box-shadow: 0 -6px 16px rgba(15, 23, 42, 0.18);
        flex-direction: column;
        overflow: hidden;
        z-index: 30;
      }
      #mobile-handle {
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: grab;
      }
      #mobile-handle::after {
        content: "";
        width: 40px;
        height: 4px;
        border-radius: 999px;
        background: #d1d5db;
      }
      #mobile-summary {
        padding: 4px 12px 6px;
        font-size: 11px;
        color: #4b5563;
        border-top: 1px solid #e5e7eb;
        border-bottom: 1px solid #e5e7eb;
        background: #f9fafb;
      }
      #mobile-list {
        flex: 1;
        overflow-y: auto;
        padding: 6px 10px 10px;
      }

      .mobile-house-item {
        margin-bottom: 8px;
        padding: 12px 14px;
        border-radius: 12px;
        background: #ffffff;
        border: 1px solid #e5e7eb;
        font-size: 12px;
        display: grid;
        gap: 4px;
        cursor: pointer;
        box-shadow: 0 2px 6px rgba(15, 23, 42, 0.08);
      }
      .mobile-house-item.active {
        border-color: #3b82f6;
        box-shadow: 0 0 0 1px #3b82f6;
        background: #eff6ff;
      }
      .mobile-house-main {
        font-size: 13px;
        font-weight: 700;
      }
      .mobile-house-rep {
        font-size: 12px;
        color: #1d4ed8;
      }
      .mobile-house-sub {
        font-size: 11px;
        color: #6b7280;
      }
      .mobile-house-bottom {
        margin-top: 4px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 11px;
        color: #4b5563;
      }

      /* Î∞òÏùëÌòï: Î™®Î∞îÏùºÏùº Îïå Í∏∞ÏÇ¨ Î™®Îìú Î†àÏù¥ÏïÑÏõÉ */
      @media (max-width: 768px) {
        #container {
          position: relative;
          flex-direction: column;
        }
        #sidebar,
        #detail,
        #group-summary {
          display: none;
        }
        #map-wrapper {
          position: relative;
          flex: 1 1 auto;
          min-height: 0;
        }
        #map {
          width: 100%;
          height: 100%;
        }
        #mobile-panel {
          display: flex;
          position: absolute;
          left: 0;
          right: 0;
          bottom: 0;
          height: var(--mobile-panel-height);
        }
        .desktop-only {
          display: none !important;
        }
        .mobile-only {
          display: inline-flex;
        }
        footer {
          font-size: 11px;
        }
      }
    </style>
  </head>

  <body>
    <header>
      <div>üì¶ Î∞∞Ï∞® ÏãúÏä§ÌÖú (PC Î∞∞Ï∞® / Î™®Î∞îÏùº Í∏∞ÏÇ¨)</div>
      <div class="file-name" id="file-name">ÏóëÏÖÄ ÌååÏùºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</div>
    </header>

    <div id="container">
      <div id="map-wrapper">
        <div id="map"></div>
        <div id="group-summary"></div>
        <div id="detail"></div>

        <!-- Î™®Î∞îÏùºÏö© ÌïòÎã® Ìå®ÎÑê -->
        <div id="mobile-panel">
          <div id="mobile-handle"></div>
          <div id="mobile-summary"></div>
          <div id="mobile-list"></div>
        </div>
      </div>

      <!-- PC Î∞∞Ï∞®Ïö© ÏÇ¨Ïù¥ÎìúÎ∞î -->
      <div id="sidebar">
        <div id="group-header-fixed"></div>
        <div id="group-list"></div>
      </div>
    </div>

    <footer>
      <div style="display: flex; align-items: center; gap: 8px">
        <label for="fileInput" class="upload-btn">ÏóëÏÖÄ Î∂àÎü¨Ïò§Í∏∞</label>
        <input id="fileInput" type="file" accept=".xlsx,.xls" />
        <span id="log"></span>
      </div>
      <div
        style="display: flex; align-items: center; gap: 6px"
        class="desktop-only"
      >
        <span>Ï∞®Îüâ Ïàò</span>
        <input id="truckCount" type="number" min="1" />
        <button class="small-btn" id="regroupBtn">ÏûêÎèô Í∑∏Î£π Ïû¨Î∞∞Ïπò</button>
        <button class="export-btn" id="exportBtn">ÏóëÏÖÄ ÎÇ¥Î≥¥ÎÇ¥Í∏∞</button>
      </div>
    </footer>

    <script>
      /* ===== ÏÉÅÏàò/ÏÉÅÌÉú ===== */
      const START_POINT_LAT = 37.158135;
      const START_POINT_LNG = 127.103159;
      const CBM_PRECISION = 3;

      const CITY_CENTERS = {
        PYEONGTAEK: { lat: 36.992, lng: 127.112 },
        HWASEONG: { lat: 37.199, lng: 126.833 },
        ANSEONG: { lat: 37.01, lng: 127.27 },
      };
      const OUTSKIRTS_RADIUS_KM = 10;
      const ANSEONG_MIN_FOR_SOLO = 8;
      const GROUP_TARGET_SIZE = 12;

      const GROUP_COLORS = [
        "#ef4444",
        "#3b82f6",
        "#22c55e",
        "#eab308",
        "#a855f7",
        "#f97316",
        "#06b6d4",
        "#ec4899",
        "#64748b",
        "#84cc16",
        "#0ea5e9",
        "#6366f1",
        "#14b8a6",
        "#f97373",
      ];

      let map = null;
      let isMobileMode = false;

      let headers = [];
      let originalRows = [];
      let households = [];
      let groups = [];
      let targetGroupCount = null;

      const colConfig = {
        idxAddress: 13,
        idxCBM: 10,
        idxPhone: 11,
        idxVendor: 6,
        idxVIName: 7,
        idxSKUName: 9,
        idxVINumber: 5,
      };

      const markerByHouseId = new Map();
      const infoWindow = new naver.maps.InfoWindow({
        anchorSkew: true,
        borderWidth: 0,
        backgroundColor: "transparent",
      });

      const uiState = {
        focusedGroupId: null,
        focusedHouseholdId: null,
      };

      /* ===== Í≥µÌÜµ Ïú†Ìã∏ ===== */
      function logInfo(msg) {
        console.log("INFO:", msg);
        const el = document.getElementById("log");
        if (el) el.textContent = msg;
      }
      function logError(msg, err) {
        console.error("ERROR:", msg, err || "");
        const el = document.getElementById("log");
        if (el) el.textContent = "‚ö†Ô∏è " + msg;
      }
      window.addEventListener("error", (e) =>
        logError(`Ï†ÑÏó≠ Ïò§Î•ò: ${e.message}`)
      );
      window.addEventListener("unhandledrejection", (e) =>
        logError(
          `ÎπÑÎèôÍ∏∞ Ïò§Î•ò: ${
            e.reason && e.reason.message ? e.reason.message : e.reason
          }`
        )
      );

      function isMobileWidth() {
        return window.matchMedia("(max-width: 768px)").matches;
      }

      function haversineKm(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLon = ((lon2 - lon1) * Math.PI) / 180;
        const a =
          Math.sin(dLat / 2) ** 2 +
          Math.cos((lat1 * Math.PI) / 180) *
            Math.cos((lat2 * Math.PI) / 180) *
            Math.sin(dLon / 2) ** 2;
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      }

      function normalizeAddress(raw) {
        if (!raw) return "";
        return String(raw)
          .replace(/ÎåÄÌïúÎØºÍµ≠|Republic of Korea/gi, "")
          .replace(/\s+/g, " ")
          .replace(/[(),]/g, "")
          .trim();
      }

      function escapeHtml(str) {
        return String(str)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function findHeaderIndex(names, fallback) {
        const lower = headers.map((h) => String(h).trim().toLowerCase());
        for (const n of names) {
          const idx = lower.indexOf(String(n).toLowerCase());
          if (idx !== -1) return idx;
        }
        return fallback;
      }

      function formatSetPartSummary(setCount, partCount) {
        if (partCount <= 1) return `ÏÑ∏Ìä∏ ${setCount}Í∞ú`;
        return `ÏÑ∏Ìä∏ ${setCount}Í∞ú ¬∑ Î∂ÄÌíà ${partCount}Í∞ú`;
      }

      function formatTelHref(phone) {
        if (!phone) return "";
        return "tel:" + String(phone).replace(/[^\d+]/g, "");
      }

      function makeCoupangUrlFromVendor(vendorId) {
        if (!vendorId) return "https://www.coupang.com/";
        return (
          "https://www.coupang.com/vp/products/8239520807?vendorItemId=" +
          encodeURIComponent(String(vendorId))
        );
      }

      /* ===== ÌååÏùº Ï≤òÎ¶¨ ===== */
      async function handleFile(file) {
        try {
          logInfo("ÏóëÏÖÄ ÏùΩÎäî Ï§ë...");
          const rows = await readXlsxFile(file);
          if (!rows || rows.length < 1) {
            logError("ÏóëÏÖÄÏóê Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.");
            return;
          }

          const firstRow = rows[0].map((c) =>
            c == null ? "" : String(c).trim()
          );
          const headerKeys = ["Ï£ºÏÜå", "address", "cbm", "Ï†ÑÌôî", "phone"];
          const hasHeader = firstRow.some((cell) =>
            headerKeys.some((key) =>
              cell.toLowerCase().includes(key.toLowerCase())
            )
          );

          if (hasHeader) {
            headers = firstRow;
            originalRows = rows.slice(1).map((cells, idx) => ({
              rowId: idx,
              cells: cells.map((c) => (c == null ? "" : c)),
            }));
            colConfig.idxAddress = findHeaderIndex(["Ï£ºÏÜå", "address"], 13);
            colConfig.idxCBM = findHeaderIndex(["cbm"], 10);
            colConfig.idxPhone = findHeaderIndex(
              ["Ï†ÑÌôîÎ≤àÌò∏", "phone", "tel"],
              11
            );
            colConfig.idxVendor = findHeaderIndex(
              ["vendoritemid", "vendor item id"],
              6
            );
            colConfig.idxVIName = findHeaderIndex(["vi name"], 7);
            colConfig.idxSKUName = findHeaderIndex(["sku name"], 9);
            colConfig.idxVINumber = findHeaderIndex(
              ["vi number", "vinumber", "invoice"],
              5
            );
            logInfo("Ìó§Îçî Í∞êÏßÄ: Ìó§Îçî ÌñâÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§.");
          } else {
            headers = firstRow.map((_, i) => `COL${i + 1}`);
            originalRows = rows.map((cells, idx) => ({
              rowId: idx,
              cells: cells.map((c) => (c == null ? "" : c)),
            }));
            colConfig.idxAddress = 13;
            colConfig.idxCBM = 10;
            colConfig.idxPhone = 11;
            colConfig.idxVendor = 6;
            colConfig.idxVIName = 7;
            colConfig.idxSKUName = 9;
            colConfig.idxVINumber = 5;
            logInfo("Ìó§Îçî ÏóÜÏùå: Í≥†Ï†ï Ïª¨Îüº Ïù∏Îç±Ïä§Î•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.");
          }

          logInfo("Í∞ÄÍµ¨ Îã®ÏúÑÎ°ú Î≥ÄÌôò...");
          buildHouseholds();

          logInfo("ÏßÄÏò§ÏΩîÎî©...");
          await geocodeAllHouseholds();

          logInfo("ÏßÄÏó≠ ÌÉúÍπÖ...");
          tagRegions();

          logInfo("Í∂åÏû• Í∑∏Î£π Ïàò Í≥ÑÏÇ∞...");
          computeRecommendedGroupCount();

          logInfo("ÏßÄÏó≠ Í∑úÏπô Í∏∞Î∞ò ÏûêÎèô Í∑∏Î£πÌïë...");
          autoGroupRegional();

          fitGroupCountToTarget();

          if (groups.length > 0) uiState.focusedGroupId = groups[0].id;

          logInfo(
            `Î†åÎçîÎßÅ... (Í∂åÏû• Í∑∏Î£πÏàò=${targetGroupCount}, Ïã§Ï†ú=${groups.length})`
          );
          renderAll();
          logInfo("ÏôÑÎ£å");
        } catch (e) {
          logError("ÏóëÏÖÄ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò", e);
        }
      }

      function buildHouseholds() {
        const idxAddress = colConfig.idxAddress;
        const idxCBM = colConfig.idxCBM;
        const idxPhone = colConfig.idxPhone;
        const idxVendor = colConfig.idxVendor;
        const idxVIName = colConfig.idxVIName;
        const idxSKUName = colConfig.idxSKUName;
        const idxVINumber = colConfig.idxVINumber;

        const mapByNorm = new Map();

        for (const row of originalRows) {
          const rawAddr = row.cells[idxAddress];
          const normAddr = normalizeAddress(rawAddr);
          if (!normAddr) continue;

          if (!mapByNorm.has(normAddr)) {
            mapByNorm.set(normAddr, {
              id: null,
              rawAddress: rawAddr,
              normAddress: normAddr,
              rows: [],
              sets: [],
              totalSets: 0,
              totalParts: 0,
              cbmSum: 0,
              lat: null,
              lng: null,
              distance: null,
              groupId: null,
              representLabel: "",
              orderInGroup: null,
              phone: null,
              city: "OTHER",
              isOutskirts: false,
            });
          }
          const h = mapByNorm.get(normAddr);
          h.rows.push(row);

          if (idxCBM >= 0 && idxCBM < row.cells.length) {
            const v = parseFloat(row.cells[idxCBM]);
            if (!isNaN(v)) h.cbmSum += v;
          }

          if (!h.phone && idxPhone >= 0 && idxPhone < row.cells.length) {
            const ph = row.cells[idxPhone];
            if (ph) h.phone = String(ph);
          }
        }

        households = Array.from(mapByNorm.values());
        households.forEach((h, idx) => {
          h.id = idx;

          const setMap = new Map();

          for (const row of h.rows) {
            const viNum =
              idxVINumber >= 0 && idxVINumber < row.cells.length
                ? row.cells[idxVINumber]
                : "";
            const viName =
              idxVIName >= 0 && idxVIName < row.cells.length
                ? row.cells[idxVIName]
                : "";
            const skuName =
              idxSKUName >= 0 && idxSKUName < row.cells.length
                ? row.cells[idxSKUName]
                : "";

            const key =
              (viNum && String(viNum)) ||
              (viName && "VI:" + String(viName)) ||
              (skuName && "SKU:" + String(skuName)) ||
              "ROW:" + row.rowId;

            if (!setMap.has(key)) {
              setMap.set(key, {
                key,
                viName: viName || "",
                rows: [],
                skuNames: [],
                vendorId: null,
              });
            }
            const s = setMap.get(key);
            s.rows.push(row);
            if (skuName) s.skuNames.push(String(skuName));

            if (!s.vendorId && idxVendor >= 0 && idxVendor < row.cells.length) {
              const v = row.cells[idxVendor];
              if (v) s.vendorId = v;
            }
          }

          const sets = [];
          for (const [, s] of setMap) {
            let rep;
            if (s.rows.length === 1) {
              rep =
                (idxSKUName >= 0 &&
                  s.rows[0].cells[idxSKUName] &&
                  String(s.rows[0].cells[idxSKUName])) ||
                s.viName ||
                "(ÌíàÎ™©)";
            } else {
              rep = s.viName || s.skuNames[0] || "(Ï°∞Î¶ΩÌíà)";
            }
            sets.push({
              key: s.key,
              representName: String(rep),
              rows: s.rows,
              skuCount: s.rows.length,
              vendorId: s.vendorId || null,
            });
          }

          h.sets = sets;
          h.totalSets = sets.length;
          h.totalParts = h.rows.length;

          if (sets.length === 0) {
            h.representLabel = "(ÌíàÎ™© ÏóÜÏùå)";
          } else if (sets.length === 1) {
            h.representLabel = sets[0].representName;
          } else {
            h.representLabel = `${sets[0].representName} Ïô∏ ${
              sets.length - 1
            }Í±¥`;
          }
        });
      }

      function geocodeAddress(query) {
        return new Promise((resolve) => {
          naver.maps.Service.geocode({ query }, (status, response) => {
            if (status !== naver.maps.Service.Status.OK) resolve(null);
            else resolve(response);
          });
        });
      }

      async function geocodeAllHouseholds() {
        const total = households.length;
        let done = 0;
        for (const h of households) {
          try {
            const r = await geocodeAddress(h.normAddress || h.rawAddress);
            if (r && r.v2 && r.v2.addresses && r.v2.addresses.length > 0) {
              const a = r.v2.addresses[0];
              const lat = parseFloat(a.y);
              const lng = parseFloat(a.x);
              if (!isNaN(lat) && !isNaN(lng)) {
                h.lat = lat;
                h.lng = lng;
                h.distance = haversineKm(
                  START_POINT_LAT,
                  START_POINT_LNG,
                  lat,
                  lng
                );
              }
            }
          } catch (e) {
            // Î¨¥Ïãú
          } finally {
            done++;
            logInfo(`ÏßÄÏò§ÏΩîÎî© Ï§ë... (${done}/${total})`);
          }
        }
      }

      /* ===== ÏßÄÏó≠ ÌÉúÍπÖ & Í∂åÏû• Í∑∏Î£π Ïàò ===== */
      function inferCityFromAddress(raw) {
        const s = String(raw || "");
        if (/ÏïàÏÑ±Ïãú/.test(s)) return "ANSEONG";
        if (/ÌèâÌÉùÏãú/.test(s)) return "PYEONGTAEK";
        if (/ÌôîÏÑ±Ïãú/.test(s)) return "HWASEONG";
        return "OTHER";
      }

      function tagRegions() {
        households.forEach((h) => {
          h.city = inferCityFromAddress(h.rawAddress);
          if (h.lat != null && h.lng != null) {
            const centers = CITY_CENTERS[h.city];
            if (centers) {
              const d = haversineKm(centers.lat, centers.lng, h.lat, h.lng);
              h.isOutskirts = d > OUTSKIRTS_RADIUS_KM;
            } else {
              h.isOutskirts = false;
            }
          } else {
            h.isOutskirts = false;
          }
        });
      }

      function computeRecommendedGroupCount() {
        const total = households.length;
        const anCnt = households.filter((h) => h.city === "ANSEONG").length;
        const hxOuter = households.filter(
          (h) => h.city === "HWASEONG" && h.isOutskirts
        ).length;
        const ptkOuter = households.filter(
          (h) => h.city === "PYEONGTAEK" && h.isOutskirts
        ).length;

        const anGroups = anCnt > 0 ? 1 : 0;
        const hxGroups = Math.ceil(hxOuter / GROUP_TARGET_SIZE);
        const ptkGroups = Math.ceil(ptkOuter / GROUP_TARGET_SIZE);
        const remaining = total - (anCnt + hxOuter + ptkOuter);
        const restGroups = Math.ceil(
          Math.max(0, remaining) / GROUP_TARGET_SIZE
        );

        targetGroupCount = Math.max(
          1,
          anGroups + hxGroups + ptkGroups + restGroups
        );
        const t = document.getElementById("truckCount");
        if (t) t.value = targetGroupCount;
        logInfo(`Í∂åÏû• Í∑∏Î£π Ïàò: ${targetGroupCount} (Ï¥ù ${total}Í∞ÄÍµ¨)`);
      }

      /* ===== ÏûêÎèô Í∑∏Î£πÌïë ===== */
      function autoGroupRegional() {
        groups = [];
        households.forEach((h) => {
          h.groupId = null;
          h.orderInGroup = null;
        });

        let nextGid = 1;
        const pool = new Set(households.map((h) => h.id));

        const take = (ids, gid) => {
          ids.forEach((id) => {
            const h = households.find((x) => x.id === id);
            if (!h) return;
            h.groupId = gid;
            pool.delete(id);
          });
          groups.push({ id: gid, memberIds: ids.slice() });
          nextGid++;
        };

        // 1) ÏïàÏÑ±: Îã®ÎèÖ ÎòêÎäî ÌèâÌÉù Ïù∏Í∑º Î≥¥Í∞ï
        const anseong = households
          .filter((h) => pool.has(h.id) && h.city === "ANSEONG")
          .map((h) => h.id);
        if (anseong.length > 0) {
          if (anseong.length < ANSEONG_MIN_FOR_SOLO) {
            const center = CITY_CENTERS.ANSEONG;
            const ptkNear = households
              .filter((h) => pool.has(h.id) && h.city === "PYEONGTAEK")
              .map((h) => ({
                id: h.id,
                d:
                  h.lat && h.lng
                    ? haversineKm(center.lat, center.lng, h.lat, h.lng)
                    : 9999,
              }))
              .sort((a, b) => a.d - b.d)
              .map((x) => x.id);

            while (anseong.length < GROUP_TARGET_SIZE && ptkNear.length > 0) {
              anseong.push(ptkNear.shift());
            }
          }
          take(anseong, nextGid);
        }

        // 2) ÌôîÏÑ± Ïô∏Í≥Ω
        const hxOuterIds = households
          .filter(
            (h) => pool.has(h.id) && h.city === "HWASEONG" && h.isOutskirts
          )
          .map((h) => h.id);
        if (hxOuterIds.length > 0) clusterOuter(hxOuterIds, "HWASEONG");

        // 3) ÌèâÌÉù Ïô∏Í≥Ω
        const ptkOuterIds = households
          .filter(
            (h) => pool.has(h.id) && h.city === "PYEONGTAEK" && h.isOutskirts
          )
          .map((h) => h.id);
        if (ptkOuterIds.length > 0) clusterOuter(ptkOuterIds, "PYEONGTAEK");

        // 4) ÎÇòÎ®∏ÏßÄ
        const rest = [...pool];
        if (rest.length > 0) {
          const restHs = rest
            .map((id) => households.find((h) => h.id === id))
            .sort((a, b) => (a.distance ?? 9999) - (b.distance ?? 9999));
          const unvisited = new Set(restHs.map((h) => h.id));
          while (unvisited.size > 0) {
            const seedId = unvisited.values().next().value;
            const seed = households.find((h) => h.id === seedId);
            if (!seed) break;
            const members = [seedId];
            unvisited.delete(seedId);

            const cands = [];
            for (const hid of unvisited) {
              const h = households.find((x) => x.id === hid);
              if (!h || h.lat == null) continue;
              const d = haversineKm(seed.lat, seed.lng, h.lat, h.lng);
              cands.push({ id: hid, d });
            }
            cands.sort((a, b) => a.d - b.d);
            for (const { id } of cands) {
              if (members.length >= GROUP_TARGET_SIZE) break;
              members.push(id);
              unvisited.delete(id);
            }
            take(members, nextGid);
          }
        }

        computeOrdersForAllGroups();

        function clusterOuter(idList, cityKey) {
          const centerCity = CITY_CENTERS[cityKey];
          const hs = idList.map((id) => households.find((h) => h.id === id));
          const sorted = hs
            .sort(
              (a, b) =>
                (a.lat && a.lng
                  ? haversineKm(centerCity.lat, centerCity.lng, a.lat, a.lng)
                  : 9999) -
                (b.lat && b.lng
                  ? haversineKm(centerCity.lat, centerCity.lng, b.lat, b.lng)
                  : 9999)
            )
            .reverse();

          while (sorted.length > 0) {
            const seed = sorted[0];
            const center = { lat: seed.lat, lng: seed.lng };
            const chunk = sorted.map((h) => ({
              id: h.id,
              d:
                h.lat && h.lng
                  ? haversineKm(center.lat, center.lng, h.lat, h.lng)
                  : 9999,
            }));
            chunk.sort((a, b) => a.d - b.d);
            const takeIds = chunk.slice(0, GROUP_TARGET_SIZE).map((x) => x.id);
            take(takeIds, nextGid);
            for (const rid of takeIds) {
              const idx = sorted.findIndex((x) => x.id === rid);
              if (idx > -1) sorted.splice(idx, 1);
            }
          }
        }
      }

      /* ===== Í∑∏Î£π Ïàò Î≥¥Ï†ï ===== */
      function fitGroupCountToTarget() {
        if (!targetGroupCount || targetGroupCount < 1) return;

        const nextGroupId = () =>
          (groups.length ? Math.max(...groups.map((g) => g.id)) : 0) + 1;

        const centroid = (g) => {
          const vs = g.memberIds
            .map((id) => households.find((h) => h.id === id))
            .filter((h) => h && h.lat != null);
          if (vs.length === 0) return null;
          let slat = 0;
          let slng = 0;
          vs.forEach((h) => {
            slat += h.lat;
            slng += h.lng;
          });
          return { lat: slat / vs.length, lng: slng / vs.length };
        };

        function splitLargest() {
          const sorted = [...groups].sort(
            (a, b) => b.memberIds.length - a.memberIds.length
          );
          const g = sorted.find((gg) => gg.memberIds.length > 1);
          if (!g) return false;
          const memberHs = g.memberIds
            .map((id) => households.find((h) => h.id === id))
            .filter((h) => h.lat != null && h.lng != null);
          if (memberHs.length < 2) return false;

          let s1 = memberHs[0];
          let s2 = memberHs[1];
          let maxD = 0;
          for (let i = 0; i < memberHs.length; i++) {
            for (let j = i + 1; j < memberHs.length; j++) {
              const d = haversineKm(
                memberHs[i].lat,
                memberHs[i].lng,
                memberHs[j].lat,
                memberHs[j].lng
              );
              if (d > maxD) {
                maxD = d;
                s1 = memberHs[i];
                s2 = memberHs[j];
              }
            }
          }

          const a = [];
          const b = [];
          g.memberIds.forEach((id) => {
            const h = households.find((x) => x.id === id);
            if (h.lat == null) {
              (a.length <= b.length ? a : b).push(id);
              return;
            }
            const d1 = haversineKm(h.lat, h.lng, s1.lat, s1.lng);
            const d2 = haversineKm(h.lat, h.lng, s2.lat, s2.lng);
            (d1 <= d2 ? a : b).push(id);
          });
          if (a.length === 0 || b.length === 0) return false;

          g.memberIds = a;
          const newId = nextGroupId();
          groups.push({ id: newId, memberIds: b });
          b.forEach((id) => {
            const h = households.find((x) => x.id === id);
            h.groupId = newId;
          });
          return true;
        }

        function mergeClosest() {
          if (groups.length < 2) return false;
          let pair = null;
          let minD = Infinity;

          for (let i = 0; i < groups.length; i++) {
            for (let j = i + 1; j < groups.length; j++) {
              const c1 = centroid(groups[i]);
              const c2 = centroid(groups[j]);
              if (!c1 || !c2) continue;
              const d = haversineKm(c1.lat, c1.lng, c2.lat, c2.lng);
              if (d < minD) {
                minD = d;
                pair = [i, j];
              }
            }
          }
          if (!pair) return false;
          const [i, j] = pair;
          const g1 = groups[i];
          const g2 = groups[j];
          g1.memberIds.push(...g2.memberIds);
          g2.memberIds.forEach((id) => {
            const h = households.find((x) => x.id === id);
            h.groupId = g1.id;
          });
          groups.splice(j, 1);
          return true;
        }

        let safety = 200;
        while (groups.length < targetGroupCount && safety--) {
          if (!splitLargest()) break;
        }
        while (groups.length > targetGroupCount && safety--) {
          if (!mergeClosest()) break;
        }

        groups.sort((a, b) => a.id - b.id);
        const idMap = new Map();
        groups.forEach((g, idx) => idMap.set(g.id, idx + 1));
        groups.forEach((g) => (g.id = idMap.get(g.id)));
        households.forEach((h) => (h.groupId = idMap.get(h.groupId)));

        computeOrdersForAllGroups();
      }

      /* ===== Î∞∞ÏÜ° ÏàúÏÑú Í≥ÑÏÇ∞ ===== */
      function computeOrdersForAllGroups() {
        groups.forEach((g) => computeOrderForGroup(g));
      }

      function computeOrderForGroup(g) {
        const members = g.memberIds
          .map((id) => households.find((h) => h.id === id))
          .filter(Boolean);
        members.forEach((h) => (h.orderInGroup = null));

        let clat = START_POINT_LAT;
        let clng = START_POINT_LNG;
        let order = 1;
        const withCoord = members.filter((h) => h.lat != null && h.lng != null);
        const noCoord = members.filter((h) => h.lat == null || h.lng == null);
        const unvisited = [...withCoord];

        while (unvisited.length > 0) {
          let bestIndex = 0;
          let bestDist = Infinity;
          for (let i = 0; i < unvisited.length; i++) {
            const h = unvisited[i];
            const d = haversineKm(clat, clng, h.lat, h.lng);
            if (d < bestDist) {
              bestDist = d;
              bestIndex = i;
            }
          }
          const next = unvisited.splice(bestIndex, 1)[0];
          next.orderInGroup = order++;
          clat = next.lat;
          clng = next.lng;
        }
        noCoord.forEach((h) => {
          h.orderInGroup = order++;
        });
      }

      function getDisplayOrder(h) {
        return h.orderInGroup ?? null;
      }

      /* ===== ÏßÄÎèÑ & ÎßàÏª§ ===== */
      function ensureMap() {
        if (map) return;
        map = new naver.maps.Map("map", {
          center: new naver.maps.LatLng(START_POINT_LAT, START_POINT_LNG),
          zoom: 11,
        });
        new naver.maps.Marker({
          position: new naver.maps.LatLng(START_POINT_LAT, START_POINT_LNG),
          map,
          title: "Ï∂úÎ∞úÏßÄ",
        });
        naver.maps.Event.addListener(map, "click", () => {
          infoWindow.close();
          uiState.focusedHouseholdId = null;
          renderDetail(null);
          renderGroupList();
          renderMobileList();
          updateMarkerAppearance();
        });
      }

      function getGroupColor(groupId) {
        const sorted = [...groups].sort((a, b) => a.id - b.id);
        const idx = sorted.findIndex((g) => g.id === groupId);
        if (idx === -1) return "#6b7280";
        return GROUP_COLORS[idx % GROUP_COLORS.length];
      }

      function makeMarkerIcon(groupId, opts) {
        const options = opts || {};
        const focused = !!options.focused;
        const dimmed = !!options.dimmed;
        const itemCount = options.itemCount;
        const orderNumber = options.orderNumber;

        const isMobile = !!isMobileMode;

        // PC: Í∑∏Î£π Î≤àÌò∏, Î™®Î∞îÏùº: ÌíàÎ™©(Î∂ÄÌíà) Ïàò
        let labelText = "";
        if (isMobile && typeof itemCount === "number") {
          labelText = String(itemCount);
        } else if (!isMobile && groupId != null) {
          labelText = String(groupId);
        } else if (orderNumber != null) {
          labelText = String(orderNumber);
        }

        const baseColor = isMobile ? "#3b82f6" : getGroupColor(groupId);
        const zoom =
          map && typeof map.getZoom === "function" ? map.getZoom() : 12;

        const radius = (focused ? 17 : 14) + Math.max(0, zoom - 12);
        const padding = 6;
        const diameter = radius * 2 + padding * 2;
        const cx = diameter / 2;
        const cy = diameter / 2;

        const pts = [];
        for (let i = 0; i < 8; i++) {
          const ang = (Math.PI / 4) * i - Math.PI / 2;
          const r2 = radius * 0.98;
          pts.push(`${cx + r2 * Math.cos(ang)},${cy + r2 * Math.sin(ang)}`);
        }

        const totalW = diameter;
        const totalH = diameter;

        const fillOpacity = dimmed ? 0.6 : 1.0;
        const centralTextSize = Math.max(11, 11 + (zoom - 12));

        const svg = `<svg xmlns="http://www.w3.org/2000/svg"
          width="${totalW}" height="${totalH}"
          viewBox="0 0 ${totalW} ${totalH}">
        <defs>
          <filter id="mkShadow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="1.2" stdDeviation="1.2"
              flood-color="rgba(17,24,39,0.45)"/>
          </filter>
        </defs>
        <polygon points="${pts.join(" ")}"
                 fill="${baseColor}" fill-opacity="${fillOpacity}"
                 stroke="#ffffff" stroke-width="2"
                 filter="url(#mkShadow)"/>
        <text x="${cx}" y="${cy}" text-anchor="middle"
              dominant-baseline="central"
              font-size="${centralTextSize}" font-weight="800"
              fill="#ffffff"
              style="paint-order:stroke;stroke:#000;stroke-width:.5;opacity:${
                dimmed ? 0.9 : 1
              }">${labelText}</text>
      </svg>`;

        return {
          url: "data:image/svg+xml;charset=UTF-8," + encodeURIComponent(svg),
          size: new naver.maps.Size(totalW, totalH),
          origin: new naver.maps.Point(0, 0),
          anchor: new naver.maps.Point(totalW / 2, totalH / 2),
        };
      }

      function renderMarkers() {
        ensureMap();
        markerByHouseId.forEach((mk) => mk.setMap(null));
        markerByHouseId.clear();

        households.forEach((h) => {
          if (h.lat == null || h.lng == null) return;
          const icon = makeMarkerIcon(h.groupId, {
            orderNumber: getDisplayOrder(h),
            itemCount: h.totalParts,
          });
          const mk = new naver.maps.Marker({
            position: new naver.maps.LatLng(h.lat, h.lng),
            map,
            title: h.representLabel,
            icon,
          });
          naver.maps.Event.addListener(mk, "click", () =>
            focusHousehold(h.id, {
              fromMarker: true,
              openDetail: !isMobileMode,
            })
          );
          markerByHouseId.set(h.id, mk);
        });
        updateMarkerAppearance();
        fitMapToAll();
      }

      function updateMarkerAppearance() {
        markerByHouseId.forEach((mk, id) => {
          const h = households.find((x) => x.id === id);
          if (!h) return;
          const focused = uiState.focusedHouseholdId === h.id;
          const inGroup = isMobileMode
            ? true
            : uiState.focusedGroupId != null &&
              h.groupId === uiState.focusedGroupId;
          const emphasized = focused || inGroup;

          mk.setIcon(
            makeMarkerIcon(h.groupId, {
              focused: emphasized,
              dimmed: !emphasized,
              orderNumber: getDisplayOrder(h),
              itemCount: h.totalParts,
            })
          );
        });
      }

      function fitMapToAll() {
        if (!map) return;
        const coords = households.filter((h) => h.lat != null && h.lng != null);
        if (!coords.length) return;
        const bounds = new naver.maps.LatLngBounds();
        coords.forEach((h) =>
          bounds.extend(new naver.maps.LatLng(h.lat, h.lng))
        );
        map.fitBounds(bounds);
      }

      /* ===== Í∑∏Î£π ÏöîÏïΩ(PC ÏÉÅÎã®) ===== */
      function renderGroupSummary() {
        const c = document.getElementById("group-summary");
        if (!c) return;
        if (isMobileMode) {
          c.innerHTML = "";
          return;
        }
        c.innerHTML = "";
        if (!groups.length) return;

        const sorted = [...groups].sort((a, b) => a.id - b.id);
        sorted.forEach((g) => {
          const members = g.memberIds.map((id) =>
            households.find((h) => h.id === id)
          );
          const hc = members.length;
          const ic = members.reduce((s, h) => s + h.totalParts, 0);
          const cbm = members
            .reduce((s, h) => s + h.cbmSum, 0)
            .toFixed(CBM_PRECISION);

          const chip = document.createElement("div");
          chip.className =
            "group-chip" + (uiState.focusedGroupId === g.id ? " active" : "");
          const dot = document.createElement("span");
          dot.className = "color-dot";
          dot.style.backgroundColor = getGroupColor(g.id);
          chip.appendChild(dot);
          const text = document.createElement("span");
          text.textContent = `${g.id} (${hc}Í∞ÄÍµ¨ / ÌíàÎ™© ${ic}Í∞ú / CBM ${cbm})`;
          chip.appendChild(text);
          chip.onclick = () => focusGroup(g.id);
          c.appendChild(chip);
        });
      }

      function focusGroup(gid) {
        uiState.focusedGroupId = gid;
        uiState.focusedHouseholdId = null;
        renderGroupSummary();
        renderGroupList();
        renderMobileList();
        updateMarkerAppearance();
      }

      /* ===== PC ÏÇ¨Ïù¥Îìú Î¶¨Ïä§Ìä∏ ===== */
      function renderGroupList() {
        const list = document.getElementById("group-list");
        const headerWrap = document.getElementById("group-header-fixed");
        if (!list || !headerWrap) return;

        if (isMobileMode) {
          list.innerHTML = "";
          headerWrap.innerHTML = "";
          return;
        }

        list.innerHTML = "";
        headerWrap.innerHTML = "";

        if (!groups.length) {
          list.textContent = "ÌëúÏãúÌï† Í∑∏Î£πÏù¥ ÏóÜÏäµÎãàÎã§.";
          return;
        }

        const gid = uiState.focusedGroupId || groups[0].id;
        const g = groups.find((x) => x.id === gid);
        if (!g) {
          list.textContent = "ÌëúÏãúÌï† Í∑∏Î£πÏù¥ ÏóÜÏäµÎãàÎã§.";
          return;
        }

        const members = g.memberIds
          .map((id) => households.find((h) => h.id === id))
          .slice()
          .sort(
            (a, b) => (getDisplayOrder(a) ?? 999) - (getDisplayOrder(b) ?? 999)
          );

        const hc = members.length;
        const ic = members.reduce((s, h) => s + h.totalParts, 0);
        const cbm = members
          .reduce((s, h) => s + h.cbmSum, 0)
          .toFixed(CBM_PRECISION);

        const header = document.createElement("div");
        header.className = "group-header active";
        const left = document.createElement("div");
        left.className = "group-header-left";
        const pill = document.createElement("div");
        pill.className = "group-color-pill";
        pill.style.backgroundColor = getGroupColor(g.id);
        left.appendChild(pill);
        const txt = document.createElement("span");
        txt.textContent = `Í∑∏Î£π ${g.id}`;
        left.appendChild(txt);
        header.appendChild(left);

        const right = document.createElement("div");
        right.textContent = `${hc}Í∞ÄÍµ¨ ¬∑ ÌíàÎ™© ${ic}Í∞ú ¬∑ CBM ${cbm}`;
        header.appendChild(right);

        headerWrap.appendChild(header);

        const body = document.createElement("div");
        body.className = "group-body";
        list.appendChild(body);

        members.forEach((h) => {
          const row = document.createElement("div");
          row.className =
            "house-item" +
            (uiState.focusedHouseholdId === h.id ? " active" : "");
          const order = getDisplayOrder(h);
          const main = document.createElement("div");
          main.className = "house-main";
          const orderLabel = order != null ? `ÏàúÏÑú ${order} ¬∑ ` : "";
          main.textContent = orderLabel + (h.normAddress || h.rawAddress || "");
          row.appendChild(main);

          const rep = document.createElement("div");
          rep.className = "house-rep";

          let repName = h.representLabel || "";
          let repUrl = null;
          if (h.sets && h.sets.length > 0) {
            const firstSet = h.sets[0];
            if (firstSet.representName) repName = firstSet.representName;
            if (firstSet.vendorId) {
              repUrl = makeCoupangUrlFromVendor(firstSet.vendorId);
            }
          }

          if (repUrl) {
            const a = document.createElement("a");
            a.href = repUrl;
            a.target = "_blank";
            a.rel = "noopener noreferrer";
            a.className = "link-product";
            a.textContent = repName;
            rep.appendChild(a);
          } else {
            rep.textContent = repName;
          }
          row.appendChild(rep);

          const sub = document.createElement("div");
          sub.className = "house-sub";
          sub.textContent = `${formatSetPartSummary(
            h.totalSets,
            h.totalParts
          )} ¬∑ ÌíàÎ™© ${h.totalParts}Í∞ú ¬∑ CBM ${h.cbmSum.toFixed(CBM_PRECISION)}`;
          row.appendChild(sub);

          const bottom = document.createElement("div");
          bottom.className = "house-bottom";

          const leftWrap = document.createElement("div");
          leftWrap.style.display = "flex";
          leftWrap.style.alignItems = "center";
          leftWrap.style.gap = "6px";

          if (h.phone) {
            const aTel = document.createElement("a");
            aTel.href = formatTelHref(h.phone);
            aTel.className = "desktop-phone-link";
            aTel.textContent = h.phone;
            leftWrap.appendChild(aTel);
          }

          const spanCity = document.createElement("span");
          spanCity.textContent = `${h.city}${h.isOutskirts ? " (Ïô∏Í≥Ω)" : ""}`;
          leftWrap.appendChild(spanCity);

          bottom.appendChild(leftWrap);
          row.appendChild(bottom);

          row.addEventListener("click", () => {
            focusHousehold(h.id, { fromList: true, openDetail: true });
          });

          body.appendChild(row);
        });
      }

      /* ===== PC ÏÉÅÏÑ∏ Ìå®ÎÑê & Ïù∏Ìè¨ÏúàÎèÑÏö∞ ===== */
      function makeInfoCardHTML(h) {
        if (!h) return "";
        const membersGroup = groups.find((g) => g.id === h.groupId);
        const gSize = membersGroup ? membersGroup.memberIds.length : 1;

        let setsHtml = "";
        h.sets.forEach((s) => {
          const skuCount = s.rows.length;
          const name = escapeHtml(s.representName || "");
          const vendorUrl = s.vendorId
            ? makeCoupangUrlFromVendor(s.vendorId)
            : null;
          const skuLine = `ÏÑ∏Ìä∏ ${skuCount}Í∞ú`;
          if (vendorUrl) {
            setsHtml += `<div class="detail-set-title"><a href="${vendorUrl}" target="_blank" rel="noopener noreferrer" class="link-product">${name}</a></div><div style="font-size:11px;color:#4b5563;margin-left:2px;">${skuLine}</div>`;
          } else {
            setsHtml += `<div class="detail-set-title">${name}</div><div style="font-size:11px;color:#4b5563;margin-left:2px;">${skuLine}</div>`;
          }
        });

        const headerColor = getGroupColor(h.groupId || 1);

        return `
      <div class="info-card">
        <div class="info-card-header" style="background:${headerColor}">
          <div class="info-card-header-top">
            <span>Í∑∏Î£π ${h.groupId || "-"} ¬∑ Î∞©Î¨∏ÏàúÏÑú ${
          getDisplayOrder(h) ?? "-"
        } / ${gSize}</span>
            <span>${escapeHtml(h.city)}${h.isOutskirts ? " (Ïô∏Í≥Ω)" : ""}</span>
          </div>
          <div class="info-card-header-title">
            ${escapeHtml(h.normAddress || h.rawAddress || "")}
          </div>
        </div>
        <div class="info-card-body">
          <div class="info-card-summary">
            ${formatSetPartSummary(
              h.totalSets,
              h.totalParts
            )} ¬∑ CBM ${h.cbmSum.toFixed(CBM_PRECISION)}
          </div>
          ${
            h.phone
              ? `<div style="margin-bottom:4px;"><a href="${formatTelHref(
                  h.phone
                )}" class="desktop-phone-link">${escapeHtml(h.phone)}</a></div>`
              : ""
          }
          ${setsHtml}
        </div>
      </div>`;
      }

      function renderDetail(h) {
        const box = document.getElementById("detail");
        if (!box || isMobileMode) {
          if (box) box.style.display = "none";
          return;
        }
        if (!h) {
          box.style.display = "none";
          return;
        }
        const headerColor = getGroupColor(h.groupId || 1);
        const orderLabel = getDisplayOrder(h);
        const g = groups.find((gg) => gg.id === h.groupId);
        const gSize = g ? g.memberIds.length : 1;

        let setsHtml = "";
        h.sets.forEach((s) => {
          const skuCount = s.rows.length;
          const name = escapeHtml(s.representName || "");
          const vendorUrl = s.vendorId
            ? makeCoupangUrlFromVendor(s.vendorId)
            : null;
          const skuLine = `ÏÑ∏Ìä∏ ${skuCount}Í∞ú`;
          if (vendorUrl) {
            setsHtml += `<div class="detail-set-title"><a href="${vendorUrl}" target="_blank" rel="noopener noreferrer" class="link-product">${name}</a></div><div style="font-size:11px;color:#4b5563;margin-left:2px;">${skuLine}</div>`;
          } else {
            setsHtml += `<div class="detail-set-title">${name}</div><div style="font-size:11px;color:#4b5563;margin-left:2px;">${skuLine}</div>`;
          }
        });

        box.innerHTML = `
        <div class="detail-header" style="background:${headerColor}">
          <div class="detail-header-title">
            Í∑∏Î£π ${h.groupId || "-"} ¬∑ Î∞©Î¨∏ÏàúÏÑú ${orderLabel ?? "-"} / ${gSize}
          </div>
          <div class="detail-header-addr">
            ${escapeHtml(h.normAddress || h.rawAddress || "")}
          </div>
        </div>
        <div class="detail-body">
          <div class="detail-summary">
            ${formatSetPartSummary(
              h.totalSets,
              h.totalParts
            )} ¬∑ CBM ${h.cbmSum.toFixed(CBM_PRECISION)}
          </div>
          ${
            h.phone
              ? `<div style="margin-bottom:4px;"><a href="${formatTelHref(
                  h.phone
                )}" class="desktop-phone-link">${escapeHtml(h.phone)}</a></div>`
              : ""
          }
          ${setsHtml}
        </div>
      `;
        box.style.display = "block";
      }

      /* ===== Î™®Î∞îÏùº Î¶¨Ïä§Ìä∏ ===== */
      function renderMobileList() {
        const list = document.getElementById("mobile-list");
        const summaryEl = document.getElementById("mobile-summary");
        if (!list) return;

        list.innerHTML = "";
        if (summaryEl) summaryEl.textContent = "";

        if (!households.length) {
          if (summaryEl) summaryEl.textContent = "";
          list.innerHTML =
            '<div style="padding:8px 4px;font-size:12px;color:#6b7280;">ÏóëÏÖÄ ÌååÏùºÏùÑ Î®ºÏ†Ä Î∂àÎü¨Ïò§ÏÑ∏Ïöî.</div>';
          return;
        }

        // ÏÉÅÎã® ÏöîÏïΩ: Ï†ÑÏ≤¥ Í∞ÄÍµ¨Ïàò / ÌíàÎ™©Ïàò / CBM
        if (summaryEl) {
          const totalHouse = households.length;
          const totalItems = households.reduce((s, h) => s + h.totalParts, 0);
          const totalCbm = households
            .reduce((s, h) => s + h.cbmSum, 0)
            .toFixed(CBM_PRECISION);
          summaryEl.textContent = `Ï¥ù ${totalHouse}Í∞ÄÍµ¨ ¬∑ ÌíàÎ™© ${totalItems}Í∞ú ¬∑ CBM ${totalCbm}`;
        }

        // Î∞∞ÏÜ° ÏàúÏÑú Í∏∞Ï§Ä Ï†ïÎ†¨
        const sorted = households.slice().sort((a, b) => {
          return (getDisplayOrder(a) ?? 999) - (getDisplayOrder(b) ?? 999);
        });

        sorted.forEach((h) => {
          const item = document.createElement("div");
          item.className =
            "mobile-house-item" +
            (uiState.focusedHouseholdId === h.id ? " active" : "");
          item.dataset.houseId = String(h.id);

          // Ï≤´ Ï§Ñ: "ÏàúÏÑú N ¬∑ Ï£ºÏÜå"
          const main = document.createElement("div");
          main.className = "mobile-house-main";
          const orderLabel = getDisplayOrder(h);
          const orderPrefix = orderLabel != null ? `ÏàúÏÑú ${orderLabel} ¬∑ ` : "";
          main.textContent =
            orderPrefix + (h.normAddress || h.rawAddress || "");
          item.appendChild(main);

          // Îëê Î≤àÏß∏ Ï§Ñ: üõí ÏÉÅÌíàÎ™Ö (ÎßÅÌÅ¨)
          const rep = document.createElement("div");
          rep.className = "mobile-house-rep";

          let repName = h.representLabel || "";
          let repUrl = null;
          if (h.sets && h.sets.length > 0) {
            const firstSet = h.sets[0];
            if (firstSet.representName) repName = firstSet.representName;
            if (firstSet.vendorId) {
              repUrl = makeCoupangUrlFromVendor(firstSet.vendorId);
            }
          }

          const prodText = `üõí ${repName}`;

          if (repUrl) {
            const a = document.createElement("a");
            a.href = repUrl;
            a.target = "_blank";
            a.rel = "noopener noreferrer";
            a.className = "link-product";
            a.textContent = prodText;
            rep.appendChild(a);
          } else {
            rep.textContent = prodText;
          }
          item.appendChild(rep);

          // ÏÑ∏ Î≤àÏß∏ Ï§Ñ: ÏÑ∏Ìä∏/Î∂ÄÌíà Ïàò + ÌíàÎ™© Ïàò + CBM
          const sub = document.createElement("div");
          sub.className = "mobile-house-sub";
          sub.textContent = `${formatSetPartSummary(
            h.totalSets,
            h.totalParts
          )} ¬∑ ÌíàÎ™© ${h.totalParts}Í∞ú ¬∑ CBM ${h.cbmSum.toFixed(CBM_PRECISION)}`;
          item.appendChild(sub);

          // ÎÑ§ Î≤àÏß∏ Ï§Ñ: Ï†ÑÌôî ÏïÑÏù¥ÏΩò + ÏßÄÏó≠
          const bottom = document.createElement("div");
          bottom.className = "mobile-house-bottom";

          if (h.phone) {
            const aCall = document.createElement("a");
            aCall.href = formatTelHref(h.phone);
            aCall.className = "mobile-phone-link";
            const spanText = document.createElement("span");
            spanText.textContent = h.phone;
            aCall.appendChild(spanText);
            aCall.addEventListener("click", (e) => e.stopPropagation());
            bottom.appendChild(aCall);
          }

          const right = document.createElement("span");
          let cityLabel = "";
          if (h.city === "PYEONGTAEK") cityLabel = "PYEONGTAEK";
          else if (h.city === "HWASEONG") cityLabel = "HWASEONG";
          else if (h.city === "ANSEONG") cityLabel = "ANSEONG";
          else if (h.city && typeof h.city === "string") cityLabel = h.city;
          if (cityLabel) {
            right.textContent = h.isOutskirts
              ? `${cityLabel} (Ïô∏Í≥Ω)`
              : cityLabel;
          }
          bottom.appendChild(right);

          item.addEventListener("click", () => {
            focusHousehold(h.id, { fromList: true, openDetail: false });
          });

          list.appendChild(item);
        });
      }

      function scrollMobileListToHouse(houseId) {
        if (!isMobileMode) return;
        const list = document.getElementById("mobile-list");
        if (!list) return;
        const el = list.querySelector(
          '.mobile-house-item[data-house-id="' + houseId + '"]'
        );
        if (!el) return;
        const top = el.offsetTop - 12;
        list.scrollTo({ top, behavior: "smooth" });
      }

      /* ===== Ìè¨Ïª§Ïä§ Í≥µÌÜµ ===== */
      function focusHousehold(houseId, opts) {
        const options = opts || {};
        const h = households.find((x) => x.id === houseId);
        if (!h) return;

        uiState.focusedGroupId = h.groupId;
        uiState.focusedHouseholdId = h.id;

        ensureMap();
        if (h.lat != null && h.lng != null) {
          const latlng = new naver.maps.LatLng(h.lat, h.lng);
          map.panTo(latlng);
          if (!isMobileMode) {
            const html = makeInfoCardHTML(h);
            infoWindow.setContent(html);
            infoWindow.open(map, latlng);
          }
        }

        if (!isMobileMode && options.openDetail) {
          renderDetail(h);
        } else if (isMobileMode) {
          renderDetail(null);
        }

        renderGroupSummary();
        renderGroupList();
        renderMobileList();
        updateMarkerAppearance();
        scrollMobileListToHouse(h.id);
      }

      /* ===== Ï†ÑÏ≤¥ Î†åÎçî ===== */
      function renderAll() {
        ensureMap();
        renderMarkers();
        renderGroupSummary();
        renderGroupList();
        renderMobileList();
      }

      /* ===== ÏóëÏÖÄ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ===== */
      function exportToExcel() {
        if (!households.length) {
          alert("ÎÇ¥Î≥¥ÎÇº Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.");
          return;
        }
        const wsData = [];
        const headerRow = [
          "Í∑∏Î£π",
          "Î∞©Î¨∏ÏàúÏÑú",
          "Ï£ºÏÜå",
          "ÏÑ∏Ìä∏Ïàò",
          "Î∂ÄÌíàÏàò",
          "CBM",
          "Ï†ÑÌôîÎ≤àÌò∏",
          "ÎèÑÏãú",
          "Ïô∏Í≥ΩÏó¨Î∂Ä",
        ];
        wsData.push(headerRow);

        households
          .slice()
          .sort((a, b) => (a.groupId ?? 0) - (b.groupId ?? 0))
          .forEach((h) => {
            wsData.push([
              h.groupId,
              getDisplayOrder(h),
              h.normAddress || h.rawAddress || "",
              h.totalSets,
              h.totalParts,
              Number(h.cbmSum.toFixed(CBM_PRECISION)),
              h.phone || "",
              h.city || "",
              h.isOutskirts ? "Ïô∏Í≥Ω" : "",
            ]);
          });

        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(wsData);
        XLSX.utils.book_append_sheet(wb, ws, "Î∞∞Ï∞®");
        XLSX.writeFile(wb, "dispatch_export.xlsx");
      }

      /* ===== Ï¥àÍ∏∞Ìôî ===== */
      function handleResize() {
        const newMobile = isMobileWidth();
        const changed = newMobile !== isMobileMode;
        isMobileMode = newMobile;
        if (changed) {
          renderAll();
        }
      }

      function init() {
        handleResize();

        const fi = document.getElementById("fileInput");
        if (fi) {
          fi.addEventListener("change", (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file) return;
            document.getElementById("file-name").textContent = file.name;
            handleFile(file);
          });
        }

        const regroupBtn = document.getElementById("regroupBtn");
        if (regroupBtn) {
          regroupBtn.addEventListener("click", () => {
            const tc = document.getElementById("truckCount");
            const v = tc ? Number(tc.value) : NaN;
            if (!isNaN(v) && v > 0) {
              targetGroupCount = v;
              fitGroupCountToTarget();
              renderAll();
            }
          });
        }

        const exportBtn = document.getElementById("exportBtn");
        if (exportBtn) {
          exportBtn.addEventListener("click", exportToExcel);
        }

        window.addEventListener("resize", handleResize);
      }

      document.addEventListener("DOMContentLoaded", init);
    </script>
  </body>
</html>
