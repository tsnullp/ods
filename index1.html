<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>ì£¼ì†Œ â†’ NAVER ì§€ë„ & ì—‘ì…€ ê·¸ë£¹ ë¬¶ê¸° (ìµœì¢…)</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
    />

    <script
      type="text/javascript"
      src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=ms2yp98bvf&submodules=geocoder"
    ></script>

    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <style>
      /* (ìŠ¤íƒ€ì¼ ë¶€ë¶„ì€ ì´ì „ê³¼ ë™ì¼í•©ë‹ˆë‹¤.) */
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #f3f5fb;
      }
      body {
        display: flex;
        flex-direction: column;
      }

      #app {
        flex: 1;
        display: flex;
        min-height: 0;
      }

      #sidebar {
        width: 420px;
        max-width: 100%;
        background: #f8f9ff;
        border-right: 1px solid #d4d9f0;
        display: flex;
        flex-direction: column;
        min-height: 0;
        transition: transform 0.25s ease;
        z-index: 2;
      }
      #sidebar.hidden {
        transform: translateX(-100%);
      }
      #map {
        flex: 1;
      }

      #headerBar {
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 14px;
        background: #ffffff;
        border-bottom: 1px solid #d4d9f0;
        z-index: 3;
      }
      #headerBar .title {
        font-weight: 700;
        font-size: 15px;
      }
      #headerBar button {
        border: none;
        background: #2563eb;
        color: #fff;
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 12px;
        cursor: pointer;
      }

      #sidebarInner {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 10px;
        gap: 8px;
        min-height: 0;
      }

      #settingsHeader {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 6px;
      }
      #settingsHeaderTitle {
        font-size: 13px;
        font-weight: 600;
      }
      #toggleSettingsBtn {
        border: none;
        background: #e5edff;
        color: #1e3a8a;
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 11px;
        cursor: pointer;
      }
      #naverBadge {
        border: none;
        background: #2563eb;
        color: #fff;
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 11px;
        cursor: default;
      }

      #settingsPanel {
        border-radius: 12px;
        background: #ffffff;
        padding: 8px 10px 10px;
        box-shadow: 0 4px 10px rgba(15, 23, 42, 0.06);
        font-size: 12px;
      }
      #settingsPanel.collapsed {
        display: none;
      }
      #settingsPanel ul {
        padding-left: 18px;
        margin: 4px 0 6px;
        color: #4b5563;
      }

      .row {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-top: 6px;
        flex-wrap: wrap;
      }
      label.formLabel {
        font-size: 12px;
        color: #374151;
        display: flex;
        align-items: center;
        gap: 4px;
      }
      input[type="number"],
      input[type="text"] {
        padding: 4px 6px;
        border-radius: 6px;
        border: 1px solid #cbd5f5;
        font-size: 12px;
        width: 70px;
      }
      input[type="file"] {
        font-size: 11px;
      }
      textarea {
        width: 100%;
        resize: vertical;
        min-height: 90px;
        border-radius: 8px;
        border: 1px solid #cbd5f5;
        padding: 6px;
        font-size: 12px;
      }

      button.primary {
        border: none;
        background: #2563eb;
        color: #fff;
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 12px;
        cursor: pointer;
        white-space: nowrap;
      }
      button.sub {
        border: none;
        background: #e5edff;
        color: #1e3a8a;
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 12px;
        cursor: pointer;
        white-space: nowrap;
      }
      button.danger {
        border: none;
        background: #fee2e2;
        color: #b91c1c;
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 12px;
        cursor: pointer;
        white-space: nowrap;
      }

      #statusLine {
        margin-top: 6px;
        font-size: 11px;
        color: #374151;
        line-height: 1.4;
      }

      #viewFilter {
        margin-top: 6px;
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
      }
      #viewFilter .chip {
        padding: 3px 8px;
        border-radius: 999px;
        border: 1px solid #cbd5f5;
        cursor: pointer;
        font-size: 11px;
        background: #f9fafb;
        color: #4b5563;
      }
      #viewFilter .chip.active {
        background: #2563eb;
        border-color: #2563eb;
        color: #fff;
      }

      #groupSummary {
        margin-top: 4px;
        font-size: 11px;
        color: #4b5563;
      }

      #groupListWrapper {
        flex: 1;
        min-height: 0;
        margin-top: 6px;
        overflow-y: auto;
        padding-right: 2px;
        position: relative;
      }

      .groupCard {
        background: #ffffff;
        border-radius: 12px;
        padding: 0 10px 8px;
        margin-bottom: 6px;
        border: 1px solid #e5e7f5;
        box-shadow: 0 2px 4px rgba(15, 23, 42, 0.04);
        cursor: default;
        position: relative;
      }
      .groupCard.highlight {
        box-shadow: 0 0 0 2px #2563eb33;
      }

      /* ê·¸ë£¹ í—¤ë”: ë” êµµê³  í¬ê²Œ + ë’¤ ë°°ê²½ ê°€ë¦¬ê¸° */
      .groupHeader {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 13px;
        font-weight: 700;
        padding: 8px 8px;
        border-radius: 10px;
        position: sticky;
        top: 0;
        z-index: 2;
        background: rgba(248, 250, 252, 0.97);
        box-shadow: 0 0px 4px rgba(15, 23, 42, 0.06);
      }
      .groupHeaderMain {
        display: flex;
        gap: 6px;
        align-items: center;
      }
      .groupTitle {
        font-size: 13px;
        font-weight: 700;
      }
      .groupTag {
        padding: 2px 6px;
        font-size: 10px;
        border-radius: 999px;
        border: 1px solid #cbd5f5;
        background: #f3f4ff;
        color: #4b5563;
      }
      .groupToggleIcon {
        font-size: 11px;
        transition: transform 0.15s ease;
        cursor: pointer;
      }
      .groupCard.collapsed .groupToggleIcon {
        transform: rotate(-90deg);
      }
      .groupCard.collapsed .householdItem {
        display: none;
      }

      .cbmBadge {
        padding: 2px 6px;
        border-radius: 999px;
        font-size: 10px;
        font-weight: 600;
      }
      .cbm-safe {
        background: #dcfce7;
        color: #166534;
      }
      .cbm-normal {
        background: #fef9c3;
        color: #854d0e;
      }
      .cbm-danger {
        background: #fee2e2;
        color: #b91c1c;
      }

      .householdItem {
        margin-top: 4px;
        padding-top: 4px;
        border-top: 1px dashed #e5e7eb;
        font-size: 11px;
        cursor: grab;
      }
      .householdItem.dragging {
        opacity: 0.6;
        cursor: grabbing;
      }
      .householdItem.highlight {
        background: #e0edff;
        border-radius: 6px;
      }
      .householdLine {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 4px;
      }
      .addrMain {
        font-weight: 500;
      }
      .addrSub {
        margin-top: 2px;
        color: #6b7280;
        font-size: 10px;
      }
      select.groupSelect {
        font-size: 11px;
        border-radius: 999px;
        border: 1px solid #cbd5f5;
        padding: 2px 6px;
        background: #f9fafb;
      }

      .cbmBar {
        margin-top: 3px;
        height: 4px;
        border-radius: 999px;
        background: #e5e7eb;
        overflow: hidden;
      }
      .cbmBarInner {
        height: 100%;
      }

      .itemList {
        margin-top: 3px;
        padding-left: 14px;
        color: #6b7280;
        font-size: 10px;
      }
      .itemList li {
        margin-bottom: 1px;
      }

      #toggleSidebarBtn {
        border: none;
        background: #2563eb;
        color: #fff;
        border-radius: 999px;
        padding: 6px 12px;
        font-size: 12px;
        cursor: pointer;
        position: absolute;
        top: 8px;
        right: 12px;
        z-index: 5;
      }

      @media (max-width: 900px) {
        #app {
          flex-direction: column;
        }
        #sidebar {
          width: 100%;
          border-right: none;
          border-bottom: 1px solid #d4d9f0;
        }
        #sidebar.hidden {
          transform: translateY(-100%);
        }
        #map {
          height: 60%;
        }
        #toggleSidebarBtn {
          right: 8px;
        }
      }
    </style>
  </head>
  <body>
    <div id="headerBar">
      <div class="title">ì£¼ì†Œ â†’ ì§€ë„ & ê·¸ë£¹ ë¬¶ê¸°</div>
      <button id="toggleSidebarBtn">ì§€ë„ë§Œ ë³´ê¸°</button>
    </div>

    <div id="app">
      <div id="sidebar">
        <div id="sidebarInner">
          <div id="settingsHeader">
            <div id="settingsHeaderTitle">ì„¤ì • í¼ì¹˜ê¸° / ì ‘ê¸°</div>
            <div style="display: flex; gap: 4px; align-items: center">
              <button id="toggleSettingsBtn">ì ‘ê¸°</button>
              <button id="naverBadge">NAVER ì§€ë„ + ì—‘ì…€</button>
            </div>
          </div>

          <div id="settingsPanel">
            <ul>
              <li>
                <b>ìµœëŒ€ ê°€êµ¬ ìˆ˜</b>ëŠ” ëª©í‘œì¹˜ì…ë‹ˆë‹¤. ë¶€ì¡±í•˜ë©´
                <b>ì¶œë°œì  ê°€ê¹Œìš´ ê·¸ë£¹ë¶€í„°</b> ì´ˆê³¼ë  ìˆ˜ ìˆì–´ìš”.
              </li>
              <li>
                <b>ê·¸ë£¹ ìˆ˜</b>ëŠ” ì´ì œ
                <span style="font-weight: 600">ìë™ ì¶”ì²œê°’</span>ìœ¼ë¡œ
                ì„¤ì •ë©ë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
              </li>
              <li>ì—‘ì…€ ì£¼ì†Œ/í’ˆëª©/CBM ì—´ì€ ë²ˆí˜¸ë¥¼ ë°”ê¾¸ë©´ ì¦‰ì‹œ ë°˜ì˜ë¼ìš”.</li>
              <li>
                ì£¼ì†Œ/ê·¸ë£¹/ì§€ì˜¤ì½”ë”© ê²°ê³¼ëŠ” ë¸Œë¼ìš°ì €
                <b>localStorage</b>ì— ì €ì¥ë©ë‹ˆë‹¤.
              </li>
            </ul>

            <div class="row">
              <label class="formLabel">
                ì—‘ì…€ íŒŒì¼
                <input type="file" id="excelInput" />
              </label>
            </div>

            <div class="row">
              <label class="formLabel">
                ì£¼ì†Œì—´
                <input type="number" id="addrColInput" value="14" min="1" />
              </label>
              <label class="formLabel">
                í’ˆëª©ì—´
                <input type="number" id="itemColInput" value="10" min="1" />
              </label>
              <label class="formLabel">
                CBMì—´
                <input type="number" id="cbmColInput" value="11" min="1" />
              </label>
            </div>

            <textarea
              id="addrInput"
              placeholder="ë„ë¡œëª… ì£¼ì†Œë¥¼ í•œ ì¤„ì— í•˜ë‚˜ì”© ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.&#10;ì—‘ì…€ì„ ë¶ˆëŸ¬ì˜¤ë©´ ì—¬ê¸°ì—ë„ ì£¼ì†Œê°€ ìë™ìœ¼ë¡œ ë“¤ì–´ê°‘ë‹ˆë‹¤."
            ></textarea>

            <div class="row">
              <label class="formLabel">
                ìµœëŒ€ ê°€êµ¬ ìˆ˜
                <input type="number" id="maxGroupSize" value="12" min="1" />
              </label>
              <label class="formLabel">
                ê·¸ë£¹ ìˆ˜ (ìë™ ì¶”ì²œ)
                <input type="number" id="numGroupsInput" value="" min="1" />
              </label>
            </div>

            <div class="row">
              <button class="primary" id="geocodeBtn">
                1ë‹¨ê³„: ì£¼ì†Œ ì§€ì˜¤ì½”ë”©
              </button>
              <button class="sub" id="groupBtn">
                2ë‹¨ê³„: ì¡°ê±´ìœ¼ë¡œ ê·¸ë£¹ ë¬¶ê¸°
              </button>
              <button class="danger" id="resetListBtn">í˜„ì¬ ëª©ë¡ ì´ˆê¸°í™”</button>
            </div>

            <div class="row">
              <button class="sub" id="exportBtn">ì—‘ì…€ë¡œ ë‚´ë³´ë‚´ê¸°</button>
            </div>

            <div id="statusLine"></div>

            <div id="viewFilter">
              <span>ë³´ê¸°:</span>
              <span class="chip active" data-view="all">ëª¨ë‘</span>
              <span class="chip" data-view="grouped">ê·¸ë£¹ë§Œ</span>
              <span class="chip" data-view="unassigned">ë¯¸ì§€ì •ë§Œ</span>
            </div>

            <div id="groupSummary"></div>
          </div>

          <div id="groupListWrapper"></div>
        </div>
      </div>

      <div id="map"></div>
    </div>

    <script>
      // -----------------------------------------------------------
      // ì „ì—­ ë³€ìˆ˜ ë° ì´ˆê¸° ì„¤ì •
      // -----------------------------------------------------------

      // NAVER ì§€ë„ ìƒì˜ ì¶œë°œì  (ì•ˆì„±ì‹œ ì¼ëŒ€ë¡œ ì„ì‹œ ì„¤ì •)
      const START_POINT = new naver.maps.LatLng(37.158135, 127.103159);
      const LOCAL_CACHE_KEY = "addrCache_v1";
      const LOCAL_STATE_KEY = "groupState_v1";
      const LOCAL_COLLAPSE_KEY = "groupCollapseState_v1";

      let map;
      let infoWindow;
      let markers = [];
      let points = [];
      let geocodeCache = {};
      let currentViewFilter = "all";
      let draggingIdx = null;

      let collapsedGroups = {};

      // ğŸ¨ [ì—…ë°ì´íŠ¸] ê·¸ë£¹ ìƒ‰ìƒ íŒ”ë ˆíŠ¸ í™•ì¥ (ì´ 30ê°œ)
      const groupColors = [
        "#E74C3C", // Red
        "#3498DB", // Blue
        "#2ECC71", // Green
        "#F39C12", // Orange
        "#9B59B6", // Purple
        "#1ABC9C", // Turquoise
        "#F1C40F", // Yellow
        "#E67E22", // Dark Orange
        "#34495E", // Dark Blue/Grey
        "#95A5A6", // Grey-Blue

        "#C0392B", // Dark Red
        "#2980B9", // Dark Blue
        "#27AE60", // Dark Green
        "#D35400", // Rust
        "#8E44AD", // Dark Purple
        "#16A085", // Dark Turquoise
        "#FAD7A0", // Light Gold
        "#4A235A", // Deep Purple

        "#5DADE2", // Light Blue
        "#58D68D", // Mint Green
        "#F5B041", // Gold
        "#E93B81", // Pink-Red
        "#76448A", // Medium Purple
        "#48C9B0", // Light Teal
        "#DC7633", // Brown-Orange
        "#BA4A00", // Deep Brown

        "#BB8FCE", // Light Purple
        "#AED6F1", // Very Light Blue
        "#F8C471", // Light Orange
        "#207040", // Forest Green
      ];

      const statusEl = document.getElementById("statusLine");
      const groupSummaryEl = document.getElementById("groupSummary");
      const groupListWrapper = document.getElementById("groupListWrapper");
      const maxGroupInput = document.getElementById("maxGroupSize");
      const numGroupsInput = document.getElementById("numGroupsInput");
      const addrTextarea = document.getElementById("addrInput");
      const excelInput = document.getElementById("excelInput");
      const addrColInput = document.getElementById("addrColInput");
      const itemColInput = document.getElementById("itemColInput");
      const cbmColInput = document.getElementById("cbmColInput");

      function initMap() {
        map = new naver.maps.Map("map", {
          center: START_POINT,
          zoom: 9,
        });

        infoWindow = new naver.maps.InfoWindow({
          anchorSize: new naver.maps.Size(16, 16),
        });
        naver.maps.Event.addListener(map, "click", () => infoWindow.close());

        // ì¶œë°œì  ë§ˆì»¤
        new naver.maps.Marker({
          position: START_POINT,
          map,
          icon: {
            content:
              '<div style="width:22px;height:22px;border-radius:50%;background:#f97316;border:2px solid #fff;box-shadow:0 0 4px rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;color:#fff;font-size:11px;font-weight:700;">S</div>',
            size: new naver.maps.Size(22, 22),
            anchor: new naver.maps.Point(11, 11),
          },
          title: "ì¶œë°œì ",
        });

        loadCache();
        loadState();
        loadCollapseState();
        updateRecommendedGroups();
        updateFilterChips();
        updateGroupSummaryAndList();
      }

      if (window.naver && naver.maps) {
        naver.maps.onJSContentLoaded = initMap;
      } else {
        window.addEventListener("load", initMap);
      }

      // -----------------------------------------------------------
      // LocalStorage ìºì‹œ/ìƒíƒœ ê´€ë¦¬
      // -----------------------------------------------------------

      function loadCache() {
        try {
          const raw = localStorage.getItem(LOCAL_CACHE_KEY);
          if (raw) geocodeCache = JSON.parse(raw);
        } catch {}
      }
      function saveCache() {
        try {
          localStorage.setItem(LOCAL_CACHE_KEY, JSON.stringify(geocodeCache));
        } catch {}
      }
      function loadState() {
        try {
          const raw = localStorage.getItem(LOCAL_STATE_KEY);
          if (!raw) return;
          const state = JSON.parse(raw);
          if (!Array.isArray(state.points)) return;
          points = state.points.map((p) => ({
            original: p.original || "",
            used: p.used || null,
            lat: typeof p.lat === "number" ? p.lat : null,
            lng: typeof p.lng === "number" ? p.lng : null,
            failed: !!p.failed,
            items: Array.isArray(p.items) ? p.items : [],
            cbmTotal: typeof p.cbmTotal === "number" ? p.cbmTotal : 0,
            groupIndex:
              typeof p.groupIndex === "number" && p.groupIndex >= 0
                ? p.groupIndex
                : null,
          }));
          renderMarkers();
        } catch {}
      }
      function saveState() {
        try {
          localStorage.setItem(
            LOCAL_STATE_KEY,
            JSON.stringify({ points: points })
          );
        } catch {}
      }

      function loadCollapseState() {
        try {
          const raw = localStorage.getItem(LOCAL_COLLAPSE_KEY);
          if (raw) {
            collapsedGroups = JSON.parse(raw);
          } else {
            collapsedGroups = {
              g_unassigned: true,
              g_failed: true,
            };
          }
        } catch {
          collapsedGroups = {
            g_unassigned: true,
            g_failed: true,
          };
        }
      }
      function saveCollapseState() {
        try {
          localStorage.setItem(
            LOCAL_COLLAPSE_KEY,
            JSON.stringify(collapsedGroups)
          );
        } catch {}
      }

      // -----------------------------------------------------------
      // ê·¸ë£¹í•‘ í•µì‹¬ ë¡œì§ (ê°•ì œ ê·¸ë£¹ ë° K-means)
      // -----------------------------------------------------------

      /**
       * ì£¼ì†Œì—ì„œ 'OOì‹œ'ì™€ ê°™ì€ ë„ì‹œëª…ì„ ì¶”ì¶œí•©ë‹ˆë‹¤.
       */
      function getCityFromAddress(addr) {
        if (!addr) return "UNKNOWN";
        const tokens = addr.split(" ").filter(Boolean);
        if (tokens.length > 0 && tokens[0].endsWith("ì‹œ")) {
          return tokens[0];
        }
        if (tokens.length > 0 && tokens[0].endsWith("ë„")) return tokens[0];
        if (tokens.length > 0 && tokens[0].endsWith("íŠ¹ë³„ì‹œ")) return tokens[0];
        if (tokens.length > 0 && tokens[0].endsWith("ê´‘ì—­ì‹œ")) return tokens[0];
        if (tokens.length > 0 && tokens[0].endsWith("ìì°¨ì‹œ")) return tokens[0];
        if (tokens.length > 0 && tokens[0].endsWith("ìì°¨ë„")) return tokens[0];
        return "UNKNOWN";
      }

      /**
       * ì§€ë¦¬ì  ê±°ë¦¬ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤. (km)
       */
      function distanceKmPoint(p1, p2) {
        const R = 6371.0088;
        const lat1 = (p1.lat * Math.PI) / 180;
        const lat2 = (p2.lat * Math.PI) / 180;
        const dLat = lat2 - lat1;
        const dLon = ((p2.lng - p1.lng) * Math.PI) / 180;
        const a =
          Math.sin(dLat / 2) ** 2 +
          Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      /**
       * ìˆœìˆ˜ ì§€ë¦¬ì  ê±°ë¦¬ ê¸°ë°˜ K-means 1íšŒ ì‹¤í–‰
       */
      function runKMeansPureDistance(
        initialPoints,
        k,
        iter = 20,
        initialCentroids = null
      ) {
        const n = initialPoints.length;
        if (k > n) k = n;

        // ì´ˆê¸° ì¤‘ì‹¬ì  ì„¤ì • (ëœë¤)
        let centroids = initialCentroids || [];
        if (centroids.length < k) {
          const indices = Array.from({ length: n }, (_, i) => i);
          for (let i = n - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [indices[i], indices[j]] = [indices[j], indices[i]];
          }
          for (let i = centroids.length; i < k; i++) {
            const p = initialPoints[indices[i]];
            centroids.push({ lat: p.lat, lng: p.lng });
          }
        }

        let assignments = new Array(n).fill(-1);

        for (let t = 0; t < iter; t++) {
          // Assignment Step
          let changed = false;
          for (let i = 0; i < n; i++) {
            let best = -1;
            let bestDist = Infinity;
            for (let c = 0; c < k; c++) {
              const d = distanceKmPoint(initialPoints[i], centroids[c]);
              if (d < bestDist) {
                bestDist = d;
                best = c;
              }
            }
            if (assignments[i] !== best) {
              assignments[i] = best;
              changed = true;
            }
          }
          if (!changed) break;

          // Update Centroids Step
          const sumLat = new Array(k).fill(0);
          const sumLng = new Array(k).fill(0);
          const cnt = new Array(k).fill(0);
          for (let i = 0; i < n; i++) {
            const g = assignments[i];
            if (g >= 0) {
              sumLat[g] += initialPoints[i].lat;
              sumLng[g] += initialPoints[i].lng;
              cnt[g] += 1;
            }
          }
          for (let c = 0; c < k; c++) {
            if (cnt[c] > 0) {
              centroids[c] = {
                lat: sumLat[c] / cnt[c],
                lng: sumLng[c] / cnt[c],
              };
            } else {
              // ë¹ˆ ê·¸ë£¹ ì¬ì´ˆê¸°í™” ë¡œì§ (ê°€ì¥ ë©€ë¦¬ ë–¨ì–´ì§„ í¬ì¸íŠ¸ë¡œ ì¬í• ë‹¹ ì‹œë„)
              let maxDist = -1;
              let farthestPoint = null;
              const referenceCentroid = centroids[(c + 1) % k] || START_POINT;

              initialPoints.forEach((p, pIdx) => {
                const isAssignedToOther =
                  assignments[pIdx] !== -1 && cnt[assignments[pIdx]] > 1;
                if (!isAssignedToOther) {
                  const dist = distanceKmPoint(p, referenceCentroid);
                  if (dist > maxDist) {
                    maxDist = dist;
                    farthestPoint = p;
                  }
                }
              });
              if (farthestPoint) {
                centroids[c] = {
                  lat: farthestPoint.lat,
                  lng: farthestPoint.lng,
                };
              } else {
                centroids[c] = { lat: START_POINT.y, lng: START_POINT.x };
              }
            }
          }
        }

        return { assignments, centroids };
      }

      function groupWithConstraints(maxSize, numGroups) {
        const ANSEONG_CITY = "ì•ˆì„±ì‹œ";
        // ì•ˆì„±ì‹œ ê·¸ë£¹ì„ ìœ„í•œ ì„ì‹œ ê·¸ë£¹ ì¸ë±ìŠ¤ (K-means ê²°ê³¼ì™€ ê²¹ì¹˜ì§€ ì•Šë„ë¡ ì„ì˜ì˜ ë†’ì€ ìˆ˜)
        const ANSEONG_TEMP_GROUP = 9999;
        const MAX_ITER = 5;

        const allValidPoints = [];
        points.forEach((p, idx) => {
          if (
            !p.failed &&
            typeof p.lat === "number" &&
            typeof p.lng === "number"
          ) {
            allValidPoints.push({
              idx: idx,
              lat: p.lat,
              lng: p.lng,
              city: getCityFromAddress(p.original),
              originalIndex: idx,
            });
          }
        });

        const n = allValidPoints.length;
        if (n === 0) return null;

        if (!maxSize || maxSize <= 0) maxSize = n;
        if (!numGroups || numGroups <= 0) numGroups = 1;

        const minGroups = Math.ceil(n / maxSize);
        statusEl.textContent = `ì „ì²´ ${n}ê°€êµ¬ / ìµœëŒ€ ${maxSize}ê°€êµ¬ ê¸°ì¤€ ì´ë¡ ìƒ ìµœì†Œ ê·¸ë£¹ ìˆ˜: ${minGroups}ê°œ`;

        const assignments = new Array(n).fill(-1);

        // 1. [í•µì‹¬] ì•ˆì„±ì‹œ ì£¼ì†Œ ê°•ì œ ì „ì²˜ë¦¬
        const anseongPoints = [];
        const otherPoints = [];

        allValidPoints.forEach((p, i) => {
          if (p.city === ANSEONG_CITY) {
            anseongPoints.push(i);
          } else {
            otherPoints.push(i);
          }
        });

        // ì•ˆì„± ì£¼ì†Œê°€ ìˆìœ¼ë©´, ì„ì‹œ ê·¸ë£¹ ì¸ë±ìŠ¤ë¡œ ê°•ì œ í• ë‹¹
        let anseongGroupAssigned = false;
        if (anseongPoints.length > 0) {
          anseongPoints.forEach((i) => (assignments[i] = ANSEONG_TEMP_GROUP));
          anseongGroupAssigned = true;
        }

        // 2. ì•ˆì„±ì„ ì œì™¸í•œ ë‚˜ë¨¸ì§€ ì£¼ì†Œì— K-means ì ìš©
        const numAnseong = anseongGroupAssigned ? 1 : 0;
        const numOtherGroups = numGroups - numAnseong;

        if (otherPoints.length > 0 && numOtherGroups > 0) {
          const otherPointsData = otherPoints.map((i) => allValidPoints[i]);
          // K-meansë¥¼ 0ë¶€í„° numOtherGroups-1 ë²”ìœ„ë¡œ ì‹¤í–‰
          const { assignments: kmAssignments } = runKMeansPureDistance(
            otherPointsData,
            numOtherGroups
          );

          // K-means ê²°ê³¼ë¥¼ ì›ë˜ assignments ë°°ì—´ì— ë°˜ì˜ (0ë¶€í„° ì‹œì‘)
          kmAssignments.forEach((g, i) => {
            if (g !== -1) {
              const originalIndex = otherPoints[i];
              assignments[originalIndex] = g;
            }
          });
        }

        // ë³´ì¡° í•¨ìˆ˜ ì •ì˜
        const getGroupedPoints = () => {
          const result = {};
          assignments.forEach((g, i) => {
            if (g >= 0) {
              if (!result[g]) result[g] = [];
              result[g].push(i);
            }
          });
          return result;
        };

        const calculateCentroids = (groups) => {
          const centroids = {};
          for (const g in groups) {
            const arr = groups[g];
            if (arr.length > 0) {
              let sLat = 0,
                sLng = 0;
              arr.forEach((i) => {
                sLat += allValidPoints[i].lat;
                sLng += allValidPoints[i].lng;
              });
              centroids[g] = { lat: sLat / arr.length, lng: sLng / arr.length };
            }
          }
          return centroids;
        };

        // 3. ê·¸ë£¹ í¬ê¸° ì œì•½ í•´ê²° (Iterative Refinement)
        let loop = 0;
        while (loop < MAX_ITER) {
          let currentGroups = getGroupedPoints();
          const centroids = calculateCentroids(currentGroups);
          let movedCount = 0;

          for (const g in currentGroups) {
            const groupIndex = parseInt(g, 10);
            const groupMembers = currentGroups[groupIndex];

            if (groupIndex === ANSEONG_TEMP_GROUP && anseongGroupAssigned)
              continue;

            if (groupMembers.length > maxSize) {
              const membersWithDist = groupMembers
                .map((i) => {
                  const p = allValidPoints[i];
                  return {
                    indexInValidPoints: i,
                    distance: distanceKmPoint(p, centroids[groupIndex]),
                  };
                })
                .sort((a, b) => b.distance - a.distance);

              const excessCount = groupMembers.length - maxSize;

              for (let k = 0; k < excessCount; k++) {
                const { indexInValidPoints: i } = membersWithDist[k];
                const p = allValidPoints[i];

                let bestTargetGroup = -1;
                let minDistance = Infinity;

                for (const targetG in centroids) {
                  const targetIndex = parseInt(targetG, 10);

                  if (targetIndex === groupIndex) continue;

                  if (
                    targetIndex === ANSEONG_TEMP_GROUP &&
                    p.city !== ANSEONG_CITY
                  )
                    continue;

                  const d = distanceKmPoint(p, centroids[targetIndex]);

                  if (currentGroups[targetIndex].length < maxSize) {
                    if (d < minDistance) {
                      minDistance = d;
                      bestTargetGroup = targetIndex;
                    }
                  }
                }

                if (bestTargetGroup !== -1 && bestTargetGroup !== groupIndex) {
                  assignments[i] = bestTargetGroup;
                  movedCount++;
                }
              }
            }
          }

          if (movedCount === 0) break;
          loop++;
        }

        // 4. [í•µì‹¬] ìµœì¢… ê·¸ë£¹ ë²ˆí˜¸ ë§¤ê¸°ê¸° (ì¶œë°œì  ê¸°ì¤€ìœ¼ë¡œ ìˆœì„œ ì •ë ¬)
        const finalGroups = getGroupedPoints();
        const centroids = calculateCentroids(finalGroups);
        const groupIndices = Object.keys(finalGroups).map((g) =>
          parseInt(g, 10)
        );

        // ëª¨ë“  ê·¸ë£¹ì„ ì¶œë°œì  ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ (ê°€ì¥ ê°€ê¹Œìš´ ê·¸ë£¹ì´ ë§¨ ì•ìœ¼ë¡œ ì˜¤ë„ë¡)
        groupIndices.sort((a, b) => {
          if (!centroids[a] || !centroids[b]) return 0;

          const da = distanceKmPoint(centroids[a], {
            lat: START_POINT.y,
            lng: START_POINT.x,
          });
          const db = distanceKmPoint(centroids[b], {
            lat: START_POINT.y,
            lng: START_POINT.x,
          });
          return da - db;
        });

        // ìƒˆ ê·¸ë£¹ ë²ˆí˜¸ ë§¤í•‘ (0, 1, 2...ë¡œ ìˆœì°¨ì  ë¶€ì—¬)
        const remap = {};
        let nextGroupNum = 0;

        groupIndices.forEach((g) => {
          if (finalGroups[g].length > 0) {
            remap[g] = nextGroupNum++; // ê°€ì¥ ê°€ê¹Œìš´ ê·¸ë£¹ì´ 0ë²ˆ(ê·¸ë£¹ 1ë²ˆ)
          }
        });

        // 5. points ë°°ì—´ì— ìµœì¢… ê·¸ë£¹ ì¸ë±ìŠ¤ ë°˜ì˜ (0ì´ ê·¸ë£¹ 1ë²ˆ, 1ì´ ê·¸ë£¹ 2ë²ˆ...)
        points.forEach((p, i) => {
          p.groupIndex = null;
        });

        allValidPoints.forEach((info, i) => {
          const srcGroup = assignments[i];
          // remap[srcGroup]ì€ 0ë¶€í„° ì‹œì‘í•˜ëŠ” ìµœì¢… ê·¸ë£¹ ì¸ë±ìŠ¤
          if (srcGroup != null && srcGroup >= 0 && remap[srcGroup] != null) {
            points[info.originalIndex].groupIndex = remap[srcGroup];
          } else {
            // ë¦¬ë§µí•‘ë˜ì§€ ì•Šì€ ìœ íš¨ í¬ì¸íŠ¸ëŠ” ë¯¸ì§€ì • ì²˜ë¦¬
            points[info.originalIndex].groupIndex = null;
          }
        });

        saveState();
        return assignments;
      }

      // -----------------------------------------------------------
      // ë³´ì¡° í•¨ìˆ˜
      // -----------------------------------------------------------

      function normalizeAddress(str) {
        if (!str) return "";
        return str.trim().replace(/\s+/g, " ");
      }

      function cbmStatusTag(cbm) {
        if (cbm == null || isNaN(cbm)) return { text: "-", cls: "" };
        if (cbm < 7)
          return { text: cbm.toFixed(1) + " CBM (ì•ˆì „)", cls: "cbm-safe" };
        if (cbm <= 8)
          return { text: cbm.toFixed(1) + " CBM (ì ì •)", cls: "cbm-normal" };
        return { text: cbm.toFixed(1) + " CBM (ìœ„í—˜)", cls: "cbm-danger" };
      }

      function getMaxGroupIndex() {
        let maxG = -1;
        points.forEach((p) => {
          if (p.groupIndex != null && p.groupIndex >= 0) {
            if (p.groupIndex > maxG) maxG = p.groupIndex;
          }
        });
        return maxG;
      }

      function updateFilterChips() {
        document.querySelectorAll("#viewFilter .chip").forEach((chip) => {
          chip.classList.toggle(
            "active",
            chip.getAttribute("data-view") === currentViewFilter
          );
        });
      }

      // -----------------------------------------------------------
      // ì—‘ì…€/ë°ì´í„° ì²˜ë¦¬
      // -----------------------------------------------------------

      // ì—‘ì…€ ì½ê¸°
      excelInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (ev) => {
          const data = new Uint8Array(ev.target.result);
          const workbook = XLSX.read(data, { type: "array" });
          const sheetName = workbook.SheetNames[0];
          const sheet = workbook.Sheets[sheetName];
          const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });

          const addrCol = parseInt(addrColInput.value, 10) - 1;
          const itemCol = parseInt(itemColInput.value, 10) - 1;
          const cbmCol = parseInt(cbmColInput.value, 10) - 1;

          const addrMap = new Map();
          const pointsTemp = [];

          for (let r = 0; r < rows.length; r++) {
            const row = rows[r];
            if (!row) continue;
            const addr = normalizeAddress(row[addrCol] || "");
            if (!addr) continue;

            const item = String(row[itemCol] || "").trim();
            const cbmVal = parseFloat(row[cbmCol]);
            const cbm = isNaN(cbmVal) ? 0 : cbmVal;

            let idx = addrMap.get(addr);
            if (idx == null) {
              idx = pointsTemp.length;
              addrMap.set(addr, idx);
              pointsTemp.push({
                original: addr,
                used: null,
                lat: null,
                lng: null,
                failed: false,
                items: [],
                cbmTotal: 0,
                groupIndex: null,
              });
            }
            const p = pointsTemp[idx];
            p.items.push({ name: item, cbm });
            p.cbmTotal += cbm;
          }

          points = pointsTemp;
          saveState();

          addrTextarea.value = points
            .map((p) => p.original)
            .filter(Boolean)
            .join("\n");

          statusEl.textContent = `ì—‘ì…€ì—ì„œ ê°€êµ¬ ${
            points.length
          }ê°œë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤. (í’ˆëª© ìˆ˜: ${points.reduce(
            (s, p) => s + p.items.length,
            0
          )}ê°œ)`;
          renderMarkers();
          updateRecommendedGroups();
          updateGroupSummaryAndList();
        };
        reader.readAsArrayBuffer(file);
      });

      // ì§€ì˜¤ì½”ë”© ë¡œì§ (ì´ì „ê³¼ ë™ì¼)
      function geocodeNaver(query) {
        return new Promise((resolve) => {
          if (!query) {
            resolve(null);
            return;
          }
          naver.maps.Service.geocode({ query }, (status, response) => {
            if (status !== naver.maps.Service.Status.OK) {
              resolve(null);
              return;
            }
            const result = response.v2.addresses && response.v2.addresses[0];
            if (!result) {
              resolve(null);
              return;
            }
            const lng = parseFloat(result.x);
            const lat = parseFloat(result.y);
            if (isNaN(lat) || isNaN(lng)) {
              resolve(null);
            } else {
              resolve({ lat, lng });
            }
          });
        });
      }

      function simplifyKoreanAddress(addr) {
        if (!addr) return "";
        let s = addr.replace(/\(.*?\)/g, " ");
        s = s.replace(/\s+/g, " ").trim();
        const tokens = s.split(" ");
        let cutIndex = -1;
        for (let i = 0; i < tokens.length - 1; i++) {
          const t = tokens[i];
          const next = tokens[i + 1];
          if (/[ë¡œê¸¸]$/.test(t) && /^[0-9\-]+$/.test(next)) {
            cutIndex = i + 1;
          }
        }
        if (cutIndex !== -1) {
          return tokens
            .slice(0, cutIndex + 1)
            .join(" ")
            .trim();
        }
        return s;
      }

      function extractJibeon(addr) {
        const m = addr.match(/\(([^)]+)\)/);
        if (!m) return null;
        const inner = m[1];
        const firstPart = inner.split(",")[0];
        const parts = firstPart.split(/\s+/).filter(Boolean);
        if (parts.length >= 2) return parts.slice(0, 2).join(" ");
        return firstPart.trim();
      }

      function buildCandidates(originalAddr) {
        const candidates = [];
        const seen = new Set();
        const add = (s) => {
          if (!s) return;
          const n = normalizeAddress(s);
          if (!n || seen.has(n)) return;
          seen.add(n);
          candidates.push(n);
        };

        add(originalAddr);
        const simplified = simplifyKoreanAddress(originalAddr);
        add(simplified);

        const base = simplified || originalAddr;
        if (base) {
          const t = base.split(" ").filter(Boolean);
          if (t.length >= 2) {
            if (/^ê²½ê¸°(ë„)?$/.test(t[0])) {
              add(t.slice(1).join(" "));
            }
            const cityIdx = t.findIndex((x) => x.endsWith("ì‹œ"));
            if (cityIdx >= 0) {
              const city = t[cityIdx];
              const afterCity = t.slice(cityIdx + 1);
              if (afterCity.length >= 2) {
                add(city + " " + afterCity.join(" "));
                const roadNum = afterCity.slice(-2).join(" ");
                add(roadNum);
              }
            }
            const roadNum2 = t.slice(-2).join(" ");
            add(roadNum2);
          }
        }

        const jibeon = extractJibeon(originalAddr);
        if (jibeon) {
          add(jibeon);
        }

        return candidates;
      }

      async function geocodeWithFallback(originalAddr) {
        const normalized = normalizeAddress(originalAddr);
        const cached = geocodeCache[normalized];
        if (cached) {
          return {
            point: { lat: cached.lat, lng: cached.lng },
            usedAddress: cached.used,
          };
        }
        const cands = buildCandidates(originalAddr);
        for (let i = 0; i < cands.length; i++) {
          const q = cands[i];
          const p = await geocodeNaver(q);
          if (p) {
            geocodeCache[normalized] = { used: q, lat: p.lat, lng: p.lng };
            saveCache();
            return { point: p, usedAddress: q };
          }
        }
        return null;
      }

      document
        .getElementById("geocodeBtn")
        .addEventListener("click", async () => {
          if (!points.length) {
            const raw = addrTextarea.value.trim();
            if (!raw) {
              alert("ì—‘ì…€ì„ ë¶ˆëŸ¬ì˜¤ê±°ë‚˜ ì£¼ì†Œë¥¼ ë¶™ì—¬ë„£ì–´ ì£¼ì„¸ìš”.");
              return;
            }
            const lines = raw
              .split(/\r?\n/)
              .map((s) => normalizeAddress(s))
              .filter(Boolean);
            const seen = new Set();
            points = [];
            lines.forEach((addr) => {
              if (seen.has(addr)) return;
              seen.add(addr);
              points.push({
                original: addr,
                used: null,
                lat: null,
                lng: null,
                failed: false,
                items: [],
                cbmTotal: 0,
                groupIndex: null,
              });
            });
          }

          let success = 0;
          let fail = 0;
          for (let i = 0; i < points.length; i++) {
            const p = points[i];
            if (p.lat != null && p.lng != null && !p.failed) continue;

            statusEl.textContent = `(${i + 1}/${points.length}) "${
              p.original
            }" ì¢Œí‘œ ë³€í™˜ ì¤‘...`;
            try {
              const result = await geocodeWithFallback(p.original);
              if (result && result.point) {
                p.lat = result.point.lat;
                p.lng = result.point.lng;
                p.used = result.usedAddress;
                p.failed = false;
                success++;
              } else {
                p.failed = true;
                fail++;
              }
            } catch {
              p.failed = true;
              fail++;
            }
            await new Promise((r) => setTimeout(r, 120));
          }

          saveState();
          statusEl.textContent = `ì§€ì˜¤ì½”ë”© ì™„ë£Œ: ì„±ê³µ ${success}ê°œ, ì‹¤íŒ¨ ${fail}ê°œ / ì „ì²´ ê°€êµ¬: ${points.length}ê°œ`;
          renderMarkers();
          updateRecommendedGroups();
          updateGroupSummaryAndList();
        });

      // ì¶”ì²œ ê·¸ë£¹ ìˆ˜
      function updateRecommendedGroups() {
        const valid = points.filter(
          (p) =>
            !p.failed && typeof p.lat === "number" && typeof p.lng === "number"
        );
        const n = valid.length;
        const maxSize = parseInt(maxGroupInput.value, 10);

        if (!n || !maxSize || maxSize <= 0) {
          numGroupsInput.value = "";
          groupSummaryEl.textContent = "";
          return;
        }

        const minGroups = Math.ceil(n / maxSize);

        const recommendedGroups = Math.max(minGroups, 1) + 2;

        let currentNumGroups = parseInt(numGroupsInput.value, 10);

        if (isNaN(currentNumGroups) || currentNumGroups < minGroups) {
          numGroupsInput.value = recommendedGroups;
          currentNumGroups = recommendedGroups;
        }

        groupSummaryEl.textContent =
          `í˜„ì¬ ê°€êµ¬ ìˆ˜: ${n}ê°œ / ìµœëŒ€ ${maxSize}ê°€êµ¬ ê¸°ì¤€ ì´ë¡ ìƒ ìµœì†Œ ê·¸ë£¹ ìˆ˜: ${minGroups}ê°œ / ` +
          `ìë™ ì¶”ì²œ ê·¸ë£¹ ìˆ˜: ${recommendedGroups}ê°œ (ìµœì†Œ + 2)`;
      }

      maxGroupInput.addEventListener("change", () => {
        updateRecommendedGroups();
        updateGroupSummaryAndList();
      });

      document.getElementById("groupBtn").addEventListener("click", () => {
        if (!points.length) {
          alert("ë¨¼ì € ì£¼ì†Œ ì§€ì˜¤ì½”ë”©ì„ í•´ì£¼ì„¸ìš”.");
          return;
        }

        updateRecommendedGroups();

        const maxSize = parseInt(maxGroupInput.value, 10);
        let numGroups = parseInt(numGroupsInput.value, 10);

        if (isNaN(numGroups) || numGroups <= 0) {
          alert("ê·¸ë£¹ ìˆ˜ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. 'ìµœëŒ€ ê°€êµ¬ ìˆ˜'ë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš”.");
          return;
        }

        const assignments = groupWithConstraints(maxSize, numGroups);
        if (!assignments) return;

        const maxG = getMaxGroupIndex();
        for (let g = 0; g <= maxG; g++) {
          const key = "g_" + g;
          if (collapsedGroups[key] === undefined) collapsedGroups[key] = true;
        }
        saveCollapseState();

        currentViewFilter = "all";
        updateFilterChips();
        renderMarkers();
        updateGroupSummaryAndList();
      });

      // -----------------------------------------------------------
      // ì§€ë„ ë§ˆì»¤ ë° ë¦¬ìŠ¤íŠ¸ ë Œë”ë§/ì´ë²¤íŠ¸
      // -----------------------------------------------------------

      function clearMarkers() {
        markers.forEach((m) => m.marker.setMap(null));
        markers = [];
      }

      function clearHighlight() {
        document
          .querySelectorAll(".householdItem.highlight")
          .forEach((el) => el.classList.remove("highlight"));
        markers.forEach(({ marker }) => {
          marker.setAnimation(null);
          marker.setZIndex(100);
        });
      }

      function highlightHouseholdAndMarker(idx, { fromList = false } = {}) {
        clearHighlight();
        const p = points[idx];
        if (!p) return;

        const row = document.querySelector(`.householdItem[data-idx="${idx}"]`);
        if (row) {
          row.classList.add("highlight");
          if (!fromList) {
            row.scrollIntoView({ behavior: "smooth", block: "center" });
          }
        }

        markers.forEach(({ marker, idx: mid }) => {
          if (mid === idx) {
            marker.setZIndex(1000);
            marker.setAnimation(naver.maps.Animation.BOUNCE);
            setTimeout(() => marker.setAnimation(null), 1500);
          }
        });
      }

      function renderMarkers() {
        clearMarkers();
        if (!points.length || !map) return;

        const bounds = new naver.maps.LatLngBounds();

        points.forEach((p, idx) => {
          if (p.failed || p.lat == null || p.lng == null) return;

          const pos = new naver.maps.LatLng(p.lat, p.lng);
          bounds.extend(pos);

          const g = p.groupIndex; // 0ë¶€í„° ì‹œì‘í•˜ëŠ” ê·¸ë£¹ ì¸ë±ìŠ¤
          let icon = null;
          if (g != null && g >= 0) {
            const groupNum = g + 1; // í™”ë©´ í‘œì‹œ ê·¸ë£¹ ë²ˆí˜¸ (1ë¶€í„° ì‹œì‘)
            const color = groupColors[g % groupColors.length];
            icon = {
              content: `<div style="
                width:24px;height:24px;border-radius:50%;
                background:${color};
                color:#fff;
                display:flex;
                align-items:center;
                justify-content:center;
                font-size:12px;
                border:2px solid #fff;
                box-shadow:0 0 3px rgba(0,0,0,0.5);
              ">${groupNum}</div>`,
              size: new naver.maps.Size(24, 24),
              anchor: new naver.maps.Point(12, 12),
            };
          }

          const marker = new naver.maps.Marker({
            position: pos,
            map,
            icon: icon || undefined,
          });
          marker._idx = idx;

          naver.maps.Event.addListener(marker, "click", () => {
            highlightHouseholdAndMarker(idx, { fromList: false });
            openMarkerPopup(marker, idx);
          });

          markers.push({ marker, idx });
        });

        if (!bounds.isEmpty()) map.fitBounds(bounds);
      }

      // [í•µì‹¬ ìˆ˜ì • ë¶€ë¶„] íŒì—…ì—ì„œ ê·¸ë£¹ ì •ë³´ê°€ points[idx].groupIndexë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì¼ê´€ë˜ê²Œ í‘œì‹œë˜ë„ë¡ ìˆ˜ì •
      function openMarkerPopup(marker, idx) {
        const p = points[idx];
        if (!p) return;

        // ë§ˆì»¤ì— í‘œì‹œëœ groupIndexë¥¼ ì‚¬ìš© (0ë¶€í„° ì‹œì‘í•˜ëŠ” ì¸ë±ìŠ¤)
        const currentGroupIndex = p.groupIndex;

        const cbmInfo = cbmStatusTag(p.cbmTotal || 0);
        const maxG = getMaxGroupIndex();
        let optionsHtml = `<option value="">ë¯¸ì§€ì •</option>`;

        // ë“œë¡­ë‹¤ìš´: ê°’ì€ ê·¸ë£¹ ì¸ë±ìŠ¤(0, 1, 2...)ë¡œ ì €ì¥
        for (let g = 0; g <= maxG; g++) {
          const selected = currentGroupIndex === g ? "selected" : "";
          optionsHtml += `<option value="${g}" ${selected}>ê·¸ë£¹ ${
            g + 1 // í™”ë©´ í‘œì‹œëŠ” ê·¸ë£¹ ë²ˆí˜¸ + 1
          }</option>`;
        }

        const currentGroupNum =
          currentGroupIndex != null ? currentGroupIndex + 1 : "ë¯¸ì§€ì •";

        let groupSummaryHtml = "";
        if (currentGroupIndex != null && currentGroupIndex >= 0) {
          const members = points.filter(
            (q) =>
              !q.failed &&
              q.lat != null &&
              q.lng != null &&
              q.groupIndex === currentGroupIndex
          );
          const hCount = members.length;
          const itemCount = members.reduce(
            (s, q) => s + (q.items ? q.items.length : 0),
            0
          );
          const cbmSum = members.reduce((s, q) => s + (q.cbmTotal || 0), 0);
          const gInfo = cbmStatusTag(cbmSum || 0);
          groupSummaryHtml = `
            <div style="margin-bottom:6px;padding:6px;border-radius:6px;background:#f9fafb;border:1px dashed #e5e7eb;">
              <div style="font-weight:700;margin-bottom:2px;">ê·¸ë£¹ ${currentGroupNum} ìš”ì•½</div>
              <div style="font-size:11px;line-height:1.5;">
                ê°€êµ¬ ìˆ˜: ${hCount}ê°œ Â· í’ˆëª© ìˆ˜: ${itemCount}ê°œ<br/>
                <span class="cbmBadge ${gInfo.cls}" style="font-size:11px;">${gInfo.text}</span>
              </div>
            </div>`;
        }

        const itemsHtml =
          p.items && p.items.length
            ? `<ul style="margin:4px 0 0 18px;padding:0;font-size:11px;color:#374151;">
                ${p.items
                  .map(
                    (it) => `<li>${it.name ? it.name : "(í’ˆëª©ëª… ì—†ìŒ)"}</li>`
                  )
                  .join("")}
               </ul>`
            : "<div style='font-size:11px;color:#6b7280;margin-top:4px;'>í’ˆëª© ì •ë³´ ì—†ìŒ</div>";

        const html = `
          <div style="padding:8px 10px;font-size:12px;max-width:340px;">
            ${
              currentGroupIndex != null && currentGroupIndex >= 0
                ? `<div style="font-weight:700;margin-bottom:4px;">ê·¸ë£¹ ${currentGroupNum}</div>`
                : ""
            }
            ${groupSummaryHtml}
            <div style="font-weight:600;margin-bottom:2px;">ì›ë³¸ ì£¼ì†Œ</div>
            <div style="margin-bottom:4px;">${p.original}</div>
            ${
              p.used && p.used !== p.original
                ? `<div style="font-weight:600;margin-top:4px;margin-bottom:2px;">ê²€ìƒ‰ì— ì‚¬ìš©í•œ ì£¼ì†Œ</div>
                   <div style="margin-bottom:6px;">${p.used}</div>`
                : ""
            }
            <div style="font-size:11px;color:#6b7280;margin-bottom:4px;">
              ${p.lat ? p.lat.toFixed(6) : "ì¢Œí‘œ ì—†ìŒ"}, ${
          p.lng ? p.lng.toFixed(6) : "ì¢Œí‘œ ì—†ìŒ"
        }
            </div>
            <hr style="border:none;border-top:1px solid #e5e7eb;margin:4px 0;" />
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
              <div style="font-weight:600;">CBM (ì´ ê°€êµ¬)</div>
              <div class="cbmBadge ${cbmInfo.cls}" style="font-size:11px;">
                ${cbmInfo.text}
              </div>
            </div>
            <div style="margin-bottom:6px;">
              <label style="font-size:11px;">ê·¸ë£¹ ë³€ê²½:
                <select id="popupGroupSelect_${idx}" style="font-size:11px;margin-left:4px;">
                  ${optionsHtml}
                </select>
              </label>
            </div>
            <div style="margin-top:4px;font-weight:600;">í’ˆëª© (${
              p.items ? p.items.length : 0
            }ê°œ)</div>
            ${itemsHtml}
          </div>
        `;

        infoWindow.setContent(html);
        infoWindow.open(map, marker);

        setTimeout(() => {
          const sel = document.getElementById(`popupGroupSelect_${idx}`);
          if (!sel) return;
          sel.onchange = () => {
            const val = sel.value === "" ? null : parseInt(sel.value, 10);

            const p = points[idx];

            if (val != null && (p.lat == null || p.lng == null)) {
              alert(
                "ì¢Œí‘œê°€ ì—†ëŠ” ê°€êµ¬ëŠ” ê·¸ë£¹ì— í• ë‹¹í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ë¯¸ì§€ì •ìœ¼ë¡œ ì¬ì„¤ì •ë©ë‹ˆë‹¤)"
              );
              p.groupIndex = null;
              sel.value = "";
            } else {
              p.groupIndex = val;
            }

            saveState();
            // ê·¸ë£¹ì´ ë³€ê²½ë˜ì—ˆìœ¼ë¯€ë¡œ ë¦¬ìŠ¤íŠ¸ì™€ ë§ˆì»¤ ëª¨ë‘ ì¬ë Œë”ë§í•˜ì—¬ ë™ê¸°í™”
            renderMarkers();
            updateGroupSummaryAndList();
          };
        }, 0);
      }

      function updateGroupSummaryAndList() {
        const grouped = {};
        const unassigned = [];
        const failed = [];

        points.forEach((p, idx) => {
          // [í•µì‹¬ ê²€ì¦] ì¢Œí‘œê°€ ì—†ê±°ë‚˜ ì‹¤íŒ¨í•œ ê²½ìš°, groupIndexë¥¼ ë¬´ì¡°ê±´ nullë¡œ ì„¤ì •í•˜ì—¬ ë¯¸ì§€ì •/ì‹¤íŒ¨ ê·¸ë£¹ìœ¼ë¡œ ë¶„ë¥˜
          if (p.failed || p.lat == null || p.lng == null) {
            failed.push({ p, idx });
            p.groupIndex = null; // ê°•ì œ null ì²˜ë¦¬
          } else if (p.groupIndex == null || p.groupIndex < 0) {
            unassigned.push({ p, idx });
            p.groupIndex = null;
          } else {
            const g = p.groupIndex;
            if (!grouped[g]) grouped[g] = [];
            grouped[g].push({ p, idx });
          }
        });

        const groupIndices = Object.keys(grouped)
          .map((x) => parseInt(x, 10))
          .sort((a, b) => a - b);

        const validCount = points.filter(
          (p) =>
            !p.failed && typeof p.lat === "number" && typeof p.lng === "number"
        ).length;
        const maxSize = parseInt(maxGroupInput.value, 10) || 0;
        const minGroups = maxSize ? Math.ceil(validCount / maxSize) : 0;

        groupIndices.forEach((g) => {
          const key = "g_" + g;
          if (collapsedGroups[key] === undefined) {
            collapsedGroups[key] = true;
          }
        });
        saveCollapseState();

        const view = currentViewFilter;
        groupSummaryEl.textContent =
          `ê·¸ë£¹ ìˆ˜: ${groupIndices.length}ê°œ (ì¢Œí‘œ ìˆìŒ: ${validCount}ê°€êµ¬ / ì¢Œí‘œ ì—†ìŒ: ${failed.length}ê°€êµ¬) / ` +
          `ì¶”ì²œ ê·¸ë£¹ ìˆ˜(ìµœëŒ€ ${maxSize || "-"}ê°€êµ¬ ê¸°ì¤€): ${
            minGroups || "-"
          }ê°œ`;

        let html = "";
        groupIndices.forEach((g) => {
          const list = grouped[g];
          if (view === "unassigned") return;

          const groupSize = list.length;
          const groupItems = list.reduce((s, it) => s + it.p.items.length, 0);
          const totalCbm = list.reduce((s, it) => s + (it.p.cbmTotal || 0), 0);
          const cbmInfo = cbmStatusTag(totalCbm);
          const color = groupColors[g % groupColors.length];
          const key = "g_" + g;
          const isCollapsed = !!collapsedGroups[key];
          const groupNum = g + 1; // í™”ë©´ í‘œì‹œ ê·¸ë£¹ ë²ˆí˜¸

          const groupCity = list.reduce((map, it) => {
            const city = getCityFromAddress(it.p.original);
            map[city] = (map[city] || 0) + 1;
            return map;
          }, {});
          const cities = Object.keys(groupCity).sort(
            (a, b) => groupCity[b] - groupCity[a]
          );
          const primaryCity = cities.length > 0 ? cities[0] : "";
          const cityTag =
            primaryCity && primaryCity !== "UNKNOWN"
              ? primaryCity.replace("ì‹œ", "")
              : "í˜¼í•©";

          html += `<div class="groupCard ${
            isCollapsed ? "collapsed" : ""
          }" data-group="${g}" style="border-color:${color}33;">
            <div class="groupHeader" style="background:${color}18;">
              <div class="groupHeaderMain">
                <span class="groupToggleIcon">â–¾</span>
                <span class="groupTitle">ê·¸ë£¹ ${groupNum} (${groupSize} ê°€êµ¬, í’ˆëª© ${groupItems}ê°œ)</span>
                <span class="groupTag">${cityTag} ì£¼ì¶•</span>
              </div>
              <div class="cbmBadge ${cbmInfo.cls}">${cbmInfo.text}</div>
            </div>
          `;

          list.forEach(({ p, idx }) => {
            html += renderHouseholdRow(p, idx);
          });

          html += `</div>`;
        });

        if (unassigned.length && view !== "grouped") {
          const groupItems = unassigned.reduce(
            (s, it) => s + it.p.items.length,
            0
          );
          const totalCbm = unassigned.reduce(
            (s, it) => s + (it.p.cbmTotal || 0),
            0
          );
          const cbmInfo = cbmStatusTag(totalCbm);
          const key = "g_unassigned";
          const isCollapsed = !!collapsedGroups[key];

          html += `<div class="groupCard ${
            isCollapsed ? "collapsed" : ""
          }" data-group="unassigned" style="border-color:#9ca3af55;">
            <div class="groupHeader" style="background:#e5e7eb;">
              <div class="groupHeaderMain">
                <span class="groupToggleIcon">â–¾</span>
                <span class="groupTitle">ë¯¸ì§€ì • ê·¸ë£¹ (${
                  unassigned.length
                } ê°€êµ¬, í’ˆëª© ${groupItems}ê°œ)</span>
              </div>
              <div class="cbmBadge ${cbmInfo.cls}">${cbmInfo.text}</div>
            </div>
          `;
          unassigned.forEach(({ p, idx }) => {
            html += renderHouseholdRow(p, idx);
          });
          html += `</div>`;
        }

        if (failed.length && view !== "grouped") {
          const key = "g_failed";
          const isCollapsed = !!collapsedGroups[key];

          html += `<div class="groupCard ${
            isCollapsed ? "collapsed" : ""
          }" data-group="failed" style="border-color:#fca5a5;">
            <div class="groupHeader" style="background:#fee2e2;">
              <div class="groupHeaderMain">
                <span class="groupToggleIcon">â–¾</span>
                <span class="groupTitle">ì§€ì˜¤ì½”ë”© ì‹¤íŒ¨ (${
                  failed.length
                } ê°€êµ¬)</span>
              </div>
              <div class="cbmBadge cbm-danger">ì¢Œí‘œ ì—†ìŒ</div>
            </div>`;
          failed.forEach(({ p, idx }) => {
            html += renderHouseholdRow(p, idx, true);
          });
          html += `</div>`;
        }

        groupListWrapper.innerHTML = html;
        attachGroupListEvents();
      }

      function renderHouseholdRow(p, idx, isFailed) {
        const cbmInfo = cbmStatusTag(p.cbmTotal || 0);
        const maxG = getMaxGroupIndex();
        let groupOptions = `<option value="">ë¯¸ì§€ì •</option>`;

        // ë“œë¡­ë‹¤ìš´ ì˜µì…˜: valueëŠ” ì¸ë±ìŠ¤(0ë¶€í„°), í…ìŠ¤íŠ¸ëŠ” ë²ˆí˜¸(1ë¶€í„°)
        for (let g = 0; g <= maxG; g++) {
          const selected = p.groupIndex === g ? "selected" : "";
          groupOptions += `<option value="${g}" ${selected}>ê·¸ë£¹ ${
            g + 1
          }</option>`;
        }

        const widthPercent = Math.min(100, ((p.cbmTotal || 0) / 10) * 100);
        const selectValue = p.groupIndex != null ? p.groupIndex : "";

        return `
          <div class="householdItem" data-idx="${idx}" draggable="true">
            <div class="householdLine">
              <div style="flex:1;min-width:0;">
                <div class="addrMain">${p.original}</div>
                <div class="addrSub">
                  ${cbmInfo.text} / ${getCityFromAddress(p.original)}
                </div>
              </div>
              ${
                isFailed
                  ? ""
                  : `<select class="groupSelect" data-idx="${idx}" value="${selectValue}">
                      ${groupOptions}
                     </select>`
              }
            </div>
            <div class="cbmBar">
              <div class="cbmBarInner ${
                cbmInfo.cls
              }" style="width:${widthPercent}%;"></div>
            </div>
            ${
              p.items && p.items.length
                ? `<ul class="itemList">
                    ${p.items
                      .map(
                        (it) =>
                          `<li>${it.name ? it.name : "(í’ˆëª©ëª… ì—†ìŒ)"}</li>`
                      )
                      .join("")}
                   </ul>`
                : ""
            }
          </div>
        `;
      }

      function attachGroupListEvents() {
        // ê·¸ë£¹ ì¹´ë“œ hover -> ë§ˆì»¤ ê°•ì¡°
        document.querySelectorAll(".groupCard").forEach((card) => {
          const gAttr = card.getAttribute("data-group");
          if (gAttr === "unassigned" || gAttr === "failed") return;
          const g = parseInt(gAttr, 10);
          card.addEventListener("mouseenter", () => {
            card.classList.add("highlight");
            markers.forEach(({ marker, idx }) => {
              if (points[idx].groupIndex === g) {
                marker.setZIndex(900);
              }
            });
          });
          card.addEventListener("mouseleave", () => {
            card.classList.remove("highlight");
            markers.forEach(({ marker }) => {
              marker.setZIndex(100);
            });
          });

          // ë“œë¡­ ëŒ€ìƒ
          card.addEventListener("dragover", (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = "move";
          });
          card.addEventListener("drop", (e) => {
            e.preventDefault();
            if (draggingIdx == null) return;
            const attr = card.getAttribute("data-group");
            if (attr === "failed") return;

            let newGroup = null;
            if (attr !== "unassigned") newGroup = parseInt(attr, 10);

            const p = points[draggingIdx];

            if (newGroup != null && (p.lat == null || p.lng == null)) {
              alert(
                "ì¢Œí‘œê°€ ì—†ëŠ” ê°€êµ¬ëŠ” ê·¸ë£¹ì— í• ë‹¹í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ë¯¸ì§€ì • ê·¸ë£¹ë§Œ ê°€ëŠ¥)"
              );
              points[draggingIdx].groupIndex = null;
              newGroup = null;
            }

            points[draggingIdx].groupIndex = newGroup;
            saveState();
            renderMarkers();
            updateGroupSummaryAndList();
          });
        });

        // í—¤ë” í´ë¦­ ì‹œ ì ‘ê¸°/í¼ì¹˜ê¸°
        document.querySelectorAll(".groupHeader").forEach((header) => {
          header.addEventListener("click", (e) => {
            const card = header.closest(".groupCard");
            const gAttr = card.getAttribute("data-group");
            const key = "g_" + gAttr;
            const collapsed = card.classList.toggle("collapsed");
            collapsedGroups[key] = collapsed;
            saveCollapseState();
          });
        });

        // ê°€êµ¬ hover -> í•´ë‹¹ ë§ˆì»¤ í¬ê²Œ ë³´ì—¬ì£¼ê¸° + ë™ê¸°í™”
        document.querySelectorAll(".householdItem").forEach((itemEl) => {
          const idx = parseInt(itemEl.getAttribute("data-idx"), 10);
          const p = points[idx];
          if (!p) return;

          itemEl.addEventListener("mouseenter", () => {
            if (!p.failed && p.lat != null && p.lng != null) {
              const pos = new naver.maps.LatLng(p.lat, p.lng);
              map.setCenter(pos);
              map.setZoom(13);
              highlightHouseholdAndMarker(idx, { fromList: true });
            }
          });
          itemEl.addEventListener("mouseleave", () => {
            clearHighlight();
          });

          // ë“œë˜ê·¸ ì‹œì‘/ë
          itemEl.addEventListener("dragstart", (e) => {
            draggingIdx = idx;
            itemEl.classList.add("dragging");
            e.dataTransfer.effectAllowed = "move";
          });
          itemEl.addEventListener("dragend", () => {
            draggingIdx = null;
            itemEl.classList.remove("dragging");
          });
        });

        // ë“œë¡­ë‹¤ìš´ìœ¼ë¡œ ê·¸ë£¹ ë³€ê²½
        document.querySelectorAll("select.groupSelect").forEach((sel) => {
          sel.addEventListener("change", () => {
            const idx = parseInt(sel.getAttribute("data-idx"), 10);
            const val = sel.value === "" ? null : parseInt(sel.value, 10);

            const p = points[idx];

            if (val != null && (p.lat == null || p.lng == null)) {
              alert(
                "ì¢Œí‘œê°€ ì—†ëŠ” ê°€êµ¬ëŠ” ê·¸ë£¹ì— í• ë‹¹í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ë¯¸ì§€ì •ìœ¼ë¡œ ì¬ì„¤ì •ë©ë‹ˆë‹¤)"
              );
              p.groupIndex = null;
              sel.value = "";
            } else {
              p.groupIndex = val;
            }

            saveState();
            renderMarkers();
            updateGroupSummaryAndList();
          });
        });
      }

      // ë³´ê¸° í•„í„°
      document.querySelectorAll("#viewFilter .chip").forEach((chip) => {
        chip.addEventListener("click", () => {
          currentViewFilter = chip.getAttribute("data-view");
          updateFilterChips();
          updateGroupSummaryAndList();
        });
      });

      // ëª©ë¡ ì´ˆê¸°í™”
      document.getElementById("resetListBtn").addEventListener("click", () => {
        if (
          !confirm(
            "í˜„ì¬ ì£¼ì†Œ/ê·¸ë£¹ ëª©ë¡ì„ ì´ˆê¸°í™”í• ê¹Œìš”? (ì§€ì˜¤ì½”ë”© ìºì‹œëŠ” ìœ ì§€ë©ë‹ˆë‹¤)"
          )
        )
          return;
        points = [];
        collapsedGroups = {
          g_unassigned: true,
          g_failed: true,
        };
        saveCollapseState();

        saveState();
        addrTextarea.value = "";
        clearMarkers();
        groupListWrapper.innerHTML = "";
        statusEl.textContent = "ëª©ë¡ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.";
        groupSummaryEl.textContent = "";
      });

      // ì—‘ì…€ ë‚´ë³´ë‚´ê¸°
      document.getElementById("exportBtn").addEventListener("click", () => {
        if (!excelInput.files[0]) {
          alert("ë¨¼ì € ì—‘ì…€ íŒŒì¼ì„ ë¶ˆëŸ¬ì™€ ì£¼ì„¸ìš”.");
          return;
        }

        const file = excelInput.files[0];
        const reader = new FileReader();
        reader.onload = (ev) => {
          const data = new Uint8Array(ev.target.result);
          const wb = XLSX.read(data, { type: "array" });
          const sheetName = wb.SheetNames[0];
          const sheet = wb.Sheets[sheetName];
          const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });

          const addrCol = parseInt(addrColInput.value, 10) - 1;
          const addrToGroup = new Map();
          points.forEach((p) => {
            const key = normalizeAddress(p.original);
            const g =
              p.groupIndex == null || p.groupIndex < 0
                ? "ë¯¸ì§€ì •"
                : `ê·¸ë£¹ ${p.groupIndex + 1}`;
            addrToGroup.set(key, g);
          });

          const outRows = rows.map((row) => {
            const newRow = row.slice();
            const addr = normalizeAddress(row[addrCol] || "");
            const g = addrToGroup.get(addr) || "";

            // ê¸°ì¡´ ì—´ì— ê·¸ë£¹ ì •ë³´ê°€ ì¶”ê°€ë  ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ìƒˆë¡œìš´ ì—´ì— ì¶”ê°€
            // (ê°€ì¥ ë§ˆì§€ë§‰ ì—´ì— ì¶”ê°€)
            newRow.push(g);
            return newRow;
          });

          // í—¤ë” í–‰ì— 'ê·¸ë£¹' ì—´ ì¶”ê°€
          if (outRows.length > 0) {
            outRows[0].push("ê·¸ë£¹");
          }

          const newSheet = XLSX.utils.aoa_to_sheet(outRows);
          const outWb = XLSX.utils.book_new();
          XLSX.utils.book_append_sheet(outWb, newSheet, "ê²°ê³¼");

          const wbout = XLSX.write(outWb, {
            bookType: "xlsx",
            type: "array",
          });
          const blob = new Blob([wbout], {
            type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
          });
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = `grouped_result_${new Date()
            .toISOString()
            .slice(0, 10)}.xlsx`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        };
        reader.readAsArrayBuffer(file);
      });

      // ì„¤ì • íŒ¨ë„ ì ‘ê¸°/í¼ì¹˜ê¸°
      const settingsPanel = document.getElementById("settingsPanel");
      const toggleSettingsBtn = document.getElementById("toggleSettingsBtn");
      toggleSettingsBtn.addEventListener("click", () => {
        const collapsed = settingsPanel.classList.toggle("collapsed");
        toggleSettingsBtn.textContent = collapsed ? "í¼ì¹˜ê¸°" : "ì ‘ê¸°";
      });

      // ì¢Œì¸¡ íŒ¨ë„ ìˆ¨ê¸°ê¸°
      const sidebar = document.getElementById("sidebar");
      const toggleSidebarBtn = document.getElementById("toggleSidebarBtn");
      toggleSidebarBtn.addEventListener("click", () => {
        const hidden = sidebar.classList.toggle("hidden");
        toggleSidebarBtn.textContent = hidden ? "ì„¤ì • ë³´ê¸°" : "ì§€ë„ë§Œ ë³´ê¸°";
      });
    </script>
  </body>
</html>
